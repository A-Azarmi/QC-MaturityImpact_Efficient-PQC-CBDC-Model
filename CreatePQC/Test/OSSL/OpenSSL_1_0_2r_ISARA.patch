# @copyright Copyright (C) 2017-2019, ISARA Corporation, All Rights Reserved.

diff --git a/openssl-1.0.2r/Makefile.org b/openssl-1.0.2r/Makefile.org
index 8089d3fc..49e05c05 100644
--- a/openssl-1.0.2r/Makefile.org
+++ b/openssl-1.0.2r/Makefile.org
@@ -61,7 +61,7 @@ CC= cc
 CFLAG= -O
 DEPFLAG= 
 PEX_LIBS= 
-EX_LIBS= 
+EX_LIBS= -L/usr/local/iqr/lib/ -liqr_toolkit
 EXE_EXT= 
 ARFLAGS=
 AR=ar $(ARFLAGS) r
@@ -145,6 +145,8 @@ SHLIBDIRS= crypto ssl
 SDIRS=  \
 	objects \
 	md2 md4 md5 sha mdc2 hmac ripemd whrlpool \
+	cmc frododh hss nhdh ntrup kyber frodokem rainbow sidh dilithium sike \
+	xmss xmssmt sphincs samwise \
 	des aes rc2 rc4 rc5 idea bf cast camellia seed modes \
 	bn ec rsa dsa ecdsa dh ecdh dso engine \
 	buffer bio stack lhash rand err \
diff --git a/openssl-1.0.2r/apps/Makefile b/openssl-1.0.2r/apps/Makefile
index 8c3297ea..36427733 100644
--- a/openssl-1.0.2r/apps/Makefile
+++ b/openssl-1.0.2r/apps/Makefile
@@ -39,7 +39,10 @@ E_EXE=	verify asn1pars req dgst dh dhparam enc passwd gendh errstr \
 	ca crl rsa rsautl dsa dsaparam ec ecparam \
 	x509 genrsa gendsa genpkey s_server s_client speed \
 	s_time version pkcs7 cms crl2pkcs7 sess_id ciphers nseq pkcs12 \
-	pkcs8 pkey pkeyparam pkeyutl spkac smime rand engine ocsp prime ts srp
+	pkcs8 pkey pkeyparam pkeyutl spkac smime rand engine ocsp prime ts srp \
+	reqQSExtend x509QSDirectExtend x509QSExtend x509QSVerify cmsQSExtend \
+	cmsQSVerify pkcs12QSExtend
+
 
 PROGS= $(PROGRAM).c
 
@@ -56,7 +59,10 @@ E_OBJ=	verify.o asn1pars.o req.o dgst.o dh.o dhparam.o enc.o passwd.o gendh.o er
 	x509.o genrsa.o gendsa.o genpkey.o s_server.o s_client.o speed.o \
 	s_time.o $(A_OBJ) $(S_OBJ) $(RAND_OBJ) version.o sess_id.o \
 	ciphers.o nseq.o pkcs12.o pkcs8.o pkey.o pkeyparam.o pkeyutl.o \
-	spkac.o smime.o cms.o rand.o engine.o ocsp.o prime.o ts.o srp.o
+	spkac.o smime.o cms.o rand.o engine.o ocsp.o prime.o ts.o srp.o \
+	QSExtend/reqQSExtend.o QSExtend/x509QSDirectExtend.o \
+	QSExtend/x509QSExtend.o QSExtend/x509QSVerify.o QSExtend/cmsQSExtend.o \
+	QSExtend/cmsQSVerify.o QSExtend/pkcs12QSExtend.o
 
 E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c passwd.c gendh.c errstr.c ca.c \
 	pkcs7.c crl2p7.c crl.c \
@@ -64,7 +70,10 @@ E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c passwd.c gendh.c errstr.c ca.
 	x509.c genrsa.c gendsa.c genpkey.c s_server.c s_client.c speed.c \
 	s_time.c $(A_SRC) $(S_SRC) $(RAND_SRC) version.c sess_id.c \
 	ciphers.c nseq.c pkcs12.c pkcs8.c pkey.c pkeyparam.c pkeyutl.c \
-	spkac.c smime.c cms.c rand.c engine.c ocsp.c prime.c ts.c srp.c
+	spkac.c smime.c cms.c rand.c engine.c ocsp.c prime.c ts.c srp.c \
+	QSExtend/reqQSExtend.c QSExtend/x509QSDirectExtend.c \
+	QSExtend/x509QSExtend.c QSExtend/x509QSVerify.c QSExtend/cmsQSExtend.c \
+	QSExtend/cmsQSVerify.c QSExtend/pkcs12QSExtend.c
 
 SRC=$(E_SRC)
 
@@ -145,6 +154,7 @@ dclean:
 clean:
 	rm -f *.o *.obj *.dll lib tags core .pure .nfs* *.old *.bak fluff $(EXE)
 	rm -f req
+	rm -f QSExtend/*.o
 
 $(DLIBSSL):
 	(cd ..; $(MAKE) build_libssl)
@@ -355,22 +365,23 @@ dsa.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h dsa.c
 dsaparam.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 dsaparam.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 dsaparam.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-dsaparam.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-dsaparam.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-dsaparam.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-dsaparam.o: ../include/openssl/engine.h ../include/openssl/err.h
-dsaparam.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+dsaparam.o: ../include/openssl/dh.h ../include/openssl/dilithium.h
+dsaparam.o: ../include/openssl/dsa.h ../include/openssl/e_os2.h
+dsaparam.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+dsaparam.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+dsaparam.o: ../include/openssl/err.h ../include/openssl/evp.h
+dsaparam.o: ../include/openssl/lhash.h ../include/openssl/lms.h
 dsaparam.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
 dsaparam.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
 dsaparam.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 dsaparam.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-dsaparam.o: ../include/openssl/pkcs7.h ../include/openssl/rand.h
-dsaparam.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-dsaparam.o: ../include/openssl/sha.h ../include/openssl/stack.h
-dsaparam.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
-dsaparam.o: ../include/openssl/ui.h ../include/openssl/x509.h
-dsaparam.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
-dsaparam.o: dsaparam.c
+dsaparam.o: ../include/openssl/pkcs7.h ../include/openssl/rainbow.h
+dsaparam.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+dsaparam.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+dsaparam.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+dsaparam.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
+dsaparam.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+dsaparam.o: ../include/openssl/x509v3.h apps.h dsaparam.c
 ec.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 ec.o: ../include/openssl/buffer.h ../include/openssl/conf.h
 ec.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
@@ -463,22 +474,23 @@ errstr.o: ../include/openssl/x509v3.h apps.h errstr.c
 gendh.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 gendh.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 gendh.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-gendh.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-gendh.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-gendh.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-gendh.o: ../include/openssl/engine.h ../include/openssl/err.h
-gendh.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+gendh.o: ../include/openssl/dh.h ../include/openssl/dilithium.h
+gendh.o: ../include/openssl/dsa.h ../include/openssl/e_os2.h
+gendh.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+gendh.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+gendh.o: ../include/openssl/err.h ../include/openssl/evp.h
+gendh.o: ../include/openssl/lhash.h ../include/openssl/lms.h
 gendh.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
 gendh.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
 gendh.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 gendh.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-gendh.o: ../include/openssl/pkcs7.h ../include/openssl/rand.h
-gendh.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-gendh.o: ../include/openssl/sha.h ../include/openssl/stack.h
-gendh.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
-gendh.o: ../include/openssl/ui.h ../include/openssl/x509.h
-gendh.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
-gendh.o: gendh.c
+gendh.o: ../include/openssl/pkcs7.h ../include/openssl/rainbow.h
+gendh.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+gendh.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+gendh.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+gendh.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
+gendh.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+gendh.o: ../include/openssl/x509v3.h apps.h gendh.c
 gendsa.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 gendsa.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 gendsa.o: ../include/openssl/conf.h ../include/openssl/crypto.h
@@ -515,22 +527,23 @@ genpkey.o: genpkey.c
 genrsa.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 genrsa.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 genrsa.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-genrsa.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-genrsa.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-genrsa.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-genrsa.o: ../include/openssl/engine.h ../include/openssl/err.h
-genrsa.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+genrsa.o: ../include/openssl/dh.h ../include/openssl/dilithium.h
+genrsa.o: ../include/openssl/dsa.h ../include/openssl/e_os2.h
+genrsa.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+genrsa.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+genrsa.o: ../include/openssl/err.h ../include/openssl/evp.h
+genrsa.o: ../include/openssl/lhash.h ../include/openssl/lms.h
 genrsa.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
 genrsa.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
 genrsa.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 genrsa.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-genrsa.o: ../include/openssl/pkcs7.h ../include/openssl/rand.h
-genrsa.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-genrsa.o: ../include/openssl/sha.h ../include/openssl/stack.h
-genrsa.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
-genrsa.o: ../include/openssl/ui.h ../include/openssl/x509.h
-genrsa.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
-genrsa.o: genrsa.c
+genrsa.o: ../include/openssl/pkcs7.h ../include/openssl/rainbow.h
+genrsa.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+genrsa.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+genrsa.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+genrsa.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
+genrsa.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+genrsa.o: ../include/openssl/x509v3.h apps.h genrsa.c
 nseq.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 nseq.o: ../include/openssl/buffer.h ../include/openssl/conf.h
 nseq.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
@@ -735,21 +748,41 @@ rand.o: ../include/openssl/x509v3.h apps.h rand.c
 req.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 req.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 req.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-req.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-req.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-req.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-req.o: ../include/openssl/engine.h ../include/openssl/err.h
-req.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+req.o: ../include/openssl/dh.h ../include/openssl/dilithium.h
+req.o: ../include/openssl/dsa.h ../include/openssl/e_os2.h
+req.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+req.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+req.o: ../include/openssl/err.h ../include/openssl/evp.h
+req.o: ../include/openssl/lhash.h ../include/openssl/lms.h
 req.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
 req.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
 req.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 req.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-req.o: ../include/openssl/pkcs7.h ../include/openssl/rand.h
-req.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-req.o: ../include/openssl/sha.h ../include/openssl/stack.h
-req.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
-req.o: ../include/openssl/ui.h ../include/openssl/x509.h
-req.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h req.c
+req.o: ../include/openssl/pkcs7.h ../include/openssl/rainbow.h
+req.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+req.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+req.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+req.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
+req.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+req.o: ../include/openssl/x509v3.h apps.h req.c
+reqQSExtend.o: ../apps_QSExtend/../apps/apps.h
+reqQSExtend.o: ../apps_QSExtend/reqQSExtend.c ../e_os.h
+reqQSExtend.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+reqQSExtend.o: ../include/openssl/buffer.h ../include/openssl/conf.h
+reqQSExtend.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+reqQSExtend.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+reqQSExtend.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+reqQSExtend.o: ../include/openssl/err.h ../include/openssl/evp.h
+reqQSExtend.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+reqQSExtend.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
+reqQSExtend.o: ../include/openssl/opensslconf.h
+reqQSExtend.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+reqQSExtend.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+reqQSExtend.o: ../include/openssl/pkcs7.h ../include/openssl/safestack.h
+reqQSExtend.o: ../include/openssl/sha.h ../include/openssl/stack.h
+reqQSExtend.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
+reqQSExtend.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+reqQSExtend.o: ../include/openssl/x509v3.h reqQSExtend.c
 rsa.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 rsa.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 rsa.o: ../include/openssl/conf.h ../include/openssl/crypto.h
@@ -831,27 +864,28 @@ s_server.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 s_server.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 s_server.o: ../include/openssl/comp.h ../include/openssl/conf.h
 s_server.o: ../include/openssl/crypto.h ../include/openssl/dh.h
-s_server.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-s_server.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-s_server.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-s_server.o: ../include/openssl/engine.h ../include/openssl/err.h
-s_server.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s_server.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+s_server.o: ../include/openssl/dilithium.h ../include/openssl/dsa.h
+s_server.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+s_server.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+s_server.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+s_server.o: ../include/openssl/err.h ../include/openssl/evp.h
+s_server.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s_server.o: ../include/openssl/lhash.h ../include/openssl/lms.h
 s_server.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
 s_server.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
 s_server.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 s_server.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 s_server.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-s_server.o: ../include/openssl/rand.h ../include/openssl/rsa.h
-s_server.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-s_server.o: ../include/openssl/srp.h ../include/openssl/srtp.h
-s_server.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-s_server.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-s_server.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-s_server.o: ../include/openssl/tls1.h ../include/openssl/txt_db.h
-s_server.o: ../include/openssl/ui.h ../include/openssl/x509.h
-s_server.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
-s_server.o: s_apps.h s_server.c timeouts.h
+s_server.o: ../include/openssl/rainbow.h ../include/openssl/rand.h
+s_server.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s_server.o: ../include/openssl/sha.h ../include/openssl/srp.h
+s_server.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+s_server.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+s_server.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+s_server.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+s_server.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
+s_server.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+s_server.o: ../include/openssl/x509v3.h apps.h s_apps.h s_server.c timeouts.h
 s_socket.o: ../e_os.h ../e_os2.h ../include/openssl/asn1.h
 s_socket.o: ../include/openssl/bio.h ../include/openssl/buffer.h
 s_socket.o: ../include/openssl/comp.h ../include/openssl/conf.h
@@ -1057,3 +1091,60 @@ x509.o: ../include/openssl/sha.h ../include/openssl/stack.h
 x509.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
 x509.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 x509.o: ../include/openssl/x509v3.h apps.h x509.c
+x509QSDirectExtend.o: ../apps_QSExtend/../apps/apps.h
+x509QSDirectExtend.o: ../apps_QSExtend/x509QSDirectExtend.c ../e_os.h
+x509QSDirectExtend.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+x509QSDirectExtend.o: ../include/openssl/buffer.h ../include/openssl/conf.h
+x509QSDirectExtend.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+x509QSDirectExtend.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+x509QSDirectExtend.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+x509QSDirectExtend.o: ../include/openssl/err.h ../include/openssl/evp.h
+x509QSDirectExtend.o: ../include/openssl/lhash.h
+x509QSDirectExtend.o: ../include/openssl/obj_mac.h
+x509QSDirectExtend.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
+x509QSDirectExtend.o: ../include/openssl/opensslconf.h
+x509QSDirectExtend.o: ../include/openssl/opensslv.h
+x509QSDirectExtend.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+x509QSDirectExtend.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+x509QSDirectExtend.o: ../include/openssl/safestack.h
+x509QSDirectExtend.o: ../include/openssl/sha.h ../include/openssl/stack.h
+x509QSDirectExtend.o: ../include/openssl/symhacks.h
+x509QSDirectExtend.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
+x509QSDirectExtend.o: ../include/openssl/x509_vfy.h
+x509QSDirectExtend.o: ../include/openssl/x509v3.h x509QSDirectExtend.c
+x509QSExtend.o: ../apps_QSExtend/../apps/apps.h
+x509QSExtend.o: ../apps_QSExtend/x509QSExtend.c ../e_os.h
+x509QSExtend.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+x509QSExtend.o: ../include/openssl/buffer.h ../include/openssl/conf.h
+x509QSExtend.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+x509QSExtend.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+x509QSExtend.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+x509QSExtend.o: ../include/openssl/err.h ../include/openssl/evp.h
+x509QSExtend.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+x509QSExtend.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
+x509QSExtend.o: ../include/openssl/opensslconf.h
+x509QSExtend.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+x509QSExtend.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+x509QSExtend.o: ../include/openssl/pkcs7.h ../include/openssl/safestack.h
+x509QSExtend.o: ../include/openssl/sha.h ../include/openssl/stack.h
+x509QSExtend.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
+x509QSExtend.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+x509QSExtend.o: ../include/openssl/x509v3.h x509QSExtend.c
+x509QSVerify.o: ../apps_QSExtend/../apps/apps.h
+x509QSVerify.o: ../apps_QSExtend/x509QSVerify.c ../e_os.h
+x509QSVerify.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+x509QSVerify.o: ../include/openssl/buffer.h ../include/openssl/conf.h
+x509QSVerify.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+x509QSVerify.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+x509QSVerify.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+x509QSVerify.o: ../include/openssl/err.h ../include/openssl/evp.h
+x509QSVerify.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+x509QSVerify.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
+x509QSVerify.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+x509QSVerify.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+x509QSVerify.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+x509QSVerify.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+x509QSVerify.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+x509QSVerify.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
+x509QSVerify.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h
+x509QSVerify.o: x509QSVerify.c
diff --git a/openssl-1.0.2r/apps/QSExtend/cmsQSExtend.c b/openssl-1.0.2r/apps/QSExtend/cmsQSExtend.c
new file mode 100644
index 00000000..bcb3f2a6
--- /dev/null
+++ b/openssl-1.0.2r/apps/QSExtend/cmsQSExtend.c
@@ -0,0 +1,339 @@
+/** @file cmsQSExtend.c Load QS private key and traditional signed cms
+ * message with MPKA certificate and sign it.
+ *
+ * @copyright Copyright (C) 2018-2019, ISARA Corporation, All Rights Reserved.
+ */
+
+/* Modified.  Was genpkey.c.
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+#include <openssl/cms.h>
+#include <openssl/safestack.h>
+
+#undef PROG
+#define PROG    cmsQSExtend_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args = NULL;
+    int badarg = 0;
+    int ret = 1;
+    char *passin_qs = NULL;
+    char *passargin_qs = NULL;
+    int qs_key_format = FORMAT_PEM;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+
+    BIO *bio_cmsin = NULL;
+    BIO *bio_cmsout = NULL;
+    const char *file_qs_priv = NULL;
+    const char *file_cmsin = NULL;
+    const char *file_cmsout = NULL;
+
+    X509 *cert = NULL;
+    CMS_ContentInfo *cms = NULL;
+    CMS_ContentInfo *cms_qs_signed = NULL;
+    BIO *cmscont = NULL;
+
+    STACK_OF(X509) *cert_stack = NULL;
+    int cert_index = 0;
+    CMS_SignerInfo *cms_si = NULL;
+
+    EVP_MD_CTX mctx;
+    EVP_MD_CTX_init(&mctx);
+    X509_ATTRIBUTE *altsigalg_attrib = NULL;
+    X509_ATTRIBUTE *altsigval_attrib = NULL;
+    int noattr_flag = 0;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    if (!load_config(bio_err, NULL))
+        goto end;
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+        } else if (strcmp(*args, "-cmsin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_cmsin = *(++args);
+        } else if (strcmp(*args, "-cmsout") == 0) {
+            if (!args[1])
+                goto bad;
+            file_cmsout = *(++args);
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*args, "-privqs_engine") == 0) {
+            qs_key_format = FORMAT_ENGINE;
+        } else if (strcmp(*args, "-passinqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin_qs = *(++args);
+        } else if (strcmp(*args, "-noattr") == 0) {
+            noattr_flag = CMS_NOATTR;
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (file_cmsin == NULL)
+        badarg = 1;
+
+    if (file_cmsout == NULL)
+        badarg = 1;
+
+    if (file_qs_priv == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl cmsQSExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use IQR Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-cmsin file        The original CMS message with an MPKA certificate in it.\n");
+        BIO_printf(bio_err,
+                   "-cmsout file       The newly signed CMS message.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The extended private QS key with the classical key.\n");
+        BIO_printf(bio_err,
+                   "-privqs_engine     The private QS key should be loaded via the engine. Optional.\n");
+        BIO_printf(bio_err,
+                   "-passinqs          The private QS key password source. Optional.\n");
+        BIO_printf(bio_err,
+                   "-noattr            Do not include any signed attributes. Optional.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin_qs, NULL, &passin_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the QS private key.\n");
+        goto end;
+    }
+
+
+    /* Read in the classical private key that will be used to re-sign
+     * this cert. If an engine is being used to read in the private key there
+     * will be extra stuff for the state.  Remove it.
+     */
+    if (qs_key_format == FORMAT_ENGINE) {
+        char *tmp1 = strstr(file_qs_priv, "::");
+        if (tmp1 == NULL) {
+            BIO_puts(bio_err, "Engine private key, but no state separator (::).\n");
+            goto end;
+        }
+
+        char *tmp2 = OPENSSL_malloc((int)(tmp1 - file_qs_priv + 1));
+        if (tmp2 == NULL) {
+            BIO_puts(bio_err, "Memory allocation failure.\n");
+            goto end;
+        }
+
+        memcpy(tmp2, file_qs_priv, tmp1 - file_qs_priv);
+        tmp2[tmp1 - file_qs_priv] = '\0';
+        classical_privkey = load_key(bio_err, tmp2, FORMAT_PEM, 0, passin_qs, e, "Classical Private Key");
+        OPENSSL_free(tmp2);
+    } else {
+        classical_privkey = load_key(bio_err, file_qs_priv, FORMAT_PEM, 0, passin_qs, e, "Classical Private Key");
+    }
+
+    if (classical_privkey == NULL) {
+        /* load_key() has already printed an appropriate error message. */
+        goto end;
+    }
+
+    pkey_qs_priv = load_alt_key(bio_err, file_qs_priv, qs_key_format, 0, passin_qs, e, "QS Private Key");
+    if (pkey_qs_priv == NULL) {
+        /* load_key() has already printed an appropriate error message. */
+        goto end;
+    }
+
+    /* Ensure the private key is actually a QS key */
+    if (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_priv))) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum-safe signature algorithm.\n");
+        goto end;
+    }
+
+    bio_cmsin = BIO_new_file(file_cmsin, "rb");
+    cms = SMIME_read_CMS(bio_cmsin, &cmscont);
+    if (cms == NULL) {
+        BIO_printf(bio_err, "Bad CMS message.\n");
+        goto end;
+    }
+
+    if (CMS_verify(cms, NULL, NULL, cmscont, NULL, CMS_NO_SIGNER_CERT_VERIFY) == 0) {
+        BIO_printf(bio_err, "CMS_verify failed.\n");
+        goto end;
+    }
+
+    /* don't need bio_cmsin any more. */
+    BIO_free_all(bio_cmsin);
+    bio_cmsin = NULL;
+
+    cert_stack = CMS_get0_signers(cms);
+    if (cert_stack == NULL) {
+        BIO_printf(bio_err, "No signer certificates.\n");
+    }
+
+    for (cert_index = 0; cert_index < sk_X509_num(cert_stack); cert_index++) {
+       cert = sk_X509_value(cert_stack, cert_index);
+       if (X509_check_alt_private_key(cert, pkey_qs_priv) == 1) {
+           break;
+       }
+    }
+
+    if (cert_index == sk_X509_num(cert_stack)) {
+        BIO_printf(bio_err, "No matching Alt Public Keys.\n");
+        goto end;
+    }
+
+    /* We now re-sign with QS private key and extend the SingnerInfo using
+     * unsigned attributes.
+     */
+
+    bio_cmsin = BIO_new_file(file_cmsin, "rb");
+    cms_qs_signed = CMS_sign(NULL, NULL, NULL, bio_cmsin, CMS_TEXT | CMS_PARTIAL | CMS_DETACHED);
+    if (cms_qs_signed == NULL) {
+        BIO_printf(bio_err, "Could not re-open the input file.\n");
+        goto end;
+    }
+
+    cms_si = CMS_add1_signer(cms_qs_signed, cert, classical_privkey, EVP_sha256(), noattr_flag);
+    if (cms_si == NULL) {
+        BIO_printf(bio_err, "Could not add the signer.\n");
+        goto end;
+    }
+
+    if (CMS_SignerInfo_set1_altpriv(cms_si, pkey_qs_priv) == 0) {
+        BIO_printf(bio_err, "Could not set alt private key in signer info.\n");
+        goto end;
+    }
+
+    /* Write the new signed CMS message. */
+    bio_cmsout = BIO_new_file(file_cmsout, "wb");
+    if (SMIME_write_CMS(bio_cmsout, cms_qs_signed, cmscont, CMS_PARTIAL | CMS_DETACHED) == 0) {
+        BIO_puts(bio_err, "Error writing new certificate.\n");
+        goto end;
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (bio_cmsin)
+        BIO_free_all(bio_cmsin);
+    if (bio_cmsout)
+        BIO_free_all(bio_cmsout);
+    if (cmscont)
+        BIO_free_all(cmscont);
+    if (cms)
+        CMS_ContentInfo_free(cms);
+    if (cms_qs_signed)
+        CMS_ContentInfo_free(cms_qs_signed);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (altsigalg_attrib)
+        X509_ATTRIBUTE_free(altsigalg_attrib);
+    if (altsigval_attrib)
+        X509_ATTRIBUTE_free(altsigval_attrib);
+
+    if (passargin_qs && passin_qs)
+        OPENSSL_free(passin_qs);
+    if (cert_stack)
+        sk_X509_free(cert_stack);
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
diff --git a/openssl-1.0.2r/apps/QSExtend/cmsQSVerify.c b/openssl-1.0.2r/apps/QSExtend/cmsQSVerify.c
new file mode 100644
index 00000000..03dabcd0
--- /dev/null
+++ b/openssl-1.0.2r/apps/QSExtend/cmsQSVerify.c
@@ -0,0 +1,263 @@
+/** @file cmsQSVerify.c QS Verify a QS signed CMS message.
+ *
+ * @copyright Copyright (C) 2018-2019, ISARA Corporation, All Rights Reserved.
+ */
+
+/* Modified.  Was genpkey.c. 
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+#include <openssl/cms.h>
+#include <openssl/safestack.h>
+
+#define X509_NAME_LINE_LENGTH 128
+
+#undef PROG
+#define PROG    cmsQSVerify_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args = NULL;
+    int badarg = 0;
+    int ret = 1;
+    char *passin = NULL;
+    char *passargin = NULL;
+    char *passin_qs = NULL;
+    char *passargin_qs = NULL;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+
+    BIO *bio_cmsin = NULL;
+    BIO *bio_cmsout = NULL;
+    const char *file_cmsin = NULL;
+
+    CMS_ContentInfo *cms = NULL;
+    CMS_ContentInfo *cms_qs_signed = NULL;
+    BIO *cmscont = NULL;
+
+    int si_index = 0;
+    CMS_SignerInfo *cms_si = NULL;
+    STACK_OF(CMS_SignerInfo) *cms_si_stack = NULL;
+
+    EVP_MD_CTX mctx;
+    EVP_MD_CTX_init(&mctx);
+    X509_ATTRIBUTE *altsigalg_attrib = NULL;
+    X509_ATTRIBUTE *altsigval_attrib = NULL;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    if (!load_config(bio_err, NULL))
+        goto end;
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+    X509_NAME *issuer = NULL;
+    char name[X509_NAME_LINE_LENGTH];
+    ASN1_INTEGER *serial = NULL;
+    char *s = NULL;
+
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+        } else if (strcmp(*args, "-cmsin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_cmsin = *(++args);
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (file_cmsin == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl cmsQSVerify [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use IQR Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-cmsin file        The CMS message with an MPKA certificate in it.\n");
+        goto end;
+    }
+
+    bio_cmsin = BIO_new_file(file_cmsin, "rb");
+    cms = SMIME_read_CMS(bio_cmsin, &cmscont);
+    if (cms == NULL) {
+        BIO_printf(bio_err, "Bad CMS message.\n");
+        goto end;
+    }
+
+    /* This does a lot of the ASN.1 decoding that is required in order for
+     *  CMS_get0_SignerInfos() to work properly.
+     */
+    if (CMS_verify(cms, NULL, NULL, cmscont, NULL, CMS_NO_SIGNER_CERT_VERIFY) == 0) {
+        BIO_printf(bio_err, "CMS_verify failed.\n");
+        goto end;
+    }
+
+    /* Do not need bio_cmsin any more. */
+    BIO_free_all(bio_cmsin);
+    bio_cmsin = NULL;
+
+    cms_si_stack = CMS_get0_SignerInfos(cms);
+    if (cms_si_stack == NULL) {
+        BIO_printf(bio_err, "No signer certificates.\n");
+        goto end;
+    }
+
+    /* We have to try all the SignerInfos because we don't have a private key
+     * to match against.
+     */
+    for (si_index = 0; si_index < sk_CMS_SignerInfo_num(cms_si_stack); si_index++) {
+        cms_si = sk_CMS_SignerInfo_value(cms_si_stack, si_index);
+
+        if (cms_si == NULL) {
+            BIO_printf(bio_err, "Expecting CMS_SignerInfo but none there.\n");
+            goto end;
+        }
+
+        if (CMS_SignerInfo_get0_signer_id(cms_si, NULL, &issuer, &serial) == 0) {
+            BIO_printf(bio_err, "Could not get signer info identifier.\n");
+            goto end;
+        }
+
+        s = i2s_ASN1_INTEGER(NULL, serial);
+        if (s == NULL) {
+            BIO_printf(bio_err, "Could not decode serial number.\n");
+            goto end;
+        }
+
+        if (CMS_SignerInfo_altverify(cms_si, cmscont) <= 0) {
+            BIO_printf(bio_err, "NOT QS Verified: ");
+        } else {
+            BIO_printf(bio_err, "Successfully QS Verified: ");
+            ret = 0;
+        }
+        BIO_printf(bio_err, "serial number:[%s] ", s);
+        BIO_printf(bio_err, "issuer:[%s]\n", X509_NAME_oneline(issuer, name, X509_NAME_LINE_LENGTH));
+
+        if (s) {
+            OPENSSL_free(s);
+        }
+        s = NULL;
+    }
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (bio_cmsin)
+        BIO_free_all(bio_cmsin);
+    if (bio_cmsout)
+        BIO_free_all(bio_cmsout);
+    if (cmscont)
+        BIO_free_all(cmscont);
+    if (cms)
+        CMS_ContentInfo_free(cms);
+    if (cms_qs_signed)
+        CMS_ContentInfo_free(cms_qs_signed);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (altsigalg_attrib)
+        X509_ATTRIBUTE_free(altsigalg_attrib);
+    if (altsigval_attrib)
+        X509_ATTRIBUTE_free(altsigval_attrib);
+
+    if (passargin && passin)
+        OPENSSL_free(passin);
+    if (passargin_qs && passin_qs)
+        OPENSSL_free(passin_qs);
+    if (s)
+        OPENSSL_free(s);
+
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
diff --git a/openssl-1.0.2r/apps/QSExtend/pkcs12QSExtend.c b/openssl-1.0.2r/apps/QSExtend/pkcs12QSExtend.c
new file mode 100644
index 00000000..8b6500a5
--- /dev/null
+++ b/openssl-1.0.2r/apps/QSExtend/pkcs12QSExtend.c
@@ -0,0 +1,428 @@
+/** @file pkcs12QSExtend.c Load a PKCS12 file with a X.509 MPKAC certificate
+ *  and convential private key.  Then load a file with an alt private key.
+ *  Add the alt private key to the PKCS12 file and append [ALT] to the front
+ *  of the friendly name.
+ *
+ * @copyright Copyright (C) 2018-2019, ISARA Corporation, All Rights Reserved.
+ */
+
+/* Modified.  Was genpkey.c. 
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/asn1_mac.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+#include <openssl/pkcs12.h>
+
+#undef PROG
+#define PROG    pkcs12QSExtend_main
+
+static int set_pbe(BIO *err, int *ppbe, const char *str)
+{
+    if (!str)
+        return 0;
+    if (!strcmp(str, "NONE")) {
+        *ppbe = -1;
+        return 1;
+    }
+    *ppbe = OBJ_txt2nid(str);
+    if (*ppbe == NID_undef) {
+        BIO_printf(bio_err, "Unknown PBE algorithm %s\n", str);
+        return 0;
+    }
+    return 1;
+}
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args = NULL;
+    int badarg = 0;
+    int ret = 1;
+    char *pass = NULL;
+    char *passarg = NULL;
+    ENGINE *e = NULL;
+    char *pass_qs = NULL;
+    char *passarg_qs = NULL;
+
+
+    EVP_PKEY *pkey_qs_priv = NULL;
+    const char *file_qs_priv = NULL;
+
+    BIO *bio_pkcs12in = NULL;
+    BIO *bio_pkcs12out = NULL;
+    const char *file_pkcs12in = NULL;
+    const char *file_pkcs12out = NULL;
+
+    PKCS12 *pkcs12 = NULL;
+
+    PKCS7 *safe = NULL;
+    STACK_OF(PKCS7) *safes = NULL;
+    int safe_iter = 0;
+
+    PKCS12_SAFEBAG * bag = NULL;
+    PKCS12_SAFEBAG * qs_priv_bag = NULL;
+    STACK_OF(PKCS12_SAFEBAG) *bags = NULL;
+    int bag_iter = 0;
+    int bag_nid = 0;
+
+    X509 *cert = NULL;
+    X509 *found_cert = NULL;
+    char *found_priv = NULL;
+    int key_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    if (!load_config(bio_err, NULL))
+        goto end;
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+        } else if (strcmp(*args, "-pkcs12in") == 0) {
+            if (!args[1])
+                goto bad;
+            file_pkcs12in = *(++args);
+        } else if (strcmp(*args, "-pkcs12out") == 0) {
+            if (!args[1])
+                goto bad;
+            file_pkcs12out = *(++args);
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*args, "-passqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passarg_qs = *(++args);
+        } else if (strcmp(*args, "-pass") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passarg = *(++args);
+        } else if (!strcmp(*args, "-keypbe")) {
+            if (!set_pbe(bio_err, &key_pbe, *++args))
+                goto bad; 
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (file_pkcs12in == NULL)
+        badarg = 1;
+
+    if (file_pkcs12out == NULL)
+        badarg = 1;
+
+    if (file_qs_priv == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl pkcs12QSExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use IQR Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-pkcs12in file     The .p12 file\n");
+        BIO_printf(bio_err,
+                   "-pkcs12out file    The new .p12 file with the alternative private key with new [ALT] prefix in\n");
+        BIO_printf(bio_err,
+                   "                   friendly name.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The private QS key.\n");
+        BIO_printf(bio_err,
+                   "-passqs            The password source for decrypting the QS private key. Only required if the QS\n");
+        BIO_printf(bio_err,
+                   "                   private key was encrypted.\n");
+        BIO_printf(bio_err,
+                   "-pass              The password source for PKCS12 private key encryption. Optional. If not present\n");
+        BIO_printf(bio_err,
+                   "                   the private keys are not encrypted.\n");
+        BIO_printf(bio_err,
+                   "-keypbe            The algorithm for QS private key encryption. Without -pass, this is ignored.\n");
+        BIO_printf(bio_err,
+                   "                   Default is PBE-SHA1-3DES. See PKCS8 manpage.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passarg, NULL, &pass, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the private key.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passarg_qs, NULL, &pass_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password to decrypt the QS private key.\n");
+        goto end;
+    }
+
+    /* This block of code will succeed if the private key file contains a dual
+     * key and the ALT key is QS. It will also succeed if the private key file
+     * contains a single QS key. Otherwise, fail.
+     *
+     * Read in the alt private key without a valid err_bio. If an error occurs,
+     * this might not be a dual key so erase the error message and try
+     * load_key()  with a valid err_bio. If that fails, or succeeds but is not
+     * QS, then call load_alt_key() again with valid error bio to output an
+     * error message for the alt key as well.
+     */
+    pkey_qs_priv = load_alt_key(NULL, file_qs_priv, FORMAT_PEM, 0, pass_qs, e, "QS Private Key");
+    ERR_clear_error();
+    if (pkey_qs_priv == NULL) {
+        pkey_qs_priv = load_key(bio_err, file_qs_priv, FORMAT_PEM, 0, pass_qs, e, "Private Key");
+        if ((pkey_qs_priv == NULL) || (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_priv)))) {
+            load_alt_key(bio_err, file_qs_priv, FORMAT_PEM, 0, pass_qs, e, "QS Private Key");
+            /* load_key() and/or load_alt_key() have already printed an appropriate
+             * message.
+             */
+            goto end;
+        }
+    }
+
+    /* Ensure the QS private key is actually a key for a QS signature scheme. */
+    if (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_priv))) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum-safe algorithm.\n");
+        goto end;
+    }
+
+    bio_pkcs12in = BIO_new_file(file_pkcs12in, "rb");
+    pkcs12 = d2i_PKCS12_bio(bio_pkcs12in, NULL);
+    safes = PKCS12_unpack_authsafes(pkcs12);
+
+    /* Going to assume that there was at most one private key in the input
+     * pkcs12 file. This is appropriate as this is a limitation of the pkcs12
+     * application that created the file.
+     */
+
+    for (safe_iter = 0; safe_iter < sk_PKCS7_num(safes); safe_iter++) {
+        safe = sk_PKCS7_value(safes, safe_iter);
+        bag_nid = OBJ_obj2nid(safe->type);
+
+        if (bag_nid == NID_pkcs7_data) {
+            bags = PKCS12_unpack_p7data(safe);
+        } else if (bag_nid == NID_pkcs7_encrypted) {
+            bags = PKCS12_unpack_p7encdata(safe, pass, strlen(pass));
+        }
+
+        if (bags == NULL) {
+            continue;
+        }
+
+        for (bag_iter = 0; bag_iter <  sk_PKCS12_SAFEBAG_num(bags); bag_iter++) {
+            bag = sk_PKCS12_SAFEBAG_value(bags, bag_iter);
+            if (bag == NULL) {
+                continue;
+            }
+
+            /* Look for the certificate. */
+            cert = PKCS12_certbag2x509(bag);
+            if (cert != NULL) {
+                if (X509_check_alt_private_key(cert, pkey_qs_priv) == 1) {
+                    found_cert = cert;
+                } else {
+                    X509_free(cert);
+                    cert = NULL;
+                }
+                continue;
+            }
+
+            /* Look for an encrypted or unencrypted private key.
+             * Grab the friendlyname and prepend [ALT] to it.
+             */
+            if ((M_PKCS12_bag_type(bag) == NID_keyBag) || (M_PKCS12_bag_type(bag) == NID_pkcs8ShroudedKeyBag)) {
+                if (found_priv != NULL) {
+                    fprintf(stderr, "Multiple private keys in the PKCS12 input file.\n");
+                }
+                found_priv = PKCS12_get_friendlyname(bag);
+                if (found_priv == NULL) {
+                    found_priv = OPENSSL_malloc(strlen("[ALT]") + 1);
+                    if (found_priv == NULL) {
+                        fprintf(stderr, "Memory allocation error while creating friendly name\n");
+                    }
+                    strcpy(found_priv, "[ALT]");
+                } else {
+                    char *ctmp = OPENSSL_malloc(strlen("[ALT]") + strlen(found_priv) + 1);
+                    if (ctmp == NULL) {
+                        fprintf(stderr, "Memory allocation error while creating friendly name\n");
+                    }
+                    strcpy(ctmp, "[ALT]");
+                    strcat(ctmp, found_priv);
+                    OPENSSL_free(found_priv);
+                    found_priv = ctmp;
+                }
+
+                continue;
+            }
+        }
+
+        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
+        bags = NULL;
+    }
+
+
+    if ((found_cert == NULL) || (found_priv == 0)) {
+        fprintf (stderr, "Certificate and/or private key not found.\n");
+        goto end;
+    }
+
+    for (safe_iter = 0; safe_iter < sk_PKCS7_num(safes); safe_iter++) {
+        safe = sk_PKCS7_value(safes, safe_iter);
+        bag_nid = OBJ_obj2nid(safe->type);
+
+        if (bag_nid == NID_pkcs7_encrypted) {
+            bags = PKCS12_unpack_p7encdata(safe, pass, strlen(pass));
+        }
+
+        if (bags != NULL) {
+            /* We are only interested in NID_pkcs7_encrypted because
+             * that is where we want to put the private key.
+             */
+            break;
+        }
+    }
+
+    qs_priv_bag = PKCS12_add_key(&bags, pkey_qs_priv, 0, PKCS12_DEFAULT_ITER,
+                                 key_pbe, pass);
+    if (qs_priv_bag == NULL) {
+        fprintf (stderr, "Error adding the QS private key.\n");
+        goto end;
+    }
+
+    /* Add the new friendly name to this alt private key. */
+    if (PKCS12_add_friendlyname_asc(qs_priv_bag, found_priv, strlen(found_priv)) == 0) {
+        fprintf(stderr, "Error adding the QS private key friendly name.\n");
+        goto end;
+    }
+
+    /* Remove and deallocate the safe and then replace it. */
+    PKCS7_free(sk_PKCS7_delete(safes, safe_iter));
+    if (sk_PKCS7_push(safes, PKCS12_pack_p7encdata(key_pbe, pass, strlen(pass), NULL, 0,
+                      PKCS12_DEFAULT_ITER, bags)) == 0) {
+        fprintf(stderr, "Error pushing a PKCS7 into stack.\n");
+        goto end;
+    }
+
+    if (PKCS12_pack_authsafes(pkcs12, safes) == 0) {
+        fprintf(stderr, "Error packing the safes\n");
+        goto end;
+    }
+
+    if (PKCS12_set_mac(pkcs12, pass, strlen(pass), NULL, 0, PKCS12_DEFAULT_ITER, NULL) == 0) {
+        fprintf(stderr, "Error setting the MAC\n");
+        goto end;
+    }
+
+    bio_pkcs12out = BIO_new_file(file_pkcs12out, "wb");
+    if (i2d_PKCS12_bio(bio_pkcs12out, pkcs12) == 0) {
+        fprintf(stderr, "Error encoding or outputting the file.\n");
+        goto end;
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    if (bio_pkcs12in)
+        BIO_free_all(bio_pkcs12in);
+    if (bio_pkcs12out)
+        BIO_free_all(bio_pkcs12out);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (passarg && pass)
+        OPENSSL_free(pass);
+    if (passarg_qs && pass_qs)
+        OPENSSL_free(pass_qs);
+    if (pkcs12)
+        PKCS12_free(pkcs12);
+    if (safes)
+        sk_PKCS7_pop_free(safes, PKCS7_free);
+    if (found_cert)
+        X509_free(found_cert);
+    if (found_priv)
+        OPENSSL_free(found_priv);
+    if (bags)
+        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
+
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
+
diff --git a/openssl-1.0.2r/apps/QSExtend/reqQSExtend.c b/openssl-1.0.2r/apps/QSExtend/reqQSExtend.c
new file mode 100644
index 00000000..d210282a
--- /dev/null
+++ b/openssl-1.0.2r/apps/QSExtend/reqQSExtend.c
@@ -0,0 +1,603 @@
+/** @file reqQSExtend.c Load QS keypair and traditional CSR and use them to create multiple public key algorithm CSR.
+ *
+ * @copyright Copyright (C) 2017-2019, ISARA Corporation, All Rights Reserved.
+ */
+
+/* Modified.  Was genpkey.c.
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+
+static X509_ATTRIBUTE *create_SAPKI_ATTRIBUTE(SUBJECT_ALT_PUBLIC_KEY_INFO *sapki) {
+    unsigned char *p = NULL;
+    unsigned char *data = NULL;
+    ASN1_STRING *astr = NULL;
+    int i = 0;
+    X509_ATTRIBUTE *attr = NULL;
+
+    i = i2d_SUBJECT_ALT_PUBLIC_KEY_INFO(sapki, NULL);
+    if (i < 0) {
+        fprintf(stderr, "Failed to get ASN.1 size of SAPKI attribute.\n");
+        goto end;
+    }
+
+    data = OPENSSL_malloc(i);
+    if (data == NULL) {
+        fprintf(stderr, "Memory failure during SAPKI attribute creation.\n");
+        goto end;
+    }
+
+    p=data;
+    i = i2d_SUBJECT_ALT_PUBLIC_KEY_INFO(sapki, &p);
+    if (i < 0) {
+        fprintf(stderr, "Failed to ASN.1 encode the SAPKI attribute.\n");
+        goto end;
+    }
+
+    astr = ASN1_STRING_new();
+    if (!ASN1_STRING_set(astr, data, i)) {
+        ASN1_STRING_free(astr);
+        fprintf(stderr, "Failed to alloc/set string for SAPKI attribute.\n");
+        goto end;
+    }
+
+    attr = X509_ATTRIBUTE_create(NID_subjectAltPublicKeyInfo, V_ASN1_SEQUENCE, astr);
+    if (attr == NULL) {
+        ASN1_STRING_free(astr);
+        fprintf(stderr, "Failed to create the SAPKI attribute.\n");
+        goto end;
+    }
+
+end:
+    OPENSSL_free(data);
+    return attr;
+}
+
+static X509_ATTRIBUTE *create_ALTSIG_ATTRIBUTE(ASN1_BIT_STRING *altsig) {
+    X509_ATTRIBUTE *attr = NULL;
+
+    attr = X509_ATTRIBUTE_create(NID_altSignatureValue, V_ASN1_BIT_STRING, altsig);
+    if (attr == NULL) {
+        fprintf(stderr, "Failed to create the ALTSIG attribute.\n");
+        goto end;
+    }
+
+end:
+    return attr;
+}
+
+static X509_ATTRIBUTE *create_ALTSIGALG_ATTRIBUTE(X509_ALGOR *altsigalg) {
+    X509_ATTRIBUTE *attr = NULL;
+    unsigned char *p = NULL;
+    unsigned char *data = NULL;
+    ASN1_STRING *astr = NULL;
+    int i = 0;
+
+    i = i2d_X509_ALGOR(altsigalg, NULL);
+    if (i < 0) {
+        fprintf(stderr, "Failed to get ASN.1 size of ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+    data = OPENSSL_malloc(i);
+    if (data == NULL) {
+        fprintf(stderr, "Memory failure during ALTSIGALG attribute creation.\n");
+        goto end;
+    }
+
+    p=data;
+    i = i2d_X509_ALGOR(altsigalg, &p);
+    if (i < 0) {
+        fprintf(stderr, "Failed to ASN.1 encode the ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+    astr = ASN1_STRING_new();
+    if (!ASN1_STRING_set(astr, data, i)) {
+        fprintf(stderr, "Failed to alloc/set string for ALTSIGALG attribute.\n");
+        ASN1_STRING_free(astr);
+        goto end;
+    }
+
+    attr = X509_ATTRIBUTE_create(NID_altSignatureAlgorithm, V_ASN1_SEQUENCE, astr);
+    if (attr == NULL) {
+        ASN1_STRING_free(astr);
+        fprintf(stderr, "Failed to create the ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+end:
+    OPENSSL_free(data);
+    return attr;
+}
+
+#undef PROG
+#define PROG    reqQSExtend_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args = NULL;
+    int badarg = 0;
+    int ret = 1;
+    char *passin = NULL;
+    char *pass_qs = NULL;
+    char *passargin = NULL;
+    char *passarg_qs = NULL;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *pkey_qs_pub = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+
+    int qs_pub_key_ind = -1;
+    int qs_sigval_ind = -1;
+    int qs_sigalg_ind = -1;
+    int qs_key_format = FORMAT_PEM;
+
+    BIO *bio_reqin = NULL;
+    BIO *bio_reqout = NULL;
+    BIO *bio_privqsout = NULL;
+
+    const char *file_priv = NULL;
+    const char *file_qs_pub = NULL;
+    const char *file_qs_priv = NULL;
+    const char *file_reqin = NULL;
+    const char *file_reqout = NULL;
+    char *file_qs_priv_out = NULL;
+
+    X509_REQ *req = NULL;
+    ASN1_BIT_STRING *qs_sigval_as_asn1bitstring = NULL;
+
+    X509_ALGOR *qssig_algor = NULL;
+    ASN1_BIT_STRING *qssig = NULL;
+    X509_ATTRIBUTE *attr_qssig = NULL;
+
+    X509_ATTRIBUTE *attr_qssigalg = NULL;
+
+    X509_PUBKEY *x509_pub_qs = NULL;
+    X509_PUBKEY *x509_sig_qs = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    X509_ATTRIBUTE *attr_sapki = NULL;
+
+    EVP_MD_CTX mctx;
+    EVP_MD_CTX_init(&mctx);
+
+    const EVP_CIPHER *cipher = NULL;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    if (!load_config(bio_err, NULL))
+        goto end;
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+        } else if (strcmp(*args, "-reqin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_reqin = *(++args);
+        } else if (strcmp(*args, "-reqout") == 0) {
+            if (!args[1])
+                goto bad;
+            file_reqout = *(++args);
+        } else if (strcmp(*args, "-privin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_priv = *(++args);
+        } else if (strcmp(*args, "-pubqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_pub = *(++args);
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*args, "-privqs_engine") == 0) {
+            qs_key_format = FORMAT_ENGINE;
+        } else if (strcmp(*args, "-passin") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin = *(++args);
+        } else if (strcmp(*args, "-passqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passarg_qs = *(++args);
+        } else {
+            cipher = EVP_get_cipherbyname(*args + 1);
+            if (cipher == NULL) {
+                BIO_printf(bio_err, "Unknown cipher %s\n", *args + 1);
+                badarg = 1;
+            }
+        }
+        args++;
+    }
+
+    if (file_priv == NULL)
+        badarg = 1;
+
+    if (file_reqin == NULL)
+        badarg = 1;
+
+    if (file_reqout == NULL)
+        badarg = 1;
+
+    if (file_qs_priv == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl reqQSExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use IQR Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-reqin file        The CSR in pem format.\n");
+        BIO_printf(bio_err,
+                   "-reqout file       The CSR in pem format with new ALT extensions.\n");
+        BIO_printf(bio_err,
+                   "-privin file       The private key used to sign the original CSR in pem format.\n");
+        BIO_printf(bio_err,
+                   "-pubqs file        The public QS key.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The private QS key. Will be rewritten to contain the classical key and QS key.\n");
+        BIO_printf(bio_err,
+                   "-privqs_engine     The private QS key should be loaded via the engine. Optional.\n");
+        BIO_printf(bio_err,
+                   "-passin            The private key password source. Optional.\n");
+        BIO_printf(bio_err,
+                   "-passqs            The private QS key password source. Optional.\n");
+        BIO_printf(bio_err,
+                   "-<cipher>          Use cipher <cipher> to encrypt the key. Optional.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the private key.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passarg_qs, NULL, &pass_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the QS private key.\n");
+        goto end;
+    }
+
+    /* Read in the the classical req. */
+    bio_reqin = BIO_new_file(file_reqin, "rb");
+    req = PEM_read_bio_X509_REQ(bio_reqin, NULL, NULL, NULL);
+    if (req == NULL) {
+        BIO_printf(bio_err, "Bad CSR\n");
+        goto end;
+    }
+    BIO_free_all(bio_reqin);
+    bio_reqin = NULL;
+
+    /* Ensure this certificate signing request does not already have alternative
+     * attributes.
+     */
+    qs_pub_key_ind = X509_REQ_get_attr_by_NID(req, NID_subjectAltPublicKeyInfo, -1);
+    qs_sigval_ind = X509_REQ_get_attr_by_NID(req, NID_altSignatureValue, -1);
+    qs_sigalg_ind = X509_REQ_get_attr_by_NID(req, NID_altSignatureAlgorithm, -1);
+    if ((qs_pub_key_ind != -1) || (qs_sigalg_ind != -1) || (qs_sigval_ind != -1)) {
+        BIO_puts(bio_err, "The input certificate signing request already has alternative attributes.\n");
+        goto end;
+    }
+
+    /* Read in the classical private key.  We'll need it to sign the
+     * QS req again.
+     */
+    classical_privkey = load_key(bio_err, file_priv, FORMAT_PEM, 0, passin, e, "Classical Private Key");
+    if (classical_privkey == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Read in the QS private key so we can create a QS signature */
+    pkey_qs_priv = load_key(bio_err, file_qs_priv, qs_key_format, 0, pass_qs, e, "QS Private Key");
+    if (pkey_qs_priv == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Ensure the private key is actually a QS key */
+    if (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_priv))) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum-safe algorithm.\n");
+        goto end;
+    }
+
+    /* Read the QS Public key to be embedded in the QS req if it was specified.
+     * If not check the private key.
+     */
+    if (file_qs_pub == NULL) {
+        pkey_qs_pub = pkey_qs_priv;
+    } else {
+        pkey_qs_pub = load_pubkey(bio_err, file_qs_pub, FORMAT_PEM, 0, NULL, e, "QS Public Key");
+        if (pkey_qs_pub == NULL) {
+            /* load_pubkey() has already printed an appropriate message. */
+            goto end;
+        }
+    }
+
+    /* Ensure the public key is actually a QS key */
+    if (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_pub))) {
+        BIO_puts(bio_err, "The provided public key is not compatible with a quantum-safe algorithm.\n");
+        goto end;
+    }
+
+    /* Convert the private key into an x509 public key.  This lets us
+     * get the algorithm identifier of the private key so we can associate
+     * it with the signature.
+     */
+    X509_PUBKEY_set(&x509_sig_qs, pkey_qs_priv);
+
+    /* Convert the pkey in to an x509 public key.  This is the standard way
+     * of doing it for x509 subject public key.
+     */
+    X509_PUBKEY_set(&x509_pub_qs, pkey_qs_pub);
+
+    sapki = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    if (sapki == NULL) {
+        BIO_puts(bio_err, "Error converting public key to x509 pubkey\n");
+        goto end;
+    }
+
+    X509_ALGOR_free(sapki->algor);
+    ASN1_BIT_STRING_free(sapki->public_key);
+
+    sapki->algor = x509_pub_qs->algor;
+    sapki->public_key = x509_pub_qs->public_key;
+
+    /* Create and insert QS public key as an extension */
+    attr_sapki = create_SAPKI_ATTRIBUTE(sapki);
+    sapki->algor = NULL;
+    sapki->public_key = NULL;
+    if (attr_sapki == NULL) {
+        BIO_puts(bio_err, "Error converting x509 pubkey to extension.\n");
+        goto end;
+    }
+
+    /* Add the ALT public key extension so the signing process includes it.
+     */
+    if (X509_REQ_add1_attr(req, attr_sapki) == 0) {
+        BIO_puts(bio_err, "Error adding public key as extension\n");
+        goto end;
+    }
+
+    qssig_algor = X509_ALGOR_dup(x509_sig_qs->algor);
+    if (qssig_algor == NULL) {
+        BIO_puts(bio_err, "Error duplicating signature algor.\n");
+        goto end;
+    }
+
+    if (X509_ALGOR_set0(qssig_algor, OBJ_nid2obj(EVP_PKEY_id(pkey_qs_priv)), ASN1_get_sigparam(pkey_qs_priv), NULL) == 0) {
+        BIO_puts(bio_err, "Error setting algorithm object ID.\n");
+        goto end;
+    }
+
+    attr_qssigalg = create_ALTSIGALG_ATTRIBUTE(qssig_algor);
+
+    /* Add the ALT signature algorithm extension so the signing process includes it.
+     */
+    if (X509_REQ_add1_attr(req, attr_qssigalg) == 0) {
+        BIO_puts(bio_err, "Error adding signature algorithm as extension\n");
+        goto end;
+    }
+
+    req->req_info->enc.modified = 1;
+
+    /* Sign the req with the QS private key. */
+    if (EVP_DigestSignInit(&mctx, NULL, NULL, NULL, pkey_qs_priv) < 1) {
+        BIO_puts(bio_err, "Error doing EVP digest initialization\n");
+        goto end;
+    }
+
+    /* Prepare an ASN1 bit string for the ALT signature extension. */
+    qs_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+    if (qs_sigval_as_asn1bitstring == NULL) {
+         BIO_puts(bio_err, "ASN1 bit string memory allocation error.\n");
+         goto end;
+    }
+
+    if (ASN1_item_sign_ctx(ASN1_ITEM_rptr(X509_REQ_INFO), NULL, NULL, qs_sigval_as_asn1bitstring, req->req_info, &mctx) <= 0) {
+        BIO_puts(bio_err, "Quantum-safe signing operation failed.\n");
+        goto end;
+    }
+
+    qs_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+    qs_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+    attr_qssig = create_ALTSIG_ATTRIBUTE(qs_sigval_as_asn1bitstring);
+    if (attr_qssig == NULL) {
+        BIO_puts(bio_err, "Error creating signature extension.\n");
+        goto end;
+    }
+    qs_sigval_as_asn1bitstring = NULL;
+
+    if (X509_REQ_add1_attr(req, attr_qssig) == 0) {
+        BIO_puts(bio_err, "Error adding signature as extension\n");
+        goto end;
+    }
+
+    req->req_info->enc.modified = 1;
+
+    /* Re-sign the req with the original classical private key. */
+    if (X509_REQ_sign(req, classical_privkey, NULL) == 0) {
+        BIO_puts(bio_err, "Error generating classical signature.\n");
+        goto end;
+    }
+
+    /* Write the new signed req with extensions in it. */
+    bio_reqout = BIO_new_file(file_reqout, "wb");
+    if (PEM_write_bio_X509_REQ(bio_reqout, req) == 0) {
+        BIO_puts(bio_err, "Error writing new CSR.\n");
+        goto end;
+    }
+
+    if (qs_key_format == FORMAT_ENGINE) {
+        char *tmp = strstr(file_qs_priv, "::");
+        if (tmp == NULL) {
+            BIO_puts(bio_err, "Engine private key, but no state separator (::).\n");
+            goto end;
+        }
+
+        file_qs_priv_out = OPENSSL_malloc((int)(tmp - file_qs_priv + 1));
+        if (file_qs_priv_out == NULL) {
+            BIO_puts(bio_err, "Memory allocation failure.\n");
+            goto end;
+        }
+
+        memcpy(file_qs_priv_out, file_qs_priv, tmp - file_qs_priv);
+        file_qs_priv_out[tmp - file_qs_priv] = '\0';
+        bio_privqsout = BIO_new_file(file_qs_priv_out, "wb");
+    } else {
+        bio_privqsout = BIO_new_file(file_qs_priv, "wb");
+    }
+
+    /* Write the combined private key.  Encrypt BOTH with the QS password. */
+    if (PEM_write_bio_PKCS8PrivateKey(bio_privqsout, classical_privkey, cipher, NULL, 0, NULL, pass_qs) == 0) {
+        BIO_puts(bio_err, "Error writing classical private key to the combined file.\n");
+        goto end;
+    }
+
+    if (PEM_write_bio_ALT_PKCS8PrivateKey(bio_privqsout, pkey_qs_priv, cipher, NULL, 0, NULL, pass_qs) == 0) {
+        BIO_puts(bio_err, "Error writing QS private key to the combined file.\n");
+        goto end;
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (bio_reqin)
+        BIO_free_all(bio_reqin);
+    if (bio_privqsout)
+        BIO_free_all(bio_privqsout);
+    if (bio_reqout)
+        BIO_free_all(bio_reqout);
+    if (req)
+        X509_REQ_free(req);
+    if (pkey_qs_pub == pkey_qs_priv)
+        pkey_qs_pub = NULL;
+    if (pkey_qs_pub)
+        EVP_PKEY_free(pkey_qs_pub);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (x509_pub_qs)
+        X509_PUBKEY_free(x509_pub_qs);
+    if (x509_sig_qs)
+        X509_PUBKEY_free(x509_sig_qs);
+    if (qssig_algor)
+        X509_ALGOR_free(qssig_algor);
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    if (qssig)
+        ASN1_BIT_STRING_free(qssig);
+    if (file_qs_priv_out)
+        OPENSSL_free(file_qs_priv_out);
+
+    /* Note that we use OPENSSL_malloc() to allocate these so we don't use
+     * the custom free functions to free them.
+     */
+    if (qs_sigval_as_asn1bitstring)
+        ASN1_BIT_STRING_free(qs_sigval_as_asn1bitstring);
+    if (attr_sapki)
+        X509_ATTRIBUTE_free(attr_sapki);
+    if (attr_qssig)
+        X509_ATTRIBUTE_free(attr_qssig);
+    if (attr_qssigalg)
+        X509_ATTRIBUTE_free(attr_qssigalg);
+
+    if (passargin && passin)
+        OPENSSL_free(passin);
+    if (passarg_qs && pass_qs)
+        OPENSSL_free(pass_qs);
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
+
diff --git a/openssl-1.0.2r/apps/QSExtend/x509QSDirectExtend.c b/openssl-1.0.2r/apps/QSExtend/x509QSDirectExtend.c
new file mode 100644
index 00000000..d8244e46
--- /dev/null
+++ b/openssl-1.0.2r/apps/QSExtend/x509QSDirectExtend.c
@@ -0,0 +1,576 @@
+/** @file x509QSDirectExtend.c Load QS keypair and traditional X509 certificates and use them to create a multiple public key algorithm certificate.
+ *
+ * @copyright Copyright (C) 2017-2019, ISARA Corporation, All Rights Reserved.
+ */
+
+/* Modified.  Was genpkey.c. 
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+
+#undef PROG
+#define PROG    x509QSDirectExtend_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args = NULL;
+    int badarg = 0;
+    int ret = 1;
+    int self_sign = 0;
+    char *passin = NULL;
+    char *pass_qs = NULL;
+    char *passargin = NULL;
+    char *passarg_qs = NULL;
+    int qs_pub_key_ind = -1;
+    int qs_sigalg_ind = -1;
+    int qs_sigval_ind = -1;
+    int qs_key_format = FORMAT_PEM;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *pkey_qs_pub = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+
+    BIO *bio_x509in = NULL;
+    BIO *bio_x509out = NULL;
+    BIO *bio_privqsout = NULL;
+
+    const char *file_priv = NULL;
+    const char *file_qs_pub = NULL;
+    const char *file_qs_priv = NULL;
+    const char *file_x509in = NULL;
+    const char *file_x509out = NULL;
+    char *file_qs_priv_out = NULL;
+
+    X509_ALGOR *algor_for_qssigalg = NULL;
+    X509_EXTENSION *ext_qssigalg = NULL;
+
+    X509 *cert = NULL;
+    ASN1_BIT_STRING *qs_sigval_as_asn1bitstring = NULL;
+
+    X509_EXTENSION *ext_qssig = NULL;
+
+    X509_PUBKEY *x509_pub_qs = NULL;
+    X509_PUBKEY *x509_sig_qs = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    X509_EXTENSION *ext_sapki = NULL;
+
+    EVP_MD_CTX mctx;
+    EVP_MD_CTX_init(&mctx);
+
+    const EVP_CIPHER *cipher = NULL;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    if (!load_config(bio_err, NULL))
+        goto end;
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+        } else if (strcmp(*args, "-x509in") == 0) {
+            if (!args[1])
+                goto bad;
+            file_x509in = *(++args);
+        } else if (strcmp(*args, "-x509out") == 0) {
+            if (!args[1])
+                goto bad;
+            file_x509out = *(++args);
+        } else if (strcmp(*args, "-privin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_priv = *(++args);
+        } else if (strcmp(*args, "-pubqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_pub = *(++args);
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*args, "-privqs_engine") == 0) {
+            qs_key_format = FORMAT_ENGINE;
+        } else if (strcmp(*args, "-self_sign") == 0) {
+            self_sign = 1;
+        } else if (strcmp(*args, "-passin") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin = *(++args);
+        } else if (strcmp(*args, "-passqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passarg_qs = *(++args);
+        } else {
+            cipher = EVP_get_cipherbyname(*args + 1);
+            if (cipher == NULL) {
+                BIO_printf(bio_err, "Unknown cipher %s\n", *args + 1);
+                badarg = 1;
+            }
+        }
+        args++;
+    }
+
+    if (file_x509in == NULL)
+        badarg = 1;
+
+    if (file_x509out == NULL)
+        badarg = 1;
+
+    if ((file_qs_pub == NULL) && (self_sign == 0))
+        badarg = 1;
+
+    if ((file_qs_pub != NULL) && (self_sign == 1))
+        badarg = 1;
+
+    if ((file_qs_priv == NULL) && (self_sign == 1))
+        badarg = 1;
+
+    if ((file_qs_priv == NULL) && (qs_key_format == FORMAT_ENGINE))
+        badarg = 1;
+
+    if ((file_qs_priv == NULL) && (passarg_qs != NULL))
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl x509QSDirectExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use IQR Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-x509in file       The X509 certificate in pem format.\n");
+        BIO_printf(bio_err,
+                   "-x509out file      The X509 MPKA certificate in pem format with new ALT extensions.\n");
+        BIO_printf(bio_err,
+                   "-privin file       The private key used to sign the original x509 certificate in pem format.\n");
+        BIO_printf(bio_err,
+                   "                   Optional. If absent, the QS private key must be present and be an extended\n");
+        BIO_printf(bio_err,
+                   "                   private key.\n");
+        BIO_printf(bio_err,
+                   "-pubqs file        The public QS key. Incompatible with -self_sign.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The private QS key. Optional; QS signature algorithm and value will be added\n");
+        BIO_printf(bio_err,
+                   "                   if present.\n");
+        BIO_printf(bio_err,
+                   "                   Will be rewritten to contain the classical key and QS key.\n");
+        BIO_printf(bio_err,
+                   "-privqs_engine     The private QS key should be loaded via the engine. Optional. Requires -privqs.\n");
+        BIO_printf(bio_err,
+                   "-self_sign         The public key should be obtained from the private key. Incompatible with.\n");
+        BIO_printf(bio_err,
+                   "                   -pubqs. Requires -privqs.\n");
+        BIO_printf(bio_err,
+                   "-passin            The private key password source. Optional.\n");
+        BIO_printf(bio_err,
+                   "-passqs            The private QS key password source. Requires -privqs. Optional.\n");
+        BIO_printf(bio_err,
+                   "-<cipher>          Use cipher <cipher> to encrypt the key. Optional.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the private key.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passarg_qs, NULL, &pass_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the QS private key.\n");
+        goto end;
+    }
+
+    bio_x509in = BIO_new_file(file_x509in, "rb");
+    cert = PEM_read_bio_X509(bio_x509in, NULL, NULL, NULL);
+    if (cert == NULL) {
+        BIO_printf(bio_err, "Bad certificate\n");
+        goto end;
+    }
+    BIO_free_all(bio_x509in);
+    bio_x509in = NULL;
+
+    /* Ensure this certificate does not already have alternative extensions. */
+    qs_pub_key_ind = X509_get_ext_by_NID(cert, NID_subjectAltPublicKeyInfo, -1);
+    qs_sigalg_ind = X509_get_ext_by_NID(cert, NID_altSignatureAlgorithm, -1);
+    qs_sigval_ind = X509_get_ext_by_NID(cert, NID_altSignatureValue, -1);
+    if ((qs_pub_key_ind != -1) || (qs_sigalg_ind != -1) || (qs_sigval_ind != -1)) {
+        BIO_puts(bio_err, "The input certificate already has alternative extensions.\n");
+        goto end;
+    }
+
+    if (file_priv == NULL) {
+        if (qs_key_format == FORMAT_ENGINE) {
+            char *tmp1 = strstr(file_qs_priv, "::");
+            if (tmp1 == NULL) {
+                BIO_puts(bio_err, "Engine private key, but no state separator (::).\n");
+                goto end;
+            }
+
+            char *tmp2 = OPENSSL_malloc((int)(tmp1 - file_qs_priv + 1));
+            if (tmp2 == NULL) {
+                BIO_puts(bio_err, "Memory allocation failure.\n");
+                goto end;
+            }
+
+            memcpy(tmp2, file_qs_priv, tmp1 - file_qs_priv);
+            tmp2[tmp1 - file_qs_priv] = '\0';
+            classical_privkey = load_key(bio_err, tmp2, FORMAT_PEM, 0, pass_qs, e, "Classical Private Key");
+            OPENSSL_free(tmp2);
+        } else {
+            classical_privkey = load_key(bio_err, file_qs_priv, FORMAT_PEM, 0, pass_qs, e, "Classical Private Key");
+        }
+    } else {
+        classical_privkey = load_key(bio_err, file_priv, FORMAT_PEM, 0, passin, e, "Classical Private Key");
+    }
+
+    if (classical_privkey == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    if (file_qs_priv != NULL) {
+        if (file_priv == NULL) {
+            pkey_qs_priv = load_alt_key(bio_err, file_qs_priv, qs_key_format, 0, pass_qs, e, "QS Private Key");
+        } else {
+            /* Try to load the alt key.  If its present, then that is an error
+             * since that means that the user has given 2 classical private
+             * keys.
+             */
+            pkey_qs_priv = load_alt_key(NULL, file_qs_priv, FORMAT_PEM, 0, pass_qs, e, "QS Private Key");
+            if (pkey_qs_priv != NULL) {
+                BIO_puts(bio_err, "Both dual private key file and classical private key file have been provided.\n");
+                goto end;
+            }
+
+            pkey_qs_priv = load_key(bio_err, file_qs_priv, qs_key_format, 0, pass_qs, e, "QS Private Key");
+        }
+        if (pkey_qs_priv == NULL) {
+            /* load_key() has already printed an appropriate message. */
+            goto end;
+        }
+    }
+
+    /* Read the QS Public key to be embedded in the QS certificate if it was specified.
+     * If not check the private key.
+     */
+    if (file_qs_pub == NULL) {
+        pkey_qs_pub = pkey_qs_priv;
+    } else {
+        pkey_qs_pub = load_pubkey(bio_err, file_qs_pub, FORMAT_PEM, 0, NULL, e, "QS Public Key");
+        if (pkey_qs_pub == NULL) {
+            /* load_pubkey() has already printed an appropriate message. */
+            goto end;
+        }
+    }
+
+    /* Ensure the private key is actually a QS key */
+    if ((pkey_qs_priv != NULL) && (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_priv)))) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum-safe algorithm.\n");
+        goto end;
+    }
+
+    /* Ensure the public key is actually a QS key */
+    if (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_pub))) {
+        BIO_puts(bio_err, "The provided public key is not compatible with a quantum-safe algorithm.\n");
+        goto end;
+    }
+
+    /* Convert the pkey in to an x509 public key.  This is the standard way
+     * of doing it for x509 subject public key.
+     */
+    X509_PUBKEY_set(&x509_pub_qs, pkey_qs_pub);
+
+    sapki = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    if (sapki == NULL) {
+        BIO_puts(bio_err, "Error converting public key to x509 pubkey\n");
+        goto end;
+    }
+
+    X509_ALGOR_free(sapki->algor);
+    ASN1_BIT_STRING_free(sapki->public_key);
+    sapki->algor = x509_pub_qs->algor;
+    sapki->public_key = x509_pub_qs->public_key;
+
+    if (pkey_qs_priv != NULL) {
+        /* Convert the private key into an x509 public key.  This lets us
+         * get the algorithm identifier of the private key so we can associate
+         * it with the signature.
+         */
+        X509_PUBKEY_set(&x509_sig_qs, pkey_qs_priv);
+
+        /* Create and insert QS signature algorithm as an extension. */
+
+        /* Duplicate the algorithm for the signature. */
+        algor_for_qssigalg = X509_ALGOR_dup(x509_sig_qs->algor);
+        if (algor_for_qssigalg == NULL) {
+            BIO_puts(bio_err, "Error duplicating signature algor.\n");
+            goto end;
+        }
+
+        if (X509_ALGOR_set0(algor_for_qssigalg, OBJ_nid2obj(EVP_PKEY_id(pkey_qs_priv)), ASN1_get_sigparam(pkey_qs_priv), NULL) == 0) {
+            BIO_puts(bio_err, "Error setting algorithm object ID.\n");
+            goto end;
+        }
+
+        ext_qssigalg = X509V3_EXT_i2d(NID_altSignatureAlgorithm, 0, algor_for_qssigalg);
+        if (ext_qssigalg == NULL) {
+            BIO_puts(bio_err, "Error creating signature algorithm extension.\n");
+            goto end;
+        }
+
+        /* Insert QS signature algorithm as an extension. */
+        if (X509_add_ext(cert, ext_qssigalg, -1) == 0) {
+            BIO_puts(bio_err, "Error adding signature algorithm extension.\n");
+            goto end;
+        }
+    }
+
+
+    /* Create and insert QS public key as an extension. */
+    ext_sapki = X509V3_EXT_i2d(NID_subjectAltPublicKeyInfo, 0, sapki);
+    sapki->algor = NULL;
+    sapki->public_key = NULL;
+    if (ext_sapki == NULL) {
+        BIO_puts(bio_err, "Error converting x509 pubkey to extension.\n");
+        goto end;
+    }
+
+    if (X509_add_ext(cert, ext_sapki, -1) == 0) {
+        BIO_puts(bio_err, "Error adding public key as extension\n");
+        goto end;
+    }
+
+    /* Sign the cert with the QS private key if required. */
+    if (pkey_qs_priv != NULL) {
+        if (EVP_DigestSignInit(&mctx, NULL, NULL, NULL, pkey_qs_priv) < 1) {
+            BIO_puts(bio_err, "Error doing EVP digest initialization\n");
+            goto end;
+        }
+
+        /* We could call X509_sign_ctx() here, but the following code in
+         * ASN1_item_sign_ctx() made that a bad idea:
+         *
+         *   if (algor1)
+         *       X509_ALGOR_set0(algor1, OBJ_nid2obj(signid), paramtype, NULL);
+         *   if (algor2)
+         *       X509_ALGOR_set0(algor2, OBJ_nid2obj(signid), paramtype, NULL);
+         *
+         * Those lines were modifying AlgorithmIdentifier in the X509 cert.
+         * That would change the resulting digest result which is a side effect
+         * we would like to avoid.
+         *
+         * X509_sign_ctx() just sets the modified flag and calls
+         * ASN1_item_sign_ctx().  We can do that and instead of passing the
+         * algors, we just pass NULL and a custom signature BISTRING.
+         */
+
+        cert->cert_info->enc.modified = 1;
+
+        qs_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+        if (qs_sigval_as_asn1bitstring == NULL) {
+             BIO_puts(bio_err, "ASN1 bit string memory allocation error.\n");
+             goto end;
+        }
+
+        if (ASN1_item_sign_ctx(ASN1_ITEM_rptr(X509_PCINF), NULL, NULL, qs_sigval_as_asn1bitstring, cert->cert_info, &mctx) <= 0) {
+            BIO_puts(bio_err, "Quantum-safe signing operation failed.\n");
+            goto end;
+        }
+
+
+        qs_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+        qs_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+        /* Create QS signature as an extension. */
+        ext_qssig = X509V3_EXT_i2d(NID_altSignatureValue, 0, qs_sigval_as_asn1bitstring);
+        if (ext_qssig == NULL) {
+            BIO_puts(bio_err, "Error creating signature extension.\n");
+            goto end;
+        }
+
+        /* Insert QS signature as an extension. */
+        if (X509_add_ext(cert, ext_qssig, -1) == 0) {
+            BIO_puts(bio_err, "Error adding signature extension\n");
+            goto end;
+        }
+    }
+
+    /* Re-sign the certificate with the original classical private key. */
+    if (X509_sign(cert, classical_privkey, NULL) == 0) {
+        BIO_puts(bio_err, "Error generating classical signature.\n");
+        goto end;
+    }
+
+    /* Write the new signed certificate with extensions in it. */
+    bio_x509out = BIO_new_file(file_x509out, "wb");
+    if (PEM_write_bio_X509(bio_x509out, cert) == 0) {
+        BIO_puts(bio_err, "Error writing new certificate.\n");
+        goto end;
+    }
+
+    if (file_qs_priv != NULL) {
+        if (qs_key_format == FORMAT_ENGINE) {
+            char *tmp = strstr(file_qs_priv, "::");
+            if (tmp == NULL) {
+                BIO_puts(bio_err, "Engine private key, but no state separator (::).\n");
+                goto end;
+            }
+
+            file_qs_priv_out = OPENSSL_malloc((int)(tmp - file_qs_priv + 1));
+            if (file_qs_priv_out == NULL) {
+                BIO_puts(bio_err, "Memory allocation failure.\n");
+                goto end;
+            }
+
+            memcpy(file_qs_priv_out, file_qs_priv, tmp - file_qs_priv);
+            file_qs_priv_out[tmp - file_qs_priv] = '\0';
+            bio_privqsout = BIO_new_file(file_qs_priv_out, "wb");
+        } else {
+            bio_privqsout = BIO_new_file(file_qs_priv, "wb");
+        }
+
+        /* Write the combined private key.  Encrypt BOTH with the QS password. */
+        if (PEM_write_bio_PKCS8PrivateKey(bio_privqsout, classical_privkey, cipher, NULL, 0, NULL, pass_qs) == 0) {
+            BIO_puts(bio_err, "Error writing classical private key to the combined file.\n");
+            goto end;
+        }
+
+        if (PEM_write_bio_ALT_PKCS8PrivateKey(bio_privqsout, pkey_qs_priv, cipher, NULL, 0, NULL, pass_qs) == 0) {
+            BIO_puts(bio_err, "Error writing QS private key to the combined file.\n");
+            goto end;
+        }
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (bio_x509in)
+        BIO_free_all(bio_x509in);
+    if (bio_x509out)
+        BIO_free_all(bio_x509out);
+    if (bio_privqsout)
+        BIO_free_all(bio_privqsout);
+    if (cert)
+        X509_free(cert);
+    if (pkey_qs_pub == pkey_qs_priv)
+        pkey_qs_pub = NULL;
+    if (pkey_qs_pub)
+        EVP_PKEY_free(pkey_qs_pub);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (x509_pub_qs)
+        X509_PUBKEY_free(x509_pub_qs);
+    if (x509_sig_qs)
+        X509_PUBKEY_free(x509_sig_qs);
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    if (algor_for_qssigalg)
+        X509_ALGOR_free(algor_for_qssigalg);
+    if (file_qs_priv_out)
+        OPENSSL_free(file_qs_priv_out);
+
+    if (qs_sigval_as_asn1bitstring)
+        ASN1_BIT_STRING_free(qs_sigval_as_asn1bitstring);
+    if (ext_sapki)
+        X509_EXTENSION_free(ext_sapki);
+    if (ext_qssig)
+        X509_EXTENSION_free(ext_qssig);
+    if (ext_qssigalg)
+        X509_EXTENSION_free(ext_qssigalg);
+
+    if (passargin && passin)
+        OPENSSL_free(passin);
+    if (passarg_qs && pass_qs)
+        OPENSSL_free(pass_qs);
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
+
diff --git a/openssl-1.0.2r/apps/QSExtend/x509QSExtend.c b/openssl-1.0.2r/apps/QSExtend/x509QSExtend.c
new file mode 100644
index 00000000..ae7ab547
--- /dev/null
+++ b/openssl-1.0.2r/apps/QSExtend/x509QSExtend.c
@@ -0,0 +1,718 @@
+/** @file x509QSExtend.c Load QS CSR and traditional X.509 certificate and use them to create a multiple public key algorithm certificate.
+ *
+ * @copyright Copyright (C) 2017-2019, ISARA Corporation, All Rights Reserved.
+ */
+
+/* Modified.  Was genpkey.c. 
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/asn1_mac.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+
+static SUBJECT_ALT_PUBLIC_KEY_INFO *get_SAPKI_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_subjectAltPublicKeyInfo);
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    ASN1_STRING *s = NULL;
+    const unsigned char *data = NULL;
+    long length = 0;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_SEQUENCE)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    s = so->value.sequence;
+    data = ASN1_STRING_data(s);
+    length = ASN1_STRING_length(s);
+    sapki = d2i_SUBJECT_ALT_PUBLIC_KEY_INFO(NULL, &data, length);
+    return sapki;
+
+err:
+    return NULL;
+}
+
+static ASN1_BIT_STRING *get_ALTSIG_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_altSignatureValue);
+    ASN1_BIT_STRING *altsig = NULL;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_BIT_STRING)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    altsig = X509_ATTRIBUTE_get0_data(attr, 0, V_ASN1_BIT_STRING, NULL);
+    if (altsig == NULL) {
+        fprintf (stderr, "Couldn't get ASN1 data from attribute.\n") ;
+        goto err;
+    }
+
+    return altsig;
+
+err:
+    return NULL;
+}
+
+static X509_ALGOR *get_ALTSIGALG_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_altSignatureAlgorithm);
+    X509_ALGOR *altsigalg = NULL;
+    ASN1_STRING *s = NULL;
+    const unsigned char *data = NULL;
+    long length = 0;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_SEQUENCE)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    s = so->value.sequence;
+    data = ASN1_STRING_data(s);
+    length = ASN1_STRING_length(s);
+    altsigalg = d2i_X509_ALGOR(NULL, &data, length);
+    return altsigalg;
+
+err:
+    return NULL;
+}
+
+#undef PROG
+#define PROG    x509QSExtend_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args = NULL;
+    int badarg = 0;
+    int ret = 1;
+    char *passin_qs = NULL;
+    char *passargin_qs = NULL;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *pkey_qs_pub = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+    X509_REQ *req = NULL;
+    X509_REQ *tmpreq = NULL;
+    EVP_PKEY *tmppkey = NULL;
+
+    BIO *bio_x509in = NULL;
+    BIO *bio_x509out = NULL;
+    BIO *bio_req = NULL;
+    const char *file_qs_priv = NULL;
+    const char *file_x509in = NULL;
+    const char *file_x509out = NULL;
+
+    X509_ALGOR *algor_for_qssigalg = NULL;
+    X509_EXTENSION *ext_qssigalg = NULL;
+
+    X509 *cert = NULL;
+    ASN1_BIT_STRING *qs_sigval_as_asn1bitstring = NULL;
+
+    int alg_nid = -1;
+    X509_EXTENSION *ext_qssig = NULL;
+    X509_ALGOR *qssig_algor = NULL;
+
+    X509_PUBKEY *x509_pub_qs = NULL;
+    X509_PUBKEY *x509_sig_qs = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki_in = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki_out = NULL;
+    X509_EXTENSION *ext_sapki = NULL;
+
+    X509_ATTRIBUTE *qs_pub_key_attr = NULL;
+    int qs_pub_key_ind = -1;
+
+    X509_ATTRIBUTE *qs_sigval_attr = NULL;
+    int qs_sigval_ind = -1;
+    int qs_key_format = FORMAT_PEM;
+
+    X509_ATTRIBUTE *qs_sigalg_attr = NULL;
+    int qs_sigalg_ind = -1;
+
+    EVP_MD_CTX mctx;
+    EVP_MD_CTX_init(&mctx);
+
+    ASN1_BIT_STRING *req_qssig = NULL;
+    X509_ALGOR *req_qssigalg = NULL;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    if (!load_config(bio_err, NULL))
+        goto end;
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+        } else if (strcmp(*args, "-x509in") == 0) {
+            if (!args[1])
+                goto bad;
+            file_x509in = *(++args);
+        } else if (strcmp(*args, "-x509out") == 0) {
+            if (!args[1])
+                goto bad;
+            file_x509out = *(++args);
+        } else if (strcmp(*args, "-reqin") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_req = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*args, "-privqs_engine") == 0) {
+            qs_key_format = FORMAT_ENGINE;
+        } else if (strcmp(*args, "-passinqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin_qs = *(++args);
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (file_x509in == NULL)
+        badarg = 1;
+
+    if (file_x509out == NULL)
+        badarg = 1;
+
+    if (bio_req == NULL)
+        badarg = 1;
+
+    if (file_qs_priv == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl x509QSExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use IQR Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-x509in file       The X509 certificate in pem format.\n");
+        BIO_printf(bio_err,
+                   "-x509out file      The X509 MPKA certificate in pem format with new ALT extensions.\n");
+        BIO_printf(bio_err,
+                   "-reqin file        The certificate signing request containing the ALT public key extension.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The private QS key. \n");
+        BIO_printf(bio_err,
+                   "-privqs_engine     The private QS key should be loaded via the engine. Optional.\n");
+        BIO_printf(bio_err,
+                   "-passinqs          The private QS key password source. Optional.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin_qs, NULL, &passin_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the QS private key.\n");
+        goto end;
+    }
+
+    /* Read in the req which contains the public key */
+    req = PEM_read_bio_X509_REQ(bio_req, NULL, NULL, NULL);
+    if (req == NULL) {
+        BIO_printf(bio_err, "Bad certificate signing request.\n");
+        goto end;
+    }
+
+    /* Get the ALT public key attribute. */
+    qs_pub_key_ind = X509_REQ_get_attr_by_NID(req, NID_subjectAltPublicKeyInfo, -1);
+    if (qs_pub_key_ind < 0) {
+        fprintf(stderr, "Error finding the req's ALT public key attribute.\n");
+        goto end;
+    }
+
+    qs_pub_key_attr = X509_REQ_get_attr(req, qs_pub_key_ind);
+    if (qs_pub_key_attr == NULL) {
+        fprintf(stderr, "Error getting the req's ALT public key attribute.\n");
+        goto end;
+    }
+
+    sapki_in = get_SAPKI_from_ATTRIBUTE(qs_pub_key_attr);
+    if (sapki_in == NULL) {
+        fprintf(stderr, "Error converting the req's ALT public key attribute into ASN.1.\n");
+        goto end;
+    }
+
+    /* Convert the ALT public key attribute to a pkey. */
+    x509_pub_qs = X509_PUBKEY_new();
+    if (x509_pub_qs == NULL) {
+        fprintf(stderr, "Memory allocation error.\n");
+        goto end;
+    }
+
+    X509_ALGOR_free(x509_pub_qs->algor);
+    ASN1_BIT_STRING_free(x509_pub_qs->public_key);
+
+    x509_pub_qs->algor = sapki_in->algor;
+    x509_pub_qs->public_key = sapki_in->public_key;
+    x509_pub_qs->pkey = NULL;
+
+    pkey_qs_pub = X509_PUBKEY_get(x509_pub_qs);
+
+    x509_pub_qs->algor = NULL;
+    x509_pub_qs->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_qs);
+    x509_pub_qs = NULL;
+
+    if (pkey_qs_pub == NULL) {
+        BIO_printf(bio_err, "Bad QS public key.\n");
+        goto end;
+    }
+
+    /* Get the ALT signature attribute. */
+    qs_sigval_ind = X509_REQ_get_attr_by_NID(req, NID_altSignatureValue, -1);
+    if (qs_sigval_ind < 0) {
+        fprintf(stderr, "Error finding the req's ALT signature attribute.\n");
+        goto end;
+    }
+
+    qs_sigval_attr = X509_REQ_get_attr(req, qs_sigval_ind);
+    if (qs_sigval_attr == NULL) {
+        fprintf(stderr, "Error getting the req's ALT signature attribute.\n");
+        goto end;
+    }
+
+    /* Remove the ALT signature attribute to make it look the same as when it
+     * was signed.
+     */
+    if (X509_REQ_delete_attr(req, qs_sigval_ind) == 0) {
+        fprintf(stderr, "Error getting the req's ALT signature attribute.\n");
+        goto end;
+    }
+
+    req_qssig = get_ALTSIG_from_ATTRIBUTE(qs_sigval_attr);
+    if (req_qssig == NULL) {
+        fprintf(stderr, "Error converting the req's ALT signature attribute into ASN.1.\n");
+        goto end;
+    }
+
+    /* Get the ALT signature algorithm attribute. */
+    qs_sigalg_ind = X509_REQ_get_attr_by_NID(req, NID_altSignatureAlgorithm, -1);
+    if (qs_sigalg_ind < 0) {
+        fprintf(stderr, "Error finding the req's ALT signature algorithm attribute index.\n");
+        goto end;
+    }
+
+    qs_sigalg_attr = X509_REQ_get_attr(req, qs_sigalg_ind);
+    if (qs_sigalg_attr == NULL) {
+        fprintf(stderr, "Error getting the req's ALT signature algorithm attribute.\n");
+        goto end;
+    }
+
+    req_qssigalg = get_ALTSIGALG_from_ATTRIBUTE(qs_sigalg_attr);
+    if (req_qssigalg == NULL) {
+        fprintf(stderr, "Error converting the req's ALT signature attribute into ASN.1.\n");
+        goto end;
+    }
+
+    /* Ensure that the signature algorithm of the sig and the algorithm of the public key
+     * match. We can't use X509_ALGOR_cmp() because the OIDs don't match. The
+     * signature OID includes information about the digest. We don't worry about digest
+     * and parameter mismatch as the actual verification will catch that.
+     */
+    if (OBJ_find_sigid_algs(OBJ_obj2nid(req_qssigalg->algorithm), NULL, &alg_nid) == 0) {
+        fprintf(stderr, "Couldn't get the algorithm ID from the ALT signature.\n");
+        goto end;
+    }
+
+    if (alg_nid != OBJ_obj2nid(sapki_in->algor->algorithm)) {
+        fprintf(stderr, "Issuer public key algorithm does not match signature algorithm\n");
+        fprintf(stderr, "Issuer: %s\n", OBJ_nid2ln(OBJ_obj2nid(sapki_in->algor->algorithm)));
+        fprintf(stderr, "Current: %s\n", OBJ_nid2ln(OBJ_obj2nid(req_qssigalg->algorithm)));
+        goto end;
+    }
+
+    req->req_info->enc.modified = 1;
+
+    if (ASN1_item_verify(ASN1_ITEM_rptr(X509_REQ_INFO), req_qssigalg,
+                         req_qssig, req->req_info, pkey_qs_pub) <= 0) {
+        printf("QS verification FAILED!\n");
+        goto end;
+    }
+
+    /* We do not do verification of the classical signature as we assume it was
+     * done during the creation of the classical chain. Now that the req is
+     * verified, we can construct the cert.
+     */
+
+    /* Read in the classical cert. */
+    bio_x509in = BIO_new_file(file_x509in, "rb");
+    cert = PEM_read_bio_X509(bio_x509in, NULL, NULL, NULL);
+    if (cert == NULL) {
+        BIO_printf(bio_err, "Bad certificate\n");
+        goto end;
+    }
+    BIO_free_all(bio_x509in);
+    bio_x509in = NULL;
+
+    /* Ensure this certificate does not already have alternative extensions. */
+    qs_pub_key_ind = X509_get_ext_by_NID(cert, NID_subjectAltPublicKeyInfo, -1);
+    qs_sigalg_ind = X509_get_ext_by_NID(cert, NID_altSignatureAlgorithm, -1);
+    qs_sigval_ind = X509_get_ext_by_NID(cert, NID_altSignatureValue, -1);
+    if ((qs_pub_key_ind != -1) || (qs_sigalg_ind != -1) || (qs_sigval_ind != -1)) {
+        BIO_puts(bio_err, "The input certificate already has alternative extensions.\n");
+        goto end;
+    }
+
+    /* Read in the classical private key that will be used to re-sign
+     * this cert. If an engine is being used to read in the private key there
+     * will be extra stuff for the state.  Remove it.
+     */
+    if (qs_key_format == FORMAT_ENGINE) {
+        char *tmp1 = strstr(file_qs_priv, "::");
+        if (tmp1 == NULL) {
+            BIO_puts(bio_err, "Engine private key, but no state separator (::).\n");
+            goto end;
+        }
+
+        char *tmp2 = OPENSSL_malloc((int)(tmp1 - file_qs_priv + 1));
+        if (tmp2 == NULL) {
+            BIO_puts(bio_err, "Memory allocation failure.\n");
+            goto end;
+        }
+
+        memcpy(tmp2, file_qs_priv, tmp1 - file_qs_priv);
+        tmp2[tmp1 - file_qs_priv] = '\0';
+        classical_privkey = load_key(bio_err, tmp2, FORMAT_PEM, 0, passin_qs, e, "Classical Private Key");
+        OPENSSL_free(tmp2);
+    } else {
+        classical_privkey = load_key(bio_err, file_qs_priv, FORMAT_PEM, 0, passin_qs, e, "Classical Private Key");
+    }
+
+    if (classical_privkey == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Read in the QS private key that will be used to create the QS
+     * signature.
+     */
+    pkey_qs_priv = load_alt_key(bio_err, file_qs_priv, qs_key_format, 0, passin_qs, e, "QS Private Key");
+    if (pkey_qs_priv == NULL) {
+        /* load_alt_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Ensure the private key is actually a QS key */
+    if (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_priv))) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum-safe algorithm.\n");
+        goto end;
+    }
+
+    /* Make sure the public key is actually QS. */
+    if (!EVP_PKEY_is_QS_auth(EVP_PKEY_id(pkey_qs_pub))) {
+        BIO_puts(bio_err, "The provided public key is not compatible with a quantum-safe algorithm.\n");
+        goto end;
+    }
+
+    /* Convert the private key into an x509 public key.  This lets us
+     * get the algorithm identifier of the private key so we can associate
+     * it with the signature.
+     */
+    X509_PUBKEY_set(&x509_sig_qs, pkey_qs_priv);
+
+    /* Convert the pkey into an x509 format public key. */
+    X509_PUBKEY_set(&x509_pub_qs, pkey_qs_pub);
+
+    sapki_out = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    X509_ALGOR_free(sapki_out->algor);
+    ASN1_BIT_STRING_free(sapki_out->public_key);
+    sapki_out->algor = x509_pub_qs->algor;
+    sapki_out->public_key = x509_pub_qs->public_key;
+
+    /* The next few blocks of code create and insert the QS signature algorithm
+     * as an extension.
+     */
+
+    /* Duplicate the algorithm for the signature. */
+    algor_for_qssigalg = X509_ALGOR_dup(x509_sig_qs->algor);
+    if (algor_for_qssigalg == NULL) {
+        BIO_puts(bio_err, "Error duplicating signature algor.\n");
+        goto end;
+    }
+
+    /* Set the Object ID based on the NID and then convert into an extension. */
+    if (X509_ALGOR_set0(algor_for_qssigalg, OBJ_nid2obj(EVP_PKEY_id(pkey_qs_priv)), ASN1_get_sigparam(pkey_qs_priv), NULL) == 0) {
+        BIO_puts(bio_err, "Error setting algorithm object ID.\n");
+        goto end;
+    }
+
+    ext_qssigalg = X509V3_EXT_i2d(NID_altSignatureAlgorithm, 0, algor_for_qssigalg);
+    if (ext_qssigalg == NULL) {
+        BIO_puts(bio_err, "Error creating signature algorithm extension.\n");
+        goto end;
+    }
+
+    /* Insert QS signature algorithm as an extension. */
+    if (X509_add_ext(cert, ext_qssigalg, -1) == 0) {
+        BIO_puts(bio_err, "Error adding signature algorithm extension.\n");
+        goto end;
+    }
+
+    /* Create and insert QS public key as an extension. */
+    ext_sapki = X509V3_EXT_i2d(NID_subjectAltPublicKeyInfo, 0, sapki_out);
+    sapki_out->algor = NULL;
+    sapki_out->public_key = NULL;
+    if (ext_sapki == NULL) {
+        BIO_puts(bio_err, "Error converting x509 pubkey to extension.\n");
+        goto end;
+    }
+
+    /* Add the ALT public key extension to the cert. */
+    if (X509_add_ext(cert, ext_sapki, -1) == 0) {
+        BIO_puts(bio_err, "Error adding public key as extension\n");
+        goto end;
+    }
+
+    /* Sign the cert with the QS private key. */
+    if (EVP_DigestSignInit(&mctx, NULL, NULL, NULL, pkey_qs_priv) < 1) {
+        BIO_puts(bio_err, "Error doing EVP digest initialization\n");
+        goto end;
+    }
+
+    /* We could call X509_sign_ctx() here, but the following code in
+     * ASN1_item_sign_ctx() made that a bad idea:
+     *
+     *   if (algor1)
+     *       X509_ALGOR_set0(algor1, OBJ_nid2obj(signid), paramtype, NULL);
+     *   if (algor2)
+     *       X509_ALGOR_set0(algor2, OBJ_nid2obj(signid), paramtype, NULL);
+     *
+     * Those lines were modifying AlgorithmIdentifier in the X509 cert.
+     * That would change the resulting digest result which is a side effect
+     * we would like to avoid.
+     *
+     * X509_sign_ctx() just sets the modified flag and calls
+     * ASN1_item_sign_ctx().  We can do that and instead of passing the
+     * algors, we just pass NULL and a custom signature BISTRING.
+     */
+
+    cert->cert_info->enc.modified = 1;
+
+    qs_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+    if (qs_sigval_as_asn1bitstring == NULL) {
+         BIO_puts(bio_err, "ASN1 bit string memory allocation error.\n");
+         goto end;
+    }
+
+    if (ASN1_item_sign_ctx(ASN1_ITEM_rptr(X509_PCINF), NULL, NULL, qs_sigval_as_asn1bitstring, cert->cert_info, &mctx) <= 0) {
+        BIO_puts(bio_err, "Quantum-safe signing operation failed.\n");
+        goto end;
+    }
+
+    qs_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+    qs_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+
+    /* Create QS signature as an extension. */
+    ext_qssig = X509V3_EXT_i2d(NID_altSignatureValue, 0, qs_sigval_as_asn1bitstring);
+    if (ext_qssig == NULL) {
+        BIO_puts(bio_err, "Error creating signature extension.\n");
+        goto end;
+    }
+
+    /* Insert QS signature as an extension. */
+    if (X509_add_ext(cert, ext_qssig, -1) == 0) {
+        BIO_puts(bio_err, "Error adding signature extension\n");
+        goto end;
+    }
+
+    /* Re-sign the certificate with the original classical private key. */
+    if (X509_sign(cert, classical_privkey, NULL) == 0) {
+        BIO_puts(bio_err, "Error generating classical signature.\n");
+        goto end;
+    }
+
+    /* write the new signed certificate with extensions in it. */
+    bio_x509out = BIO_new_file(file_x509out, "wb");
+    if (PEM_write_bio_X509(bio_x509out, cert) == 0) {
+        BIO_puts(bio_err, "Error writing new certificate.\n");
+        goto end;
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (tmpreq)
+        X509_REQ_free(tmpreq);
+    if (tmppkey)
+        EVP_PKEY_free(tmppkey);
+    if (bio_req)
+        BIO_free_all(bio_req);
+    if (bio_x509in)
+        BIO_free_all(bio_x509in);
+    if (bio_x509out)
+        BIO_free_all(bio_x509out);
+    if (cert)
+        X509_free(cert);
+    if (pkey_qs_pub)
+        EVP_PKEY_free(pkey_qs_pub);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (req)
+        X509_REQ_free(req);
+
+    if (sapki_in)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki_in);
+    if (sapki_out)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki_out);
+    if (algor_for_qssigalg)
+        X509_ALGOR_free(algor_for_qssigalg);
+    if (req_qssigalg)
+        X509_ALGOR_free(req_qssigalg);
+    if (x509_pub_qs)
+        X509_PUBKEY_free(x509_pub_qs);
+    if (x509_sig_qs)
+        X509_PUBKEY_free(x509_sig_qs);
+    if (qssig_algor)
+        X509_ALGOR_free(qssig_algor);
+    if (qs_sigval_as_asn1bitstring)
+        ASN1_BIT_STRING_free(qs_sigval_as_asn1bitstring);
+    if (ext_sapki)
+        X509_EXTENSION_free(ext_sapki);
+    if (ext_qssig)
+        X509_EXTENSION_free(ext_qssig);
+    if (ext_qssigalg)
+        X509_EXTENSION_free(ext_qssigalg);
+
+    if (qs_sigval_attr)
+        X509_ATTRIBUTE_free(qs_sigval_attr);
+
+    /* I don't need to free qs_sigalg_attr because it is still referenced by
+     * the req.
+     */
+    if (passargin_qs && passin_qs)
+        OPENSSL_free(passin_qs);
+
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
+
diff --git a/openssl-1.0.2r/apps/QSExtend/x509QSVerify.c b/openssl-1.0.2r/apps/QSExtend/x509QSVerify.c
new file mode 100644
index 00000000..7f9210c5
--- /dev/null
+++ b/openssl-1.0.2r/apps/QSExtend/x509QSVerify.c
@@ -0,0 +1,568 @@
+/** @file openssl_x509QSVerify.c Verification of the QS multiple public key algorithm certificates.
+ *
+ * @copyright Copyright (C) 2017-2019, ISARA Corporation, All Rights Reserved.
+ */
+
+/* Modified.  Was genpkey.c.
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/asn1.h>
+
+static int x509qsverify_load_certs(BIO *err, BIO *bio,
+                      const char *pass, ENGINE *e,
+                      STACK_OF(X509) **pcerts)
+{
+    int i;
+    STACK_OF(X509_INFO) *xis = NULL;
+    X509_INFO *xi;
+    int rv = 0;
+
+    xis = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);
+
+    if (pcerts) {
+        *pcerts = sk_X509_new_null();
+        if (!*pcerts)
+            goto end;
+    }
+
+    for (i = 0; i < sk_X509_INFO_num(xis); i++) {
+        xi = sk_X509_INFO_value(xis, i);
+        if (xi->x509 && pcerts) {
+            if (!sk_X509_push(*pcerts, xi->x509))
+                goto end;
+            xi->x509 = NULL;
+        }
+    }
+
+    if (pcerts && sk_X509_num(*pcerts) > 0)
+        rv = 1;
+
+ end:
+
+    if (xis)
+        sk_X509_INFO_pop_free(xis, X509_INFO_free);
+
+    if (rv == 0) {
+        if (pcerts) {
+            sk_X509_pop_free(*pcerts, X509_free);
+            *pcerts = NULL;
+        }
+        BIO_printf(err, "unable to load certificates.\n");
+        ERR_print_errors(err);
+    }
+    return rv;
+}
+
+EVP_PKEY *get_SAPKI_pubkey(SUBJECT_ALT_PUBLIC_KEY_INFO *sapki) {
+    X509_PUBKEY *x509_pub_qs = NULL;
+    EVP_PKEY *qs_pub_key = NULL;
+
+    /* Convert the x509 formatted public key into a pkey */
+    x509_pub_qs = X509_PUBKEY_new();
+    if (x509_pub_qs == NULL) {
+        fprintf(stderr, "Memory allocation error.\n");
+        goto end;
+    }
+    X509_ALGOR_free(x509_pub_qs->algor);
+    ASN1_BIT_STRING_free(x509_pub_qs->public_key);
+
+    x509_pub_qs->algor = sapki->algor;
+    x509_pub_qs->public_key = sapki->public_key;
+    x509_pub_qs->pkey = NULL;
+
+    qs_pub_key = X509_PUBKEY_get(x509_pub_qs);
+
+    x509_pub_qs->algor = NULL;
+    x509_pub_qs->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_qs);
+    x509_pub_qs = NULL;
+
+    if (qs_pub_key == NULL) {
+        fprintf(stderr, "Error converting ALT public key into a PKEY.\n");
+        goto end;
+    }
+
+end:
+
+    return qs_pub_key;    
+}
+
+#define X509_NAME_LINE_LENGTH 128
+
+/* on WIN16 you need to add `_far _loadds` */
+static int qs_verification_cb(int ok, X509_STORE_CTX *ctx) {
+    X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);
+    int cert_error = X509_STORE_CTX_get_error(ctx);
+    int cert_depth = X509_STORE_CTX_get_error_depth(ctx);
+    STACK_OF(X509) *chain = X509_STORE_CTX_get1_chain(ctx);
+    ASN1_BIT_STRING *new_sig = NULL;
+    X509 * alt_free_cert = NULL;
+    X509 *issuer = NULL;
+
+    int qs_pub_key_ind = -1;
+    X509_EXTENSION *qs_pub_key_ext = NULL;
+
+    int qs_sigalg_ind = -1;
+    X509_ALGOR *qssigalg = NULL;
+    X509_EXTENSION *qs_sigalg_ext = NULL;
+
+    int alg_nid = -1;
+    int qs_sigval_ind = -1;
+    X509_EXTENSION *qs_sigval_ext = NULL;
+    X509_EXTENSION *new_qs_sigval_ext = NULL;
+
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    ASN1_BIT_STRING *qssig = NULL;
+    EVP_PKEY * qs_pub_key = NULL;
+
+    char cert_name[X509_NAME_LINE_LENGTH];
+
+    if (!ok) {
+        if (current_cert) {
+            X509_NAME_print_ex_fp(stderr,
+                                  X509_get_subject_name(current_cert),
+                                  0, XN_FLAG_ONELINE);
+            fprintf(stderr, "\n");
+        }
+        printf("%serror %d at %d depth lookup:%s\n",
+               X509_STORE_CTX_get0_parent_ctx(ctx) ? "[CRL path]" : "",
+               cert_error,
+               X509_STORE_CTX_get_error_depth(ctx),
+               X509_verify_cert_error_string(cert_error));
+        switch (cert_error) {
+        case X509_V_ERR_NO_EXPLICIT_POLICY:
+        case X509_V_ERR_CERT_HAS_EXPIRED:
+
+            /*
+             * since we are just checking the certificates, it is ok if they
+             * are self signed. But we should still warn the user.
+             */
+
+        case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+            /* Continue after extension errors too */
+        case X509_V_ERR_INVALID_CA:
+        case X509_V_ERR_INVALID_NON_CA:
+        case X509_V_ERR_PATH_LENGTH_EXCEEDED:
+        case X509_V_ERR_INVALID_PURPOSE:
+        case X509_V_ERR_CRL_HAS_EXPIRED:
+        case X509_V_ERR_CRL_NOT_YET_VALID:
+        case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
+            ok = 1;
+
+        }
+    }
+
+    if (chain == NULL) {
+        fprintf(stderr, "Error getting a certificate chain to verify.\n");
+        goto end;
+    }
+
+    if (current_cert == NULL) {
+        fprintf(stderr, "Error getting a certificate to verify.\n");
+        goto end;
+    }
+
+    if (sk_X509_num(chain) - 1 == cert_depth) {
+        /* This is a root cert.  If it is self signed then there is no point
+         * in verifying it. If is is NOT self signed then we don't have the
+         * signer cert so we cannot verify it.
+         */
+        goto end;
+    }
+
+    /* This is where the QS verification actually is done. */
+    ok = 0;
+
+    /* Grab the next cert in the stack. That should be the issuer. OpenSSL
+     * should have checked that for us so we don't bother with any checks.
+     * We simply get the QS public key out of the extensions and convert
+     * it to a pkey.  However, if this is the root cert, it is self signed
+     * so in a sense the root cert is its own issuer. Normally, an X.509 root
+     * cert is not verified, however this utility does verification to confirm
+     * that the work done by other utilities in this suite was performed
+     * correctly.
+     */
+    if (sk_X509_num(chain) - 1 == cert_depth) {
+        issuer = sk_X509_value(chain, cert_depth);
+    } else {
+        issuer = sk_X509_value(chain, cert_depth + 1);
+    }
+    if (issuer == NULL) {
+        fprintf(stderr, "Error finding the issuer certificate.\n");
+        goto end;
+    }
+
+    /* Find the issuer's ALT public key extension. */
+    qs_pub_key_ind = X509_get_ext_by_NID(issuer, NID_subjectAltPublicKeyInfo, -1);
+    if (qs_pub_key_ind < 0) {
+        fprintf(stderr, "Error finding the issuer's ALT pulbic key extension.\n");
+        goto end;
+    }
+
+    /* Get the issuer's ALT public key extension. */
+    qs_pub_key_ext = X509_get_ext(issuer, qs_pub_key_ind);
+    if (qs_pub_key_ext == NULL) {
+        fprintf(stderr, "Error getting the issuer's ALT public key extension.\n");
+        goto end;
+    }
+
+    /* ASN.1 parse the ALT public key extension. */
+    sapki = X509V3_EXT_d2i(qs_pub_key_ext);
+    if (sapki == NULL) {
+        fprintf(stderr, "Error converting the issuer's ALT public key extension into ASN.1.\n");
+        goto end;
+    }
+
+    qs_pub_key = get_SAPKI_pubkey(sapki);
+    if (qs_pub_key == NULL) {
+        fprintf(stderr, "Error converting ALT public key into a PKEY.\n");
+        goto end;
+    }
+
+    /* Find the ALT signature algorithm extension and convert it into data. */
+    qs_sigalg_ind = X509_get_ext_by_NID(current_cert, NID_altSignatureAlgorithm, -1);
+    if (qs_sigalg_ind < 0) {
+        fprintf(stderr, "Error finding the certificate's ALT signature algorithm extension.\n");
+        goto end;
+    }
+
+    qs_sigalg_ext = X509_get_ext(current_cert, qs_sigalg_ind);
+    if (qs_sigalg_ext == NULL) {
+        fprintf(stderr, "Error getting the certificate's ALT signature algorithm extension.\n");
+        goto end;
+    }
+
+    qssigalg = X509V3_EXT_d2i(qs_sigalg_ext);
+    if (qssigalg == NULL) {
+        fprintf(stderr, "Error converting the issuer's ALT signature algorithm extension into ASN.1.\n");
+        goto end;
+    }
+
+    /* Find the ALT signature extension and convert it into data. */
+    qs_sigval_ind = X509_get_ext_by_NID(current_cert, NID_altSignatureValue, -1);
+    if (qs_sigval_ind < 0) {
+        fprintf(stderr, "Error finding the certificate's ALT signature extension.\n");
+        goto end;
+    }
+
+    qs_sigval_ext = X509_get_ext(current_cert, qs_sigval_ind);
+    if (qs_sigval_ext == NULL) {
+        fprintf(stderr, "Error getting the certificate's ALT signature extension.\n");
+        goto end;
+    }
+
+    qssig = X509V3_EXT_d2i(qs_sigval_ext);
+    if (qssig == NULL) {
+        fprintf(stderr, "Error converting the issuer's ALT signature extension into ASN.1.\n");
+        goto end;
+    }
+
+    /* Ensure that the signature algorithm specified in the signature extension
+     * and the algorithm of the issuer's public key matches. We can't use
+     * X509_ALGOR_cmp() because the OIDs don't match. The signature one includes
+     * information about the digest. We don't worry about digest and parameter
+     * mismatch as the actual verification will catch that.
+     */
+    if (OBJ_find_sigid_algs(OBJ_obj2nid(qssigalg->algorithm), NULL, &alg_nid) == 0) {
+        fprintf(stderr, "Couldn't get the algorithm ID from the ALT signature.\n");
+        goto end;
+    }
+
+    if (alg_nid != OBJ_obj2nid(sapki->algor->algorithm)) {
+        fprintf(stderr, "Issuer public key algorithm does not match signature algorithm\n");
+        goto end;
+    }
+
+    new_sig = M_ASN1_BIT_STRING_dup(qssig);
+    if (new_sig == NULL) {
+        fprintf(stderr, "Error duplicating the ALT signature.\n");
+        goto end;
+    }
+
+    /* Now duplicate the current certificate, remove the ALT signature extension
+     * and verify against that. We hid the classical algorithm during the signing
+     * process so we also have to do it again to verify against the same thing.
+     */
+    alt_free_cert = X509_dup(current_cert);
+    if (alt_free_cert == NULL) {
+        fprintf(stderr, "Error duplicating the certificate.\n");
+        goto end;
+    }
+
+    qs_sigval_ind = X509_get_ext_by_NID(alt_free_cert, NID_altSignatureValue, -1);
+    if (qs_sigval_ind < 0) {
+        fprintf(stderr, "Error getting the ALT signature extension.\n");
+        goto end;
+    }
+
+    new_qs_sigval_ext = X509_get_ext(alt_free_cert, qs_sigval_ind);
+    if (new_qs_sigval_ext == NULL) {
+        fprintf(stderr, "Error getting duplicate ALT signature extension to deallocate it.\n");
+        goto end;
+    }
+
+    if (X509_delete_ext(alt_free_cert, qs_sigval_ind) == NULL) {
+        fprintf(stderr, "Error removing the ALT signature extension.\n");
+        goto end;
+    }
+
+    /* Encoded data is being cached.  See https://www.openssl.org/docs/man1.1.0/crypto/X509_sign.html.
+     * Setting this flag ensures the cache is ignored.
+     */
+    alt_free_cert->cert_info->enc.modified = 1;
+
+    /* Note the use of X509_PCINF which excludes the signature field. */
+    if (ASN1_item_verify(ASN1_ITEM_rptr(X509_PCINF), qssigalg,
+                         new_sig, alt_free_cert->cert_info, qs_pub_key) <= 0) {
+        printf("QS verification FAILED!\n");
+        goto end;
+    }
+
+    ok = 1;
+
+end:
+    printf ("%d : %s : %s\n", cert_depth, ok == 1 ? "ok" : "not ok", X509_NAME_oneline(X509_get_subject_name(current_cert), cert_name, X509_NAME_LINE_LENGTH));
+
+    if (chain)
+        sk_X509_pop_free(chain, X509_free);
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    if (qssig)
+        ASN1_BIT_STRING_free(qssig);
+    if (alt_free_cert)
+        X509_free(alt_free_cert);
+    if (qs_pub_key)
+        EVP_PKEY_free(qs_pub_key);
+    if (new_sig)
+        ASN1_BIT_STRING_free(new_sig);
+    if (qssigalg)
+        X509_ALGOR_free(qssigalg);
+    if (new_qs_sigval_ext)
+        X509_EXTENSION_free(new_qs_sigval_ext);
+
+    return ok;
+}
+
+#undef PROG
+#define PROG    x509QSVerify_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args = NULL;
+    int badarg = 0;
+    int ret = 1;
+    int err_code = 0;
+
+    ENGINE *e = NULL;
+    BIO *bio_cert = NULL;
+    BIO *bio_trusted = NULL;
+    BIO *bio_untrusted = NULL;
+
+    X509 *cert = NULL;
+    STACK_OF(X509) *trusted = NULL;
+    STACK_OF(X509) *untrusted = NULL;
+
+    X509_STORE *cert_store = NULL;
+    X509_STORE_CTX *cert_store_ctx = NULL;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    if (!load_config(bio_err, NULL))
+        goto end;
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+        } else if (strcmp(*args, "-root") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_trusted = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-untrusted") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_untrusted = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-cert") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_cert = BIO_new_file(*(++args), "rb");
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (bio_trusted == NULL)
+        badarg = 1;
+
+    if (bio_cert == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl x509QSVerify [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use IQR Engine library <e>\n");
+        BIO_printf(bio_err,
+                   "-root file         The self signed X509 root certificates concatenated into a single file.\n");
+        BIO_printf(bio_err,
+                   "-untrusted file    All the untrusted certificates concatenated into a single file.\n");
+        BIO_printf(bio_err,
+                   "-cert file         The certificate to be verified.\n");
+        goto end;
+    }
+
+    cert_store = X509_STORE_new();
+    if (cert_store == NULL) {
+        goto end;
+    }
+
+    X509_STORE_set_verify_cb(cert_store, qs_verification_cb);
+
+    if (x509qsverify_load_certs(bio_err, bio_trusted, NULL, NULL, &trusted) == 0) {
+        BIO_printf(bio_err, "Error loading trusted certs.\n");
+        goto end;
+    }
+
+    if (bio_untrusted != NULL) {
+        if (x509qsverify_load_certs(bio_err, bio_untrusted, NULL, NULL, &untrusted) == 0) {
+            BIO_printf(bio_err, "Error loading untrusted certs.\n");
+            goto end;
+        }
+    }
+
+    cert = PEM_read_bio_X509(bio_cert, NULL, NULL, NULL);
+    if (cert == NULL) {
+        BIO_printf(bio_err, "Error loading cert to be verified.\n");
+        goto end;
+    }
+
+    cert_store_ctx = X509_STORE_CTX_new();
+    if (cert_store_ctx == NULL) {
+        ERR_print_errors(bio_err);
+        goto end;
+    }
+
+    X509_STORE_set_flags(cert_store, 0);
+
+    if (X509_STORE_CTX_init(cert_store_ctx, cert_store, cert, untrusted) == 0) {
+        ERR_print_errors(bio_err);
+        goto end;
+    }
+    X509_STORE_CTX_trusted_stack(cert_store_ctx, trusted);
+
+    if((X509_verify_cert(cert_store_ctx) == 1) && ((err_code = X509_STORE_CTX_get_error(cert_store_ctx)) == X509_V_OK)) {
+        ret = 0;
+    } else {
+        BIO_printf(bio_err, "Certificate chain verification failed with error code %d.\n", err_code);
+    }
+
+ end:
+    if (ret == 0)
+        BIO_printf(bio_err, "Success!!\n");
+    else
+        ERR_print_errors(bio_err);
+
+    if (bio_cert)
+        BIO_free_all(bio_cert);
+    if (bio_trusted)
+        BIO_free_all(bio_trusted);
+    if (bio_untrusted)
+        BIO_free_all(bio_untrusted);
+    if (cert)
+        X509_free(cert);
+    if (trusted)
+        sk_X509_pop_free(trusted, X509_free);
+    if (untrusted)
+        sk_X509_pop_free(untrusted, X509_free);
+    if (cert_store)
+        X509_STORE_free(cert_store);
+    if (cert_store_ctx) {
+        X509_STORE_CTX_cleanup(cert_store_ctx);
+        X509_STORE_CTX_free(cert_store_ctx);
+    }
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
+
diff --git a/openssl-1.0.2r/apps/apps.c b/openssl-1.0.2r/apps/apps.c
index fc1bae07..4a6330a9 100644
--- a/openssl-1.0.2r/apps/apps.c
+++ b/openssl-1.0.2r/apps/apps.c
@@ -1043,6 +1043,74 @@ EVP_PKEY *load_key(BIO *err, const char *file, int format, int maybe_stdin,
     return (pkey);
 }
 
+EVP_PKEY *load_alt_key(BIO *err, const char *file, int format, int maybe_stdin,
+                       const char *pass, ENGINE *e, const char *key_descrip)
+{
+    BIO *key = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    PW_CB_DATA cb_data;
+
+    cb_data.password = pass;
+    cb_data.prompt_info = file;
+
+    if ((format != FORMAT_ENGINE) && (format != FORMAT_PEM)) {
+        BIO_printf(err, "only support FORMAT_ENGINE and FORMAT_PEM\n");
+        goto end;
+    }
+
+    if (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE)) {
+        BIO_printf(err, "no keyfile specified\n");
+        goto end;
+    }
+#ifndef OPENSSL_NO_ENGINE
+    if (format == FORMAT_ENGINE) {
+        if (!e)
+            BIO_printf(err, "no engine specified\n");
+        else {
+            if (ENGINE_init(e)) {
+                pkey = ENGINE_load_private_key(e, file, ui_method, &cb_data);
+                ENGINE_finish(e);
+            }
+            if (!pkey) {
+                BIO_printf(err, "cannot load %s from engine\n", key_descrip);
+                ERR_print_errors(err);
+            }
+        }
+        goto end;
+    }
+#endif
+    key = BIO_new(BIO_s_file());
+    if (key == NULL) {
+        ERR_print_errors(err);
+        goto end;
+    }
+    if (file == NULL && maybe_stdin) {
+#ifdef _IONBF
+# ifndef OPENSSL_NO_SETVBUF_IONBF
+        setvbuf(stdin, NULL, _IONBF, 0);
+# endif                         /* ndef OPENSSL_NO_SETVBUF_IONBF */
+#endif
+        BIO_set_fp(key, stdin, BIO_NOCLOSE);
+    } else if (BIO_read_filename(key, file) <= 0) {
+        BIO_printf(err, "Error opening %s %s\n", key_descrip, file);
+        ERR_print_errors(err);
+        goto end;
+    }
+
+    pkey = PEM_read_bio_ALTPrivateKey(key, NULL,
+                                      (pem_password_cb *)password_callback,
+                                       &cb_data);
+
+ end:
+    if (key != NULL)
+        BIO_free(key);
+    if (pkey == NULL) {
+        BIO_printf(err, "There was no quantum-safe alternative private key in %s\n", key_descrip);
+    }
+    return (pkey);
+}
+
 EVP_PKEY *load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,
                       const char *pass, ENGINE *e, const char *key_descrip)
 {
@@ -2444,7 +2512,8 @@ int args_verify(char ***pargs, int *pargc,
 
 /*
  * Read whole contents of a BIO into an allocated memory buffer and return
- * it.
+ * it. If maxlen is set to -1, keep on reading until there is no more data
+ * or the operating system returns a memory allocation error.
  */
 
 int bio_to_mem(unsigned char **out, int maxlen, BIO *in)
@@ -2471,10 +2540,12 @@ int bio_to_mem(unsigned char **out, int maxlen, BIO *in)
             BIO_free(mem);
             return -1;
         }
-        maxlen -= len;
+        if (maxlen != -1) {
+            maxlen -= len;
 
-        if (maxlen == 0)
-            break;
+            if (maxlen == 0)
+                break;
+        }
     }
     ret = BIO_get_mem_data(mem, (char **)out);
     BIO_set_flags(mem, BIO_FLAGS_MEM_RDONLY);
diff --git a/openssl-1.0.2r/apps/apps.h b/openssl-1.0.2r/apps/apps.h
index 268863c3..48984756 100644
--- a/openssl-1.0.2r/apps/apps.h
+++ b/openssl-1.0.2r/apps/apps.h
@@ -250,6 +250,8 @@ int load_cert_crl_http(const char *url, BIO *err,
                        X509 **pcert, X509_CRL **pcrl);
 EVP_PKEY *load_key(BIO *err, const char *file, int format, int maybe_stdin,
                    const char *pass, ENGINE *e, const char *key_descrip);
+EVP_PKEY *load_alt_key(BIO *err, const char *file, int format, int maybe_stdin,
+                      const char *pass, ENGINE *e, const char *key_descrip);
 EVP_PKEY *load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,
                       const char *pass, ENGINE *e, const char *key_descrip);
 STACK_OF(X509) *load_certs(BIO *err, const char *file, int format,
diff --git a/openssl-1.0.2r/apps/ca.c b/openssl-1.0.2r/apps/ca.c
index 31e87738..afbb8c4c 100644
--- a/openssl-1.0.2r/apps/ca.c
+++ b/openssl-1.0.2r/apps/ca.c
@@ -985,7 +985,8 @@ int MAIN(int argc, char **argv)
         md = (char *)OBJ_nid2sn(def_nid);
     }
 
-    if ((dgst = EVP_get_digestbyname(md)) == NULL) {
+    dgst = EVP_get_digestbyname(md);
+    if ((dgst == NULL) && (strcmp(SN_undef, md) != 0)) {
         BIO_printf(bio_err, "%s is an unsupported message digest type\n", md);
         goto err;
     }
@@ -998,9 +999,14 @@ int MAIN(int argc, char **argv)
             if (strcmp(tmp_email_dn, "no") == 0)
                 email_dn = 0;
         }
-        if (verbose)
-            BIO_printf(bio_err, "message digest is %s\n",
-                       OBJ_nid2ln(dgst->type));
+        if (verbose) {
+            if (dgst == NULL)
+                BIO_printf(bio_err, "attempting intrinsic signing\n");
+            else
+                BIO_printf(bio_err, "message digest is %s\n",
+                           OBJ_nid2ln(dgst->type));
+        }
+
         if ((policy == NULL) && ((policy = NCONF_get_string(conf,
                                                             section,
                                                             ENV_POLICY)) ==
diff --git a/openssl-1.0.2r/apps/cms.c b/openssl-1.0.2r/apps/cms.c
index de4ba136..ce21bb12 100644
--- a/openssl-1.0.2r/apps/cms.c
+++ b/openssl-1.0.2r/apps/cms.c
@@ -790,7 +790,7 @@ int MAIN(int argc, char **argv)
             goto end;
         }
         if (contfile) {
-            BIO_free(indata);
+            BIO_free_all(indata);
             if (!(indata = BIO_new_file(contfile, "rb"))) {
                 BIO_printf(bio_err, "Can't read content file %s\n", contfile);
                 goto end;
@@ -1173,7 +1173,7 @@ int MAIN(int argc, char **argv)
     release_engine(e);
     BIO_free(rctin);
     BIO_free(in);
-    BIO_free(indata);
+    BIO_free_all(indata);
     BIO_free_all(out);
     if (passin)
         OPENSSL_free(passin);
diff --git a/openssl-1.0.2r/apps/crl.c b/openssl-1.0.2r/apps/crl.c
index c9c3a5f6..43bedc97 100644
--- a/openssl-1.0.2r/apps/crl.c
+++ b/openssl-1.0.2r/apps/crl.c
@@ -93,6 +93,9 @@ static const char *crl_usage[] = {
     " -CAfile  name   - verify CRL using certificates in file \"name\"\n",
     " -CApath  dir    - verify CRL using certificates in \"dir\"\n",
     " -nameopt arg    - various certificate name options\n",
+#ifndef OPENSSL_NO_ENGINE
+    " -engine e       - use engine e, possibly a hardware device.\n",
+#endif
     NULL
 };
 
@@ -123,6 +126,8 @@ int MAIN(int argc, char **argv)
     EVP_PKEY *pkey;
     int do_ver = 0;
     const EVP_MD *md_alg, *digest = EVP_sha1();
+    ENGINE *e = NULL;
+    char *engine = NULL;
 
     apps_startup();
 
@@ -231,7 +236,15 @@ int MAIN(int argc, char **argv)
         else if ((md_alg = EVP_get_digestbyname(*argv + 1))) {
             /* ok */
             digest = md_alg;
-        } else {
+        }
+#ifndef OPENSSL_NO_ENGINE
+        else if (strcmp(*argv, "-engine") == 0) {
+            if (--argc < 1)
+                goto bad;
+            engine = *(++argv);
+        }
+#endif
+        else {
             BIO_printf(bio_err, "unknown option %s\n", *argv);
             badops = 1;
             break;
@@ -247,6 +260,7 @@ int MAIN(int argc, char **argv)
         goto end;
     }
 
+    e = setup_engine(bio_err, engine, 0);
     ERR_load_crypto_strings();
     x = load_crl(infile, informat);
     if (x == NULL) {
@@ -437,6 +451,7 @@ int MAIN(int argc, char **argv)
         X509_STORE_CTX_cleanup(&ctx);
         X509_STORE_free(store);
     }
+    release_engine(e);
     apps_shutdown();
     OPENSSL_EXIT(ret);
 }
diff --git a/openssl-1.0.2r/apps/pkcs12.c b/openssl-1.0.2r/apps/pkcs12.c
index 0ba4c9a8..4f832380 100644
--- a/openssl-1.0.2r/apps/pkcs12.c
+++ b/openssl-1.0.2r/apps/pkcs12.c
@@ -830,6 +830,7 @@ int dump_certs_pkeys_bag(BIO *out, PKCS12_SAFEBAG *bag, char *pass,
     PKCS8_PRIV_KEY_INFO *p8;
     X509 *x509;
     int ret = 0;
+    char *fn = NULL;
 
     switch (M_PKCS12_bag_type(bag)) {
     case NID_keyBag:
@@ -842,8 +843,13 @@ int dump_certs_pkeys_bag(BIO *out, PKCS12_SAFEBAG *bag, char *pass,
         if (!(pkey = EVP_PKCS82PKEY(p8)))
             return 0;
         print_attribs(out, p8->attributes, "Key Attributes");
-        ret = PEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
+        fn = PKCS12_get_friendlyname(bag);
+        if ((fn != NULL) && (strncmp(fn, "[ALT]", strlen("[ALT]")) == 0))
+            ret = PEM_write_bio_ALT_PKCS8PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
+        else
+            ret = PEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
         EVP_PKEY_free(pkey);
+        OPENSSL_free(fn);
         break;
 
     case NID_pkcs8ShroudedKeyBag:
@@ -862,8 +868,13 @@ int dump_certs_pkeys_bag(BIO *out, PKCS12_SAFEBAG *bag, char *pass,
         }
         print_attribs(out, p8->attributes, "Key Attributes");
         PKCS8_PRIV_KEY_INFO_free(p8);
-        ret = PEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
+        fn = PKCS12_get_friendlyname(bag);
+        if ((fn != NULL) && (strncmp(fn, "[ALT]", strlen("[ALT]")) == 0))
+            ret = PEM_write_bio_ALT_PKCS8PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
+        else
+            ret = PEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
         EVP_PKEY_free(pkey);
+        OPENSSL_free(fn);
         break;
 
     case NID_certBag:
diff --git a/openssl-1.0.2r/apps/pkeyutl.c b/openssl-1.0.2r/apps/pkeyutl.c
index 19f2e5d9..c1edcc6b 100644
--- a/openssl-1.0.2r/apps/pkeyutl.c
+++ b/openssl-1.0.2r/apps/pkeyutl.c
@@ -299,8 +299,8 @@ int MAIN(int argc, char **argv)
     }
 
     if (in) {
-        /* Read the input data */
-        buf_inlen = bio_to_mem(&buf_in, keysize * 10, in);
+        /* Read the input data. -1 means we put no limit on the maximum length of the file.  */
+        buf_inlen = bio_to_mem(&buf_in, -1, in);
         if (buf_inlen < 0) {
             BIO_printf(bio_err, "Error reading input Data\n");
             exit(1);
diff --git a/openssl-1.0.2r/apps/progs.h b/openssl-1.0.2r/apps/progs.h
index d5c0039b..1f8a8bf1 100644
--- a/openssl-1.0.2r/apps/progs.h
+++ b/openssl-1.0.2r/apps/progs.h
@@ -47,6 +47,13 @@ extern int ocsp_main(int argc, char *argv[]);
 extern int prime_main(int argc, char *argv[]);
 extern int ts_main(int argc, char *argv[]);
 extern int srp_main(int argc, char *argv[]);
+extern int reqQSExtend_main(int argc, char *argv[]);
+extern int x509QSExtend_main(int argc, char *argv[]);
+extern int x509QSDirectExtend_main(int argc, char *argv[]);
+extern int x509QSVerify_main(int argc, char *argv[]);
+extern int cmsQSExtend_main(int argc, char *argv[]);
+extern int cmsQSVerify_main(int argc, char *argv[]);
+extern int pkcs12QSExtend_main(int argc, char *argv[]);
 
 #define FUNC_TYPE_GENERAL       1
 #define FUNC_TYPE_MD            2
@@ -151,6 +158,13 @@ FUNCTION functions[] = {
 #ifndef OPENSSL_NO_SRP
     {FUNC_TYPE_GENERAL, "srp", srp_main},
 #endif
+    {FUNC_TYPE_GENERAL, "reqQSExtend", reqQSExtend_main},
+    {FUNC_TYPE_GENERAL, "x509QSExtend", x509QSExtend_main},
+    {FUNC_TYPE_GENERAL, "x509QSDirectExtend", x509QSDirectExtend_main},
+    {FUNC_TYPE_GENERAL, "x509QSVerify", x509QSVerify_main},
+    {FUNC_TYPE_GENERAL, "cmsQSExtend", cmsQSExtend_main},
+    {FUNC_TYPE_GENERAL, "cmsQSVerify", cmsQSVerify_main},
+    {FUNC_TYPE_GENERAL, "pkcs12QSExtend", pkcs12QSExtend_main},
 #ifndef OPENSSL_NO_MD2
     {FUNC_TYPE_MD, "md2", dgst_main},
 #endif
diff --git a/openssl-1.0.2r/apps/s_apps.h b/openssl-1.0.2r/apps/s_apps.h
index cbb61baf..4009b31e 100644
--- a/openssl-1.0.2r/apps/s_apps.h
+++ b/openssl-1.0.2r/apps/s_apps.h
@@ -159,7 +159,7 @@ int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx);
 #endif
 #ifdef HEADER_SSL_H
 int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file);
-int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key, EVP_PKEY *qs_key,
                        STACK_OF(X509) *chain, int build_chain);
 int ssl_print_sigalgs(BIO *out, SSL *s);
 int ssl_print_point_formats(BIO *out, SSL *s);
diff --git a/openssl-1.0.2r/apps/s_cb.c b/openssl-1.0.2r/apps/s_cb.c
index 7d719543..a3826a98 100644
--- a/openssl-1.0.2r/apps/s_cb.c
+++ b/openssl-1.0.2r/apps/s_cb.c
@@ -251,7 +251,7 @@ int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)
     return (1);
 }
 
-int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key, EVP_PKEY *qs_key,
                        STACK_OF(X509) *chain, int build_chain)
 {
     int chflags = chain ? SSL_BUILD_CHAIN_FLAG_CHECK : 0;
@@ -277,6 +277,15 @@ int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
                    "Private key does not match the certificate public key\n");
         return 0;
     }
+
+    if (qs_key != NULL) {
+        if (SSL_CTX_use_ALTPrivateKey(ctx, qs_key) <= 0) {
+            BIO_printf(bio_err, "error setting the quantum-safe alternative private key\n");
+            ERR_print_errors(bio_err);
+            return 0;
+        }
+    }
+
     if (chain && !SSL_CTX_set1_chain(ctx, chain)) {
         BIO_printf(bio_err, "error setting certificate chain\n");
         ERR_print_errors(bio_err);
@@ -337,7 +346,9 @@ static void ssl_print_client_cert_types(BIO *bio, SSL *s)
         case TLS_CT_GOST01_SIGN:
             cname = "GOST01 Sign";
             break;
-
+        case TLS_CT_DILITHIUM_SIGN:
+            cname = "DILITHIUM Sign";
+            break;
         default:
             cname = NULL;
         }
@@ -385,6 +396,14 @@ static int do_print_sigalgs(BIO *out, SSL *s, int shared)
             sstr = "RSA";
         else if (sign_nid == EVP_PKEY_DSA)
             sstr = "DSA";
+        else if (sign_nid == EVP_PKEY_HSS)
+            sstr = "HSS";
+        else if (sign_nid == EVP_PKEY_XMSS)
+            sstr = "XMSS";
+        else if (sign_nid == EVP_PKEY_XMSSMT)
+            sstr = "XMSSmt";
+        else if (sign_nid == EVP_PKEY_DILITHIUM)
+            sstr = "DILITHIUM";
         else if (sign_nid == EVP_PKEY_EC)
             sstr = "ECDSA";
         if (sstr)
diff --git a/openssl-1.0.2r/apps/s_client.c b/openssl-1.0.2r/apps/s_client.c
index b455d901..65652283 100644
--- a/openssl-1.0.2r/apps/s_client.c
+++ b/openssl-1.0.2r/apps/s_client.c
@@ -675,7 +675,7 @@ int MAIN(int argc, char **argv)
     int cert_format = FORMAT_PEM, key_format = FORMAT_PEM;
     char *passarg = NULL, *pass = NULL;
     X509 *cert = NULL;
-    EVP_PKEY *key = NULL;
+    EVP_PKEY *key = NULL, *qs_key = NULL;
     STACK_OF(X509) *chain = NULL;
     char *CApath = NULL, *CAfile = NULL;
     char *chCApath = NULL, *chCAfile = NULL;
@@ -1216,6 +1216,13 @@ int MAIN(int argc, char **argv)
 
     }
 
+    /* Check for QS private key.  It is not an error if it is not present
+     * so we do not want any error message printed out if it is not found.
+     * Don't pass in bio_err.
+     */
+    qs_key = load_alt_key(NULL, key_file, FORMAT_PEM, 0, pass, e,
+        "server certificate quantum safe alternative private key");
+
     if (cert_file) {
         cert = load_cert(bio_err, cert_file, cert_format,
                          NULL, e, "client certificate file");
@@ -1375,7 +1382,7 @@ int MAIN(int argc, char **argv)
     }
 
     ssl_ctx_add_crls(ctx, crls, crl_download);
-    if (!set_cert_key_stuff(ctx, cert, key, chain, build_chain))
+    if (!set_cert_key_stuff(ctx, cert, key, qs_key, chain, build_chain))
         goto end;
 
 #ifndef OPENSSL_NO_TLSEXT
@@ -2096,6 +2103,8 @@ int MAIN(int argc, char **argv)
         sk_X509_CRL_pop_free(crls, X509_CRL_free);
     if (key)
         EVP_PKEY_free(key);
+    if (qs_key)
+        EVP_PKEY_free(qs_key);
     if (chain)
         sk_X509_pop_free(chain, X509_free);
     if (pass)
diff --git a/openssl-1.0.2r/apps/s_server.c b/openssl-1.0.2r/apps/s_server.c
index ce7a1d64..b31f5b73 100644
--- a/openssl-1.0.2r/apps/s_server.c
+++ b/openssl-1.0.2r/apps/s_server.c
@@ -1106,7 +1106,7 @@ int MAIN(int argc, char *argv[])
     int s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM;
     X509 *s_cert = NULL, *s_dcert = NULL;
     STACK_OF(X509) *s_chain = NULL, *s_dchain = NULL;
-    EVP_PKEY *s_key = NULL, *s_dkey = NULL;
+    EVP_PKEY *s_key = NULL, *s_dkey = NULL, *s_qs_key = NULL;
     int no_cache = 0, ext_cache = 0;
     int rev = 0, naccept = -1;
 #ifndef OPENSSL_NO_TLSEXT
@@ -1635,6 +1635,16 @@ int MAIN(int argc, char *argv[])
             goto end;
         }
 
+        /* Check for QS private key.  It is not an error if it is not present
+         * so we do not want any error message printed out if it is not found.
+         * Don't pass in bio_err and clear errors if no key is found.
+         */
+        s_qs_key = load_alt_key(NULL, s_key_file, FORMAT_PEM, 0, pass, e,
+                                "server certificate quantum-safe alternative private key");
+        if (s_qs_key == NULL) {
+            ERR_clear_error();
+        }
+
         s_cert = load_cert(bio_err, s_cert_file, s_cert_format,
                            NULL, e, "server certificate file");
 
@@ -1944,7 +1954,7 @@ int MAIN(int argc, char *argv[])
     }
 #endif
 
-    if (!set_cert_key_stuff(ctx, s_cert, s_key, s_chain, build_chain))
+    if (!set_cert_key_stuff(ctx, s_cert, s_key, s_qs_key, s_chain, build_chain))
         goto end;
 #ifndef OPENSSL_NO_TLSEXT
     if (s_serverinfo_file != NULL
@@ -1954,11 +1964,11 @@ int MAIN(int argc, char *argv[])
     }
 #endif
 #ifndef OPENSSL_NO_TLSEXT
-    if (ctx2 && !set_cert_key_stuff(ctx2, s_cert2, s_key2, NULL, build_chain))
+    if (ctx2 && !set_cert_key_stuff(ctx2, s_cert2, s_key2, NULL, NULL, build_chain))
         goto end;
 #endif
     if (s_dcert != NULL) {
-        if (!set_cert_key_stuff(ctx, s_dcert, s_dkey, s_dchain, build_chain))
+        if (!set_cert_key_stuff(ctx, s_dcert, s_dkey, NULL, s_dchain, build_chain))
             goto end;
     }
 #ifndef OPENSSL_NO_RSA
@@ -2090,6 +2100,8 @@ int MAIN(int argc, char *argv[])
         X509_free(s_dcert);
     if (s_key)
         EVP_PKEY_free(s_key);
+    if (s_qs_key)
+        EVP_PKEY_free(s_qs_key);
     if (s_dkey)
         EVP_PKEY_free(s_dkey);
     if (s_chain)
diff --git a/openssl-1.0.2r/config b/openssl-1.0.2r/config
index 6214c4b1..9ebe11f2 100755
--- a/openssl-1.0.2r/config
+++ b/openssl-1.0.2r/config
@@ -912,7 +912,7 @@ case "$GUESSOS" in
   i386-*) options="$options 386" ;;
 esac
 
-for i in aes bf camellia cast des dh dsa ec hmac idea md2 md5 mdc2 rc2 rc4 rc5 ripemd rsa seed sha
+for i in aes bf camellia cast cmc des dh dilithium dsa ec frododh frodokem hmac idea kyber hss md2 md5 mdc2 nh ntrup rainbow rc2 rc4 rc5 ripemd rsa samwise seed sha sidh sike sphincs xmss xmssmt
 do
   if [ ! -d crypto/$i ]
   then
diff --git a/openssl-1.0.2r/crypto/asn1/a_sign.c b/openssl-1.0.2r/crypto/asn1/a_sign.c
index 51c6a0c3..61e08501 100644
--- a/openssl-1.0.2r/crypto/asn1/a_sign.c
+++ b/openssl-1.0.2r/crypto/asn1/a_sign.c
@@ -216,6 +216,20 @@ int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,
 
 #endif
 
+int ASN1_get_sigparam(EVP_PKEY *pkey)
+{
+    if ((pkey == NULL) || (pkey->ameth == NULL)) {
+        /* Having it NULL is what RSA does so that's a good default. */
+        return V_ASN1_NULL;
+    }
+
+    if (pkey->ameth->pkey_flags & ASN1_PKEY_SIGPARAM_NULL) {
+        return V_ASN1_NULL;
+    }
+
+    return V_ASN1_UNDEF;
+}
+
 int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1,
                    X509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *asn,
                    EVP_PKEY *pkey, const EVP_MD *type)
@@ -243,7 +257,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it,
     type = EVP_MD_CTX_md(ctx);
     pkey = EVP_PKEY_CTX_get0_pkey(ctx->pctx);
 
-    if (!type || !pkey) {
+    if (!pkey) {
         ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_CONTEXT_NOT_INITIALISED);
         return 0;
     }
diff --git a/openssl-1.0.2r/crypto/asn1/asn1.h b/openssl-1.0.2r/crypto/asn1/asn1.h
index 36e79d5e..6b93b0e2 100644
--- a/openssl-1.0.2r/crypto/asn1/asn1.h
+++ b/openssl-1.0.2r/crypto/asn1/asn1.h
@@ -1256,6 +1256,7 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_F_D2I_ASN1_UINTEGER                         150
 # define ASN1_F_D2I_ASN1_UTCTIME                          151
 # define ASN1_F_D2I_AUTOPRIVATEKEY                        207
+# define ASN1_F_D2I_KEMINFO                               227
 # define ASN1_F_D2I_NETSCAPE_RSA                          152
 # define ASN1_F_D2I_NETSCAPE_RSA_2                        153
 # define ASN1_F_D2I_PRIVATEKEY                            154
@@ -1271,13 +1272,26 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_F_I2D_ASN1_OBJECT                           222
 # define ASN1_F_I2D_ASN1_SET                              188
 # define ASN1_F_I2D_ASN1_TIME                             160
+# define ASN1_F_I2D_DILITHIUM_PUBKEY                      233
 # define ASN1_F_I2D_DSA_PUBKEY                            161
 # define ASN1_F_I2D_EC_PUBKEY                             181
+# define ASN1_F_I2D_FRODODH_PUBKEY                        224
+# define ASN1_F_I2D_HSS_PUBKEY                            234
+# define ASN1_F_I2D_KEMINFO                               228
 # define ASN1_F_I2D_PRIVATEKEY                            163
 # define ASN1_F_I2D_PUBLICKEY                             164
+# define ASN1_F_I2D_RAINBOW_PUBKEY                        235
 # define ASN1_F_I2D_RSA_NET                               162
 # define ASN1_F_I2D_RSA_PUBKEY                            165
+# define ASN1_F_I2D_SPHINCS_PUBKEY                        232
+# define ASN1_F_I2D_XMSSMT_PUBKEY                         226
+# define ASN1_F_I2D_XMSS_PUBKEY                           225
+# define ASN1_F_I2O_PUBLICKEY                             229
 # define ASN1_F_LONG_C2I                                  166
+# define ASN1_F_O2I_PUBLICKEY                             230
+# define ASN1_F_OCTET2RAW                                 231
+# define ASN1_F_I2O_KEMINFO                               236
+# define ASN1_F_O2I_KEMINFO                               237
 # define ASN1_F_OID_MODULE_INIT                           174
 # define ASN1_F_PARSE_TAGGING                             182
 # define ASN1_F_PKCS5_PBE2_SET_IV                         167
@@ -1380,6 +1394,7 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_R_NO_MULTIPART_BOUNDARY                     211
 # define ASN1_R_NO_SIG_CONTENT_TYPE                       212
 # define ASN1_R_NULL_IS_WRONG_LENGTH                      144
+# define ASN1_R_NULL_POINTER                              221
 # define ASN1_R_OBJECT_NOT_ASCII_FORMAT                   191
 # define ASN1_R_ODD_NUMBER_OF_CHARS                       145
 # define ASN1_R_PRIVATE_KEY_HEADER_MISSING                146
diff --git a/openssl-1.0.2r/crypto/asn1/asn1_err.c b/openssl-1.0.2r/crypto/asn1/asn1_err.c
index 9e273dcf..c3386e6d 100644
--- a/openssl-1.0.2r/crypto/asn1/asn1_err.c
+++ b/openssl-1.0.2r/crypto/asn1/asn1_err.c
@@ -1,6 +1,6 @@
 /* crypto/asn1/asn1_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2018 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2019 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -157,6 +157,8 @@ static ERR_STRING_DATA ASN1_str_functs[] = {
     {ERR_FUNC(ASN1_F_D2I_ASN1_UINTEGER), "d2i_ASN1_UINTEGER"},
     {ERR_FUNC(ASN1_F_D2I_ASN1_UTCTIME), "D2I_ASN1_UTCTIME"},
     {ERR_FUNC(ASN1_F_D2I_AUTOPRIVATEKEY), "d2i_AutoPrivateKey"},
+    {ERR_FUNC(ASN1_F_D2I_KEMINFO), "d2i_KemInfo"},
+    {ERR_FUNC(ASN1_F_O2I_KEMINFO), "o2i_KemInfo"},
     {ERR_FUNC(ASN1_F_D2I_NETSCAPE_RSA), "d2i_Netscape_RSA"},
     {ERR_FUNC(ASN1_F_D2I_NETSCAPE_RSA_2), "D2I_NETSCAPE_RSA_2"},
     {ERR_FUNC(ASN1_F_D2I_PRIVATEKEY), "d2i_PrivateKey"},
@@ -172,13 +174,25 @@ static ERR_STRING_DATA ASN1_str_functs[] = {
     {ERR_FUNC(ASN1_F_I2D_ASN1_OBJECT), "i2d_ASN1_OBJECT"},
     {ERR_FUNC(ASN1_F_I2D_ASN1_SET), "i2d_ASN1_SET"},
     {ERR_FUNC(ASN1_F_I2D_ASN1_TIME), "I2D_ASN1_TIME"},
+    {ERR_FUNC(ASN1_F_I2D_DILITHIUM_PUBKEY), "i2d_DILITHIUM_PUBKEY"},
     {ERR_FUNC(ASN1_F_I2D_DSA_PUBKEY), "i2d_DSA_PUBKEY"},
     {ERR_FUNC(ASN1_F_I2D_EC_PUBKEY), "i2d_EC_PUBKEY"},
+    {ERR_FUNC(ASN1_F_I2D_FRODODH_PUBKEY), "I2D_FRODODH_PUBKEY"},
+    {ERR_FUNC(ASN1_F_I2D_HSS_PUBKEY), "i2d_HSS_PUBKEY"},
+    {ERR_FUNC(ASN1_F_I2D_KEMINFO), "i2d_KemInfo"},
     {ERR_FUNC(ASN1_F_I2D_PRIVATEKEY), "i2d_PrivateKey"},
     {ERR_FUNC(ASN1_F_I2D_PUBLICKEY), "i2d_PublicKey"},
+    {ERR_FUNC(ASN1_F_I2D_RAINBOW_PUBKEY), "i2d_RAINBOW_PUBKEY"},
     {ERR_FUNC(ASN1_F_I2D_RSA_NET), "i2d_RSA_NET"},
     {ERR_FUNC(ASN1_F_I2D_RSA_PUBKEY), "i2d_RSA_PUBKEY"},
+    {ERR_FUNC(ASN1_F_I2D_SPHINCS_PUBKEY), "i2d_SPHINCS_PUBKEY"},
+    {ERR_FUNC(ASN1_F_I2D_XMSSMT_PUBKEY), "i2d_XMSSMT_PUBKEY"},
+    {ERR_FUNC(ASN1_F_I2D_XMSS_PUBKEY), "i2d_XMSS_PUBKEY"},
+    {ERR_FUNC(ASN1_F_I2O_PUBLICKEY), "i2o_PublicKey"},
+    {ERR_FUNC(ASN1_F_I2O_KEMINFO), "i2o_KemInfo"},
     {ERR_FUNC(ASN1_F_LONG_C2I), "LONG_C2I"},
+    {ERR_FUNC(ASN1_F_O2I_PUBLICKEY), "o2i_PublicKey"},
+    {ERR_FUNC(ASN1_F_OCTET2RAW), "OCTET2RAW"},
     {ERR_FUNC(ASN1_F_OID_MODULE_INIT), "OID_MODULE_INIT"},
     {ERR_FUNC(ASN1_F_PARSE_TAGGING), "PARSE_TAGGING"},
     {ERR_FUNC(ASN1_F_PKCS5_PBE2_SET_IV), "PKCS5_pbe2_set_iv"},
@@ -294,6 +308,7 @@ static ERR_STRING_DATA ASN1_str_reasons[] = {
     {ERR_REASON(ASN1_R_NO_MULTIPART_BOUNDARY), "no multipart boundary"},
     {ERR_REASON(ASN1_R_NO_SIG_CONTENT_TYPE), "no sig content type"},
     {ERR_REASON(ASN1_R_NULL_IS_WRONG_LENGTH), "null is wrong length"},
+    {ERR_REASON(ASN1_R_NULL_POINTER), "null pointer"},
     {ERR_REASON(ASN1_R_OBJECT_NOT_ASCII_FORMAT), "object not ascii format"},
     {ERR_REASON(ASN1_R_ODD_NUMBER_OF_CHARS), "odd number of chars"},
     {ERR_REASON(ASN1_R_PRIVATE_KEY_HEADER_MISSING),
diff --git a/openssl-1.0.2r/crypto/asn1/asn_mime.c b/openssl-1.0.2r/crypto/asn1/asn_mime.c
index 02b7c9b7..f17bc0e2 100644
--- a/openssl-1.0.2r/crypto/asn1/asn_mime.c
+++ b/openssl-1.0.2r/crypto/asn1/asn_mime.c
@@ -419,7 +419,8 @@ static int asn1_output_data(BIO *out, BIO *data, ASN1_VALUE *val, int flags,
 
 ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
 {
-    BIO *asnin;
+    BIO *asnin = NULL;
+    BIO *asnin_chain = NULL;
     STACK_OF(MIME_HEADER) *headers = NULL;
     STACK_OF(BIO) *parts = NULL;
     MIME_HEADER *hdr;
@@ -460,8 +461,8 @@ ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
         }
 
         /* Parse the signature piece */
-        asnin = sk_BIO_value(parts, 1);
-
+        asnin_chain = sk_BIO_value(parts, 1);
+        asnin = BIO_find_type(asnin_chain, BIO_TYPE_MEM);
         if (!(headers = mime_parse_hdr(asnin))) {
             ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_MIME_SIG_PARSE_ERROR);
             sk_BIO_pop_free(parts, BIO_vfree);
@@ -495,7 +496,7 @@ ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
 
         if (bcont) {
             *bcont = sk_BIO_value(parts, 0);
-            BIO_free(asnin);
+            BIO_free_all(asnin_chain);
             sk_BIO_free(parts);
         } else
             sk_BIO_pop_free(parts, BIO_vfree);
@@ -590,7 +591,8 @@ int SMIME_text(BIO *in, BIO *out)
 
 /*
  * Split a multipart/XXX message body into component parts: result is
- * canonical parts in a STACK of bios
+ * canonical parts in a STACK of bios. Each BIO is a store and a memory.
+ * Add a store BIO in case we want to do raw verification.
  */
 
 static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret)
@@ -599,6 +601,7 @@ static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret)
     int len, blen;
     int eol = 0, next_eol = 0;
     BIO *bpart = NULL;
+    BIO *btmp = NULL;
     STACK_OF(BIO) *parts;
     char state, part, first;
 
@@ -623,10 +626,17 @@ static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret)
                 first = 0;
                 if (bpart)
                     sk_BIO_push(parts, bpart);
-                bpart = BIO_new(BIO_s_mem());
-                if (bpart == NULL)
+                bpart = BIO_new(BIO_f_store());
+                btmp = BIO_new(BIO_s_mem());
+                if ((bpart == NULL) || (btmp == NULL)) {
+                    BIO_free(bpart);
+                    BIO_free(btmp);
                     return 1;
+                }
+                BIO_set_mem_eof_return(btmp, 0);
                 BIO_set_mem_eof_return(bpart, 0);
+                BIO_push(bpart, btmp);
+                btmp = NULL;
             } else if (eol)
                 BIO_write(bpart, "\r\n", 2);
             eol = next_eol;
diff --git a/openssl-1.0.2r/crypto/asn1/d2i_pu.c b/openssl-1.0.2r/crypto/asn1/d2i_pu.c
index 33542dd1..fccb174d 100644
--- a/openssl-1.0.2r/crypto/asn1/d2i_pu.c
+++ b/openssl-1.0.2r/crypto/asn1/d2i_pu.c
@@ -71,6 +71,235 @@
 #ifndef OPENSSL_NO_EC
 # include <openssl/ec.h>
 #endif
+#ifndef OPENSSL_NO_CMC
+# include <openssl/cmc.h>
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+#ifndef OPENSSL_NO_FRODODH
+# include <openssl/frododh.h>
+#endif
+#ifndef OPENSSL_NO_FRODOKEM
+# include <openssl/frodokem.h>
+#endif
+#ifndef OPENSSL_NO_HSS
+# include <openssl/hss.h>
+#endif
+#ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+#endif
+#ifndef OPENSSL_NO_NHDH
+# include <openssl/nhdh.h>
+#endif
+#ifndef OPENSSL_NO_NTRUP
+# include <openssl/ntrup.h>
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+# include <openssl/rainbow.h>
+#endif
+#ifndef OPENSSL_NO_SAMWISE
+# include <openssl/samwise.h>
+#endif
+#ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+#endif
+#ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+# include <openssl/sphincs.h>
+#endif
+#ifndef OPENSSL_NO_XMSS
+# include <openssl/xmss.h>
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+# include <openssl/xmssmt.h>
+#endif
+
+/* Note that this function does NOT transfer ownership of the buffer to the
+ * returned EVP_PKEY. The user must still free the memory pointed to by p.
+ * Note that this will only work for quantum-safe key exchanges.
+ */
+EVP_PKEY *o2i_PublicKey(int type, EVP_PKEY **a, const unsigned char *p,
+                        long length)
+{
+    EVP_PKEY *ret;
+
+    if (p == NULL) {
+        ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_ASN1_LIB);
+        return (NULL);
+    }
+
+    if ((a == NULL) || (*a == NULL)) {
+        if ((ret = EVP_PKEY_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+            return (NULL);
+        }
+    } else
+        ret = *a;
+
+    if (!EVP_PKEY_set_type(ret, type)) {
+        ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    switch (EVP_PKEY_id(ret)) {
+#ifndef OPENSSL_NO_FRODODH
+    case EVP_PKEY_FRODODH:
+        if ((ret->pkey.frododh = FRODODH_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+            goto err;
+        }
+        ret->pkey.frododh->my_public_key = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.frododh->my_public_key, p, length)) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        ret->pkey.frododh->nid = type;
+        break;
+#endif
+#ifndef OPENSSL_NO_NHDH
+    case EVP_PKEY_NHDH:
+        if ((ret->pkey.nhdh = NHDH_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+            goto err;
+        }
+        ret->pkey.nhdh->my_public_key = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.nhdh->my_public_key, p, length)) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        ret->pkey.nhdh->nid = type;
+        break;
+#endif
+#ifndef OPENSSL_NO_SAMWISE
+    case EVP_PKEY_SAMWISE:
+        if ((ret->pkey.samwise = SAMWISE_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+            goto err;
+        }
+        ret->pkey.samwise->my_public_key = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.samwise->my_public_key, p, length)) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        ret->pkey.samwise->nid = type;
+        break;
+#endif
+#ifndef OPENSSL_NO_SIDH
+    case EVP_PKEY_SIDH:
+        if ((ret->pkey.sidh = SIDH_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+            goto err;
+        }
+        ret->pkey.sidh->my_public_key = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.sidh->my_public_key, p, length)) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        if ((ret->pkey.sike = SIKE_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+            goto err;
+        }
+        ret->pkey.sike->pub_key = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.sike->pub_key, p, length)) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        if ((ret->pkey.kyber = KYBER_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_EVP_LIB);
+            goto err;
+        }
+        ret->pkey.kyber->pub_key = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.kyber->pub_key, p, length)) {
+            ASN1err(ASN1_F_O2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+    default:
+        ASN1err(ASN1_F_O2I_PUBLICKEY, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
+        goto err;
+    }
+
+    if (a != NULL)
+        (*a) = ret;
+    return (ret);
+ err:
+    if ((ret != NULL) && ((a == NULL) || (*a != ret)))
+        EVP_PKEY_free(ret);
+    return NULL;
+}
+
+EVP_PKEY *o2i_KemInfo(int type, EVP_PKEY **a, const unsigned char *p,
+                        long length)
+{
+    EVP_PKEY *ret;
+
+    if ((a == NULL) || (*a == NULL)) {
+        if ((ret = EVP_PKEY_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_KEMINFO, ERR_R_EVP_LIB);
+            return (NULL);
+        }
+    } else
+        ret = *a;
+
+    if (!EVP_PKEY_set_type(ret, type)) {
+        ASN1err(ASN1_F_O2I_KEMINFO, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    switch (EVP_PKEY_id(ret)) {
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        if ((ret->pkey.sike = SIKE_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_KEMINFO, ERR_R_EVP_LIB);
+            goto err;
+        }
+
+        ret->pkey.sike->kem_info = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.sike->kem_info, p, length)) {
+            ASN1err(ASN1_F_O2I_KEMINFO, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        if ((ret->pkey.kyber = KYBER_new()) == NULL) {
+            ASN1err(ASN1_F_O2I_KEMINFO, ERR_R_EVP_LIB);
+            goto err;
+        }
+
+        ret->pkey.kyber->kem_info = ASN1_OCTET_STRING_new();
+        if (!ASN1_OCTET_STRING_set(ret->pkey.kyber->kem_info, p, length)) {
+            ASN1err(ASN1_F_O2I_KEMINFO, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+    default:
+        ASN1err(ASN1_F_O2I_KEMINFO, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
+        goto err;
+    }
+
+    if (a != NULL)
+        (*a) = ret;
+    return (ret);
+ err:
+    if ((ret != NULL) && ((a == NULL) || (*a != ret)))
+        EVP_PKEY_free(ret);
+    return NULL;
+}
 
 EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
                         long length)
@@ -120,6 +349,156 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
             goto err;
         }
         break;
+#endif
+#ifndef OPENSSL_NO_CMC
+    case EVP_PKEY_CMC:
+        if ((ret->pkey.cmc = d2i_CMCPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+    case EVP_PKEY_DILITHIUM:
+        if ((ret->pkey.dilithium = d2i_DILITHIUMPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_FRODODH
+    case EVP_PKEY_FRODODH:
+        if ((ret->pkey.frododh = d2i_FRODODHPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_FRODOKEM
+    case EVP_PKEY_FRODOKEM:
+        if ((ret->pkey.frodokem = d2i_FRODOKEMPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_HSS
+    case EVP_PKEY_HSS:
+        if ((ret->pkey.hss = d2i_HSSPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        if ((ret->pkey.kyber = d2i_KYBERPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_NHDH
+    case EVP_PKEY_NHDH:
+        if ((ret->pkey.nhdh = d2i_NHDHPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_NTRUP
+    case EVP_PKEY_NTRUP:
+        if ((ret->pkey.ntrup = d2i_NTRUPPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+    case EVP_PKEY_RAINBOW:
+        if ((ret->pkey.rainbow = d2i_RAINBOWPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_SAMWISE
+    case EVP_PKEY_SAMWISE:
+        if ((ret->pkey.samwise = d2i_SAMWISEPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_SIDH
+    case EVP_PKEY_SIDH:
+        if ((ret->pkey.sidh = d2i_SIDHPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        if ((ret->pkey.sike = d2i_SIKEPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+    case EVP_PKEY_SPHINCS:
+        if ((ret->pkey.sphincs = d2i_SPHINCSPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_XMSS
+    case EVP_PKEY_XMSS:
+        if ((ret->pkey.xmss = d2i_XMSSPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+    case EVP_PKEY_XMSSMT:
+        if ((ret->pkey.xmssmt = d2i_XMSSMTPublicKey(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
 #endif
     default:
         ASN1err(ASN1_F_D2I_PUBLICKEY, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
@@ -134,3 +513,84 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
         EVP_PKEY_free(ret);
     return (NULL);
 }
+
+EVP_PKEY *d2i_KemInfo(int type, EVP_PKEY **a, const unsigned char **pp, long length) {
+    EVP_PKEY *ret;
+
+    if ((a == NULL) || (*a == NULL)) {
+        if ((ret = EVP_PKEY_new()) == NULL) {
+            ASN1err(ASN1_F_D2I_KEMINFO, ERR_R_EVP_LIB);
+            return (NULL);
+        }
+    } else
+        ret = *a;
+
+    if (!EVP_PKEY_set_type(ret, type)) {
+        ASN1err(ASN1_F_D2I_KEMINFO, ERR_R_EVP_LIB);
+        goto err;
+    }
+
+    switch (EVP_PKEY_id(ret)) {
+#ifndef OPENSSL_NO_CMC
+    case EVP_PKEY_CMC:
+        if ((ret->pkey.cmc = d2i_CMCKemInfo(NULL,
+                                            (const unsigned char **)pp,
+                                            length)) == NULL) {
+            ASN1err(ASN1_F_D2I_KEMINFO, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_FRODOKEM
+    case EVP_PKEY_FRODOKEM:
+        if ((ret->pkey.frodokem = d2i_FRODOKEMKemInfo(NULL,
+                                                      (const unsigned char **)pp,
+                                                      length)) == NULL) {
+            ASN1err(ASN1_F_D2I_KEMINFO, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        if ((ret->pkey.kyber = d2i_KYBERKemInfo(NULL,
+                                                (const unsigned char **)pp,
+                                                length)) == NULL) {
+            ASN1err(ASN1_F_D2I_KEMINFO, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_NTRUP
+    case EVP_PKEY_NTRUP:
+        if ((ret->pkey.ntrup = d2i_NTRUPKemInfo(NULL,
+                                               (const unsigned char **)pp,
+                                               length)) == NULL) {
+            ASN1err(ASN1_F_D2I_KEMINFO, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        if ((ret->pkey.sike = d2i_SIKEKemInfo(NULL,
+                                              (const unsigned char **)pp,
+                                              length)) == NULL) {
+            ASN1err(ASN1_F_D2I_KEMINFO, ERR_R_ASN1_LIB);
+            goto err;
+        }
+        break;
+#endif
+    default:
+        ASN1err(ASN1_F_D2I_KEMINFO, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
+        goto err;
+        /* break; */
+    }
+    if (a != NULL)
+        (*a) = ret;
+    return (ret);
+ err:
+    if ((ret != NULL) && ((a == NULL) || (*a != ret)))
+        EVP_PKEY_free(ret);
+    return (NULL);
+}
diff --git a/openssl-1.0.2r/crypto/asn1/i2d_pu.c b/openssl-1.0.2r/crypto/asn1/i2d_pu.c
index b8ed3554..d9b03d90 100644
--- a/openssl-1.0.2r/crypto/asn1/i2d_pu.c
+++ b/openssl-1.0.2r/crypto/asn1/i2d_pu.c
@@ -70,6 +70,135 @@
 #ifndef OPENSSL_NO_EC
 # include <openssl/ec.h>
 #endif
+#ifndef OPENSSL_NO_CMC
+# include <openssl/cmc.h>
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+#ifndef OPENSSL_NO_FRODODH
+# include <openssl/frododh.h>
+#endif
+#ifndef OPENSSL_NO_FRODOKEM
+# include <openssl/frodokem.h>
+#endif
+#ifndef OPENSSL_NO_HSS
+# include <openssl/hss.h>
+#endif
+#ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+#endif
+#ifndef OPENSSL_NO_NHDH
+# include <openssl/nhdh.h>
+#endif
+#ifndef OPENSSL_NO_NTRUP
+# include <openssl/ntrup.h>
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+# include <openssl/rainbow.h>
+#endif
+#ifndef OPENSSL_NO_SAMWISE
+# include <openssl/samwise.h>
+#endif
+#ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+#endif
+#ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+# include <openssl/sphincs.h>
+#endif
+#ifndef OPENSSL_NO_XMSS
+# include <openssl/xmss.h>
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+# include <openssl/xmssmt.h>
+#endif
+
+static int octet2raw(ASN1_OCTET_STRING *s, unsigned char **pp)
+{
+    unsigned char *retbuf = OPENSSL_malloc(s->length);
+
+    if (s == NULL) {
+        ASN1err(ASN1_F_OCTET2RAW, ASN1_R_NULL_POINTER);
+        return -1;
+    }
+
+    if (retbuf == NULL) {
+        ASN1err(ASN1_F_OCTET2RAW, ERR_R_MALLOC_FAILURE);
+        return -1;
+    }
+
+    memcpy(retbuf, s->data, s->length);
+    *pp = retbuf;
+    return s->length;
+}
+
+/* Note that this function gives ownership of the returned buffer pointed to by
+ * *pp. The user must still free the memory pointed to by *pp. Note that this
+ * will only work for Quantum-Safe key exchanges.
+ */
+int i2o_PublicKey(EVP_PKEY *a, unsigned char **pp)
+{
+    if ((a == NULL) || (pp == NULL)) {
+        ASN1err(ASN1_F_I2O_PUBLICKEY, ASN1_R_NULL_POINTER);
+        return (-1);
+    }
+
+    switch (a->type) {
+#ifndef OPENSSL_NO_FRODODH
+    case EVP_PKEY_FRODODH:
+        return octet2raw(a->pkey.frododh->my_public_key, pp);
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        return octet2raw(a->pkey.kyber->pub_key, pp);
+#endif
+#ifndef OPENSSL_NO_NHDH
+    case EVP_PKEY_NHDH:
+        return octet2raw(a->pkey.nhdh->my_public_key, pp);
+#endif
+#ifndef OPENSSL_NO_SAMWISE
+    case EVP_PKEY_SAMWISE:
+        return octet2raw(a->pkey.samwise->my_public_key, pp);
+#endif
+#ifndef OPENSSL_NO_SIDH
+    case EVP_PKEY_SIDH:
+        return octet2raw(a->pkey.sidh->my_public_key, pp);
+#endif
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        return octet2raw(a->pkey.sike->pub_key, pp);
+#endif
+    default:
+        ASN1err(ASN1_F_I2O_PUBLICKEY, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
+        return (-1);
+    }
+    return (-1);
+}
+
+int i2o_KemInfo(EVP_PKEY *a, unsigned char **pp)
+{
+    if ((a == NULL) || (pp == NULL)) {
+        ASN1err(ASN1_F_I2O_KEMINFO, ASN1_R_NULL_POINTER);
+        return (-1);
+    }
+
+    switch (a->type) {
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        return (octet2raw(a->pkey.sike->kem_info, pp));
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        return (octet2raw(a->pkey.kyber->kem_info, pp));
+#endif
+    default:
+        ASN1err(ASN1_F_I2O_KEMINFO, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
+        return (-1);
+    }
+}
 
 int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp)
 {
@@ -85,9 +214,99 @@ int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp)
 #ifndef OPENSSL_NO_EC
     case EVP_PKEY_EC:
         return (i2o_ECPublicKey(a->pkey.ec, pp));
+#endif
+#ifndef OPENSSL_NO_CMC
+    case EVP_PKEY_CMC:
+        return (i2d_CMCPublicKey(a->pkey.cmc, pp));
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+    case EVP_PKEY_DILITHIUM:
+        return (i2d_DILITHIUMPublicKey(a->pkey.dilithium, pp));
+#endif
+#ifndef OPENSSL_NO_FRODODH
+    case EVP_PKEY_FRODODH:
+        return (i2d_FRODODHPublicKey(a->pkey.frododh, pp));
+#endif
+#ifndef OPENSSL_NO_FRODOKEM
+    case EVP_PKEY_FRODOKEM:
+        return (i2d_FRODOKEMPublicKey(a->pkey.frodokem, pp));
+#endif
+#ifndef OPENSSL_NO_HSS
+    case EVP_PKEY_HSS:
+        return (i2d_HSSPublicKey(a->pkey.hss, pp));
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        return (i2d_KYBERPublicKey(a->pkey.kyber, pp));
+#endif
+#ifndef OPENSSL_NO_NHDH
+    case EVP_PKEY_NHDH:
+        return (i2d_NHDHPublicKey(a->pkey.nhdh, pp));
+#endif
+#ifndef OPENSSL_NO_NTRUP
+    case EVP_PKEY_NTRUP:
+        return (i2d_NTRUPPublicKey(a->pkey.ntrup, pp));
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+    case EVP_PKEY_RAINBOW:
+        return (i2d_RAINBOWPublicKey(a->pkey.rainbow, pp));
+#endif
+#ifndef OPENSSL_NO_SAMWISE
+    case EVP_PKEY_SAMWISE:
+        return (i2d_SAMWISEPublicKey(a->pkey.samwise, pp));
+#endif
+#ifndef OPENSSL_NO_SIDH
+    case EVP_PKEY_SIDH:
+        return (i2d_SIDHPublicKey(a->pkey.sidh, pp));
+#endif
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        return (i2d_SIKEPublicKey(a->pkey.sike, pp));
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+    case EVP_PKEY_SPHINCS:
+        return (i2d_SPHINCSPublicKey(a->pkey.sphincs, pp));
+#endif
+#ifndef OPENSSL_NO_XMSS
+    case EVP_PKEY_XMSS:
+        return (i2d_XMSSPublicKey(a->pkey.xmss, pp));
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+    case EVP_PKEY_XMSSMT:
+        return (i2d_XMSSMTPublicKey(a->pkey.xmssmt, pp));
 #endif
     default:
         ASN1err(ASN1_F_I2D_PUBLICKEY, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
         return (-1);
     }
 }
+
+int i2d_KemInfo(EVP_PKEY *a, unsigned char **pp) {
+    switch (a->type) {
+#ifndef OPENSSL_NO_CMC
+    case EVP_PKEY_CMC:
+        return (i2d_CMCKemInfo(a->pkey.cmc, pp));
+#endif
+#ifndef OPENSSL_NO_FRODOKEM
+    case EVP_PKEY_FRODOKEM:
+        return (i2d_FRODOKEMKemInfo(a->pkey.frodokem, pp));
+#endif
+#ifndef OPENSSL_NO_KYBER
+    case EVP_PKEY_KYBER:
+        return (i2d_KYBERKemInfo(a->pkey.kyber, pp));
+#endif
+#ifndef OPENSSL_NO_NTRUP
+    case EVP_PKEY_NTRUP:
+        return (i2d_NTRUPKemInfo(a->pkey.ntrup, pp));
+#endif
+#ifndef OPENSSL_NO_SIKE
+    case EVP_PKEY_SIKE:
+        return (i2d_SIKEKemInfo(a->pkey.sike, pp));
+#endif
+    default:
+        ASN1err(ASN1_F_I2D_KEMINFO, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
+        return (-1);
+    }
+
+    return 1;
+}
diff --git a/openssl-1.0.2r/crypto/asn1/p5_pbev2.c b/openssl-1.0.2r/crypto/asn1/p5_pbev2.c
index 4c037d3d..d0df0efb 100644
--- a/openssl-1.0.2r/crypto/asn1/p5_pbev2.c
+++ b/openssl-1.0.2r/crypto/asn1/p5_pbev2.c
@@ -212,17 +212,19 @@ X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,
     kdf->salt->value.octet_string = osalt;
     kdf->salt->type = V_ASN1_OCTET_STRING;
 
-    if (!saltlen)
-        saltlen = PKCS5_SALT_LEN;
-    if (!(osalt->data = OPENSSL_malloc(saltlen)))
-        goto merr;
+    if(saltlen >= 0) {
+        if (!saltlen)
+            saltlen = PKCS5_SALT_LEN;
+        if (!(osalt->data = OPENSSL_malloc(saltlen)))
+            goto merr;
 
-    osalt->length = saltlen;
+        osalt->length = saltlen;
 
-    if (salt)
-        memcpy(osalt->data, salt, saltlen);
-    else if (RAND_bytes(osalt->data, saltlen) <= 0)
-        goto merr;
+        if (salt)
+            memcpy(osalt->data, salt, saltlen);
+        else if (RAND_bytes(osalt->data, saltlen) <= 0)
+            goto merr;
+    }
 
     if (iter <= 0)
         iter = PKCS5_DEFAULT_ITER;
diff --git a/openssl-1.0.2r/crypto/asn1/x_pubkey.c b/openssl-1.0.2r/crypto/asn1/x_pubkey.c
index 6c57a797..e70e717e 100644
--- a/openssl-1.0.2r/crypto/asn1/x_pubkey.c
+++ b/openssl-1.0.2r/crypto/asn1/x_pubkey.c
@@ -301,6 +301,246 @@ int i2d_DSA_PUBKEY(DSA *a, unsigned char **pp)
 }
 #endif
 
+#ifndef OPENSSL_NO_HSS
+HSS *d2i_HSS_PUBKEY(HSS **a, const unsigned char **pp, long length)
+{
+    EVP_PKEY *pkey;
+    HSS *key;
+    const unsigned char *q;
+    q = *pp;
+    pkey = d2i_PUBKEY(NULL, &q, length);
+    if (!pkey)
+        return NULL;
+    key = EVP_PKEY_get1_HSS(pkey);
+    EVP_PKEY_free(pkey);
+    if (!key)
+        return NULL;
+    *pp = q;
+    if (a) {
+        HSS_free(*a);
+        *a = key;
+    }
+    return key;
+}
+
+int i2d_HSS_PUBKEY(HSS *a, unsigned char **pp)
+{
+    EVP_PKEY *pktmp;
+    int ret;
+    if (!a)
+        return 0;
+    pktmp = EVP_PKEY_new();
+    if (!pktmp) {
+        ASN1err(ASN1_F_I2D_HSS_PUBKEY, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    EVP_PKEY_set1_HSS(pktmp, a);
+    ret = i2d_PUBKEY(pktmp, pp);
+    EVP_PKEY_free(pktmp);
+    return ret;
+}
+#endif
+
+#ifndef OPENSSL_NO_XMSS
+XMSS *d2i_XMSS_PUBKEY(XMSS **a, const unsigned char **pp, long length)
+{
+    EVP_PKEY *pkey;
+    XMSS *key;
+    const unsigned char *q;
+    q = *pp;
+    pkey = d2i_PUBKEY(NULL, &q, length);
+    if (!pkey)
+        return NULL;
+    key = EVP_PKEY_get1_XMSS(pkey);
+    EVP_PKEY_free(pkey);
+    if (!key)
+        return NULL;
+    *pp = q;
+    if (a) {
+        XMSS_free(*a);
+        *a = key;
+    }
+    return key;
+}
+
+int i2d_XMSS_PUBKEY(XMSS *a, unsigned char **pp)
+{
+    EVP_PKEY *pktmp;
+    int ret;
+    if (!a)
+        return 0;
+    pktmp = EVP_PKEY_new();
+    if (!pktmp) {
+        ASN1err(ASN1_F_I2D_XMSS_PUBKEY, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    EVP_PKEY_set1_XMSS(pktmp, a);
+    ret = i2d_PUBKEY(pktmp, pp);
+    EVP_PKEY_free(pktmp);
+    return ret;
+}
+#endif
+
+#ifndef OPENSSL_NO_XMSSMT
+XMSSMT *d2i_XMSSMT_PUBKEY(XMSSMT **a, const unsigned char **pp, long length)
+{
+    EVP_PKEY *pkey;
+    XMSSMT *key;
+    const unsigned char *q;
+    q = *pp;
+    pkey = d2i_PUBKEY(NULL, &q, length);
+    if (!pkey)
+        return NULL;
+    key = EVP_PKEY_get1_XMSSMT(pkey);
+    EVP_PKEY_free(pkey);
+    if (!key)
+        return NULL;
+    *pp = q;
+    if (a) {
+        XMSSMT_free(*a);
+        *a = key;
+    }
+    return key;
+}
+
+int i2d_XMSSMT_PUBKEY(XMSSMT *a, unsigned char **pp)
+{
+    EVP_PKEY *pktmp;
+    int ret;
+    if (!a)
+        return 0;
+    pktmp = EVP_PKEY_new();
+    if (!pktmp) {
+        ASN1err(ASN1_F_I2D_XMSSMT_PUBKEY, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    EVP_PKEY_set1_XMSSMT(pktmp, a);
+    ret = i2d_PUBKEY(pktmp, pp);
+    EVP_PKEY_free(pktmp);
+    return ret;
+}
+#endif
+
+#ifndef OPENSSL_NO_DILITHIUM
+DILITHIUM *d2i_DILITHIUM_PUBKEY(DILITHIUM **a, const unsigned char **pp, long length)
+{
+    EVP_PKEY *pkey;
+    DILITHIUM *key;
+    const unsigned char *q;
+    q = *pp;
+    pkey = d2i_PUBKEY(NULL, &q, length);
+    if (!pkey) 
+        return NULL;
+    key = EVP_PKEY_get1_DILITHIUM(pkey);
+    EVP_PKEY_free(pkey);
+    if (!key)
+        return NULL;
+    *pp = q;
+    if (a) {
+        DILITHIUM_free(*a);
+        *a = key;
+    }
+    return key;
+}
+
+int i2d_DILITHIUM_PUBKEY(DILITHIUM *a, unsigned char **pp)
+{
+    EVP_PKEY *pktmp;
+    int ret;
+    if (!a)
+        return 0;
+    pktmp = EVP_PKEY_new();
+    if (!pktmp) {
+        ASN1err(ASN1_F_I2D_DILITHIUM_PUBKEY, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    EVP_PKEY_set1_DILITHIUM(pktmp, a);
+    ret = i2d_PUBKEY(pktmp, pp);
+    EVP_PKEY_free(pktmp);
+    return ret;
+}
+#endif
+
+#ifndef OPENSSL_NO_SPHINCS
+SPHINCS *d2i_SPHINCS_PUBKEY(SPHINCS **a, const unsigned char **pp, long length)
+{
+    EVP_PKEY *pkey;
+    SPHINCS *key;
+    const unsigned char *q;
+    q = *pp;
+    pkey = d2i_PUBKEY(NULL, &q, length);
+    if (!pkey)
+        return NULL;
+    key = EVP_PKEY_get1_SPHINCS(pkey);
+    EVP_PKEY_free(pkey);
+    if (!key)
+        return NULL;
+    *pp = q;
+    if (a) {
+        SPHINCS_free(*a);
+        *a = key;
+    }
+    return key;
+}
+
+int i2d_SPHINCS_PUBKEY(SPHINCS *a, unsigned char **pp)
+{
+    EVP_PKEY *pktmp;
+    int ret;
+    if (!a)
+        return 0;
+    pktmp = EVP_PKEY_new();
+    if (!pktmp) {
+        ASN1err(ASN1_F_I2D_SPHINCS_PUBKEY, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    EVP_PKEY_set1_SPHINCS(pktmp, a);
+    ret = i2d_PUBKEY(pktmp, pp);
+    EVP_PKEY_free(pktmp);
+    return ret;
+}
+#endif
+
+#ifndef OPENSSL_NO_RAINBOW
+RAINBOW *d2i_RAINBOW_PUBKEY(RAINBOW **a, const unsigned char **pp, long length)
+{
+    EVP_PKEY *pkey;
+    RAINBOW *key;
+    const unsigned char *q;
+    q = *pp;
+    pkey = d2i_PUBKEY(NULL, &q, length);
+    if (!pkey)
+        return NULL;
+    key = EVP_PKEY_get1_RAINBOW(pkey);
+    EVP_PKEY_free(pkey);
+    if (!key)
+        return NULL;
+    *pp = q;
+    if (a) {
+        RAINBOW_free(*a);
+        *a = key;
+    }
+    return key;
+}
+
+int i2d_RAINBOW_PUBKEY(RAINBOW *a, unsigned char **pp)
+{
+    EVP_PKEY *pktmp;
+    int ret;
+    if (!a)
+        return 0;
+    pktmp = EVP_PKEY_new();
+    if (!pktmp) {
+        ASN1err(ASN1_F_I2D_RAINBOW_PUBKEY, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    EVP_PKEY_set1_RAINBOW(pktmp, a);
+    ret = i2d_PUBKEY(pktmp, pp);
+    EVP_PKEY_free(pktmp);
+    return ret;
+}
+#endif
+
 #ifndef OPENSSL_NO_EC
 EC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length)
 {
diff --git a/openssl-1.0.2r/crypto/asn1/x_x509.c b/openssl-1.0.2r/crypto/asn1/x_x509.c
index aada4a84..8431971d 100644
--- a/openssl-1.0.2r/crypto/asn1/x_x509.c
+++ b/openssl-1.0.2r/crypto/asn1/x_x509.c
@@ -77,6 +77,22 @@ ASN1_SEQUENCE_enc(X509_CINF, enc, 0) = {
 } ASN1_SEQUENCE_END_enc(X509_CINF, X509_CINF)
 
 IMPLEMENT_ASN1_FUNCTIONS(X509_CINF)
+
+/* Note that this is the same as above except no signature field. */
+ASN1_SEQUENCE_enc(X509_PCINF, enc, 0) = {
+        ASN1_EXP_OPT(X509_PCINF, version, ASN1_INTEGER, 0),
+        ASN1_SIMPLE(X509_PCINF, serialNumber, ASN1_INTEGER),
+        ASN1_SIMPLE(X509_PCINF, issuer, X509_NAME),
+        ASN1_SIMPLE(X509_PCINF, validity, X509_VAL),
+        ASN1_SIMPLE(X509_PCINF, subject, X509_NAME),
+        ASN1_SIMPLE(X509_PCINF, key, X509_PUBKEY),
+        ASN1_IMP_OPT(X509_PCINF, issuerUID, ASN1_BIT_STRING, 1),
+        ASN1_IMP_OPT(X509_PCINF, subjectUID, ASN1_BIT_STRING, 2),
+        ASN1_EXP_SEQUENCE_OF_OPT(X509_PCINF, extensions, X509_EXTENSION, 3)
+} ASN1_SEQUENCE_END_enc(X509_PCINF, X509_PCINF)
+
+IMPLEMENT_ASN1_FUNCTIONS(X509_PCINF)
+
 /* X509 top level structure needs a bit of customisation */
 
 extern void policy_cache_free(X509_POLICY_CACHE *cache);
diff --git a/openssl-1.0.2r/crypto/bio/Makefile b/openssl-1.0.2r/crypto/bio/Makefile
index ef526f6b..ac758119 100644
--- a/openssl-1.0.2r/crypto/bio/Makefile
+++ b/openssl-1.0.2r/crypto/bio/Makefile
@@ -22,14 +22,14 @@ LIBSRC= bio_lib.c bio_cb.c bio_err.c \
 	bss_file.c bss_sock.c bss_conn.c \
 	bf_null.c bf_buff.c b_print.c b_dump.c \
 	b_sock.c bss_acpt.c bf_nbio.c bss_log.c bss_bio.c \
-	bss_dgram.c
+	bss_dgram.c bf_store.c
 #	bf_lbuf.c
 LIBOBJ= bio_lib.o bio_cb.o bio_err.o \
 	bss_mem.o bss_null.o bss_fd.o \
 	bss_file.o bss_sock.o bss_conn.o \
 	bf_null.o bf_buff.o b_print.o b_dump.o \
 	b_sock.o bss_acpt.o bf_nbio.o bss_log.o bss_bio.o \
-	bss_dgram.o
+	bss_dgram.o bf_store.o
 #	bf_lbuf.o
 
 SRC= $(LIBSRC)
diff --git a/openssl-1.0.2r/crypto/bio/bf_store.c b/openssl-1.0.2r/crypto/bio/bf_store.c
new file mode 100644
index 00000000..d8b39995
--- /dev/null
+++ b/openssl-1.0.2r/crypto/bio/bf_store.c
@@ -0,0 +1,198 @@
+/* crypto/bio/bf_store.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include "cryptlib.h"
+#include <openssl/bio.h>
+
+static int store_write(BIO *h, const char *buf, int num);
+static int store_read(BIO *h, char *buf, int size);
+static int store_puts(BIO *h, const char *str);
+static int store_gets(BIO *h, char *str, int size);
+static long store_ctrl(BIO *h, int cmd, long arg1, void *arg2);
+static int store_new(BIO *h);
+static int store_free(BIO *data);
+static BIO_METHOD store_method = {
+    BIO_TYPE_STORE,
+    "storage buffer",
+    store_write,
+    store_read,
+    store_puts,
+    store_gets,
+    store_ctrl,
+    store_new,
+    store_free,
+    NULL,
+};
+
+BIO_METHOD *BIO_f_store(void)
+{
+    return (&store_method);
+}
+
+static int store_new(BIO *bi)
+{
+    BUF_MEM *b;
+
+    if ((b = BUF_MEM_new()) == NULL)
+        return (0);
+    bi->shutdown = 1;
+    bi->init = 1;
+    bi->num = -1;
+    bi->ptr = (char *)b;
+    return (1);
+}
+
+static int store_free(BIO *a)
+{
+    if (a == NULL)
+        return (0);
+    if (a->shutdown) {
+        if ((a->init) && (a->ptr != NULL)) {
+            BUF_MEM *b = (BUF_MEM *)a->ptr;
+            BUF_MEM_free(b);
+            a->ptr = NULL;
+        }
+    }
+    return (1);
+}
+
+static int store_write(BIO *b, const char *in, int inl)
+{
+    int ret = -1;
+    int blen;
+    BUF_MEM *bm = (BUF_MEM *)b->ptr;
+
+    if ((in == NULL) || (inl <= 0))
+        return (0);
+    if (b->next_bio == NULL)
+        return (0);
+
+    ret = BIO_write(b->next_bio, in, inl);
+    BIO_clear_retry_flags(b);
+    BIO_copy_next_retry(b);
+    if (ret <= 0)
+        return ret;
+
+    blen = bm->length;
+    if (BUF_MEM_grow_clean(bm, blen + inl) != (blen + inl))
+        return -1;
+    memcpy(&(bm->data[blen]), in, inl);
+    return inl;
+}
+
+static int store_read(BIO *b, char *out, int outl)
+{
+    int ret = -1;
+    int blen;
+    BUF_MEM *bm = (BUF_MEM *)b->ptr;
+
+    if ((out == NULL) || (outl <= 0))
+        return (0);
+    if (b->next_bio == NULL)
+        return (0);
+
+    ret = BIO_read(b->next_bio, out, outl);
+    BIO_clear_retry_flags(b);
+    BIO_copy_next_retry(b);
+    if (ret <= 0)
+        return ret;
+
+    blen = bm->length;
+    if (BUF_MEM_grow_clean(bm, blen + ret) != (blen + ret))
+        return -1;
+    memcpy(&(bm->data[blen]), out, ret);
+    return ret;
+}
+
+static int store_puts(BIO *bp, const char *str)
+{
+    int n, ret;
+
+    n = strlen(str);
+    ret = store_write(bp, str, n);
+    return (ret);
+}
+
+static int store_gets(BIO *bp, char *buf, int size)
+{
+    return store_read(bp, buf, size);
+}
+
+static long store_ctrl(BIO *b, int cmd, long num, void *ptr)
+{
+    long ret = 0;
+    char **pptr;
+
+    BUF_MEM *bm = (BUF_MEM *)b->ptr;
+
+    switch (cmd) {
+    case BIO_CTRL_INFO:
+        ret = (long)bm->length;
+        if (ptr != NULL) {
+            pptr = (char **)ptr;
+            *pptr = (char *)&(bm->data[0]);
+        }
+        break;
+    default:
+        ret = BIO_ctrl(b->next_bio, cmd, num, ptr);
+        break;
+    }
+    return (ret);
+}
diff --git a/openssl-1.0.2r/crypto/bio/bio.h b/openssl-1.0.2r/crypto/bio/bio.h
index 8f2438cd..9bc97f52 100644
--- a/openssl-1.0.2r/crypto/bio/bio.h
+++ b/openssl-1.0.2r/crypto/bio/bio.h
@@ -108,6 +108,7 @@ extern "C" {
 # endif
 # define BIO_TYPE_ASN1           (22|0x0200)/* filter */
 # define BIO_TYPE_COMP           (23|0x0200)/* filter */
+# define BIO_TYPE_STORE          (25|0x0200)/* filter */
 
 # define BIO_TYPE_DESCRIPTOR     0x0100/* socket, fd, connect or accept */
 # define BIO_TYPE_FILTER         0x0200
@@ -574,6 +575,9 @@ int BIO_read_filename(BIO *b, const char *name);
 # define BIO_set_mem_eof_return(b,v) \
                                 BIO_ctrl(b,BIO_C_SET_BUF_MEM_EOF_RETURN,v,NULL)
 
+/* For the BIO_f_store() type */
+# define BIO_get_store_data(b,pp)   BIO_ctrl(b,BIO_CTRL_INFO,0,(char *)pp)
+
 /* For the BIO_f_buffer() type */
 # define BIO_get_buffer_num_lines(b)     BIO_ctrl(b,BIO_C_GET_BUFF_NUM_LINES,0,NULL)
 # define BIO_set_buffer_size(b,size)     BIO_ctrl(b,BIO_C_SET_BUFF_SIZE,size,NULL)
@@ -701,6 +705,7 @@ BIO_METHOD *BIO_s_bio(void);
 BIO_METHOD *BIO_s_null(void);
 BIO_METHOD *BIO_f_null(void);
 BIO_METHOD *BIO_f_buffer(void);
+BIO_METHOD *BIO_f_store(void);
 # ifdef OPENSSL_SYS_VMS
 BIO_METHOD *BIO_f_linebuffer(void);
 # endif
diff --git a/openssl-1.0.2r/crypto/cmc/Makefile b/openssl-1.0.2r/crypto/cmc/Makefile
new file mode 100644
index 00000000..32d86936
--- /dev/null
+++ b/openssl-1.0.2r/crypto/cmc/Makefile
@@ -0,0 +1,103 @@
+#
+# OpenSSL/crypto/cmc/Makefile
+#
+
+DIR=	cmc
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= cmc_lib.c cmc_asn1.c cmc_err.c
+LIBOBJ= cmc_lib.o cmc_asn1.o cmc_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= cmc.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+cmc_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+cmc_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+cmc_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+cmc_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+cmc_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/cmc.h
+cmc_asn1.o: ../../include/openssl/opensslconf.h
+cmc_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cmc_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+cmc_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+cmc_asn1.o: ../cryptlib.h cmc_asn1.c
+cmc_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+cmc_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+cmc_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+cmc_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+cmc_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+cmc_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+cmc_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+cmc_lib.o: ../../include/openssl/cmc.h ../../include/openssl/obj_mac.h
+cmc_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+cmc_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cmc_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+cmc_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+cmc_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+cmc_lib.o: ../../include/openssl/x509_vfy.h ../cryptlib.h cmc_lib.c
diff --git a/openssl-1.0.2r/crypto/cmc/cmc.h b/openssl-1.0.2r/crypto/cmc/cmc.h
new file mode 100644
index 00000000..05c3ca2e
--- /dev/null
+++ b/openssl-1.0.2r/crypto/cmc/cmc.h
@@ -0,0 +1,167 @@
+/* crypto/cmc/cmc.h loosly based off of crypto/rsa/rsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, CMC,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_CMC_H
+# define HEADER_CMC_H
+
+# include <openssl/asn1.h>
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+# ifdef OPENSSL_NO_CMC
+#  error CMC is disabled.
+# endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_CMC_PARAMETER_SET  (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string    "parameter_set"
+
+#define CMC_6960119_R2 1
+#define CMC_8192128_R2 2
+
+/* Declared already in ossl_typ.h */
+/* typedef struct cmc_st CMC; */
+
+struct cmc_st {
+    /*
+     * The first parameter is used to pickup errors where this is passed
+     * instead of an EVP_PKEY, it is set to 0
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    ENGINE *engine;
+
+    /* CMC parameter.  Please see the spec. */
+    long parameter_set;
+
+    ASN1_OCTET_STRING *pub_key;                 /* public key */
+    ASN1_OCTET_STRING *priv_key;                /* private key */
+    ASN1_OCTET_STRING *kem_info;                /* KEM public info */
+    ASN1_OCTET_STRING *kem_shared_key;          /* KEM shared secret key */
+
+
+    /* not sure if we need this, keep it for now */
+    CRYPTO_EX_DATA ex_data;
+    int references;
+    int flags;
+};
+
+/* memory management methods for the CMC struct */
+CMC *CMC_new(void);
+CMC *CMC_new_with_engine(ENGINE *engine);
+void CMC_free(CMC *r);
+int CMC_up_ref(CMC *r);
+
+/* We will will need ASN1 because we will need the keys for encryption and
+ * decryption.  
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(CMC, CMCPublicKey)
+ */
+CMC *d2i_CMCPublicKey(CMC **a, const unsigned char **pp, long length);
+int i2d_CMCPublicKey(const CMC *a, unsigned char **pp);
+
+/* ASN.1 for public kem info
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(CMC, CMCKemInfo)
+ */
+CMC *d2i_CMCKemInfo(CMC **a, const unsigned char **pp, long length);
+int i2d_CMCKemInfo(const CMC *a, unsigned char **pp);
+
+
+/* ASN.1 for private key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(CMC, CMCPrivateKey)
+ */
+CMC *d2i_CMCPrivateKey(CMC **a, const unsigned char **pp, long length);
+int i2d_CMCPrivateKey(const CMC *a, unsigned char **pp);
+
+/* not sure if we need this, keep for now. */
+int CMC_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
+int CMC_set_ex_data(CMC *r, int idx, void *arg);
+void *CMC_get_ex_data(CMC *r, int idx);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_CMC_strings(void);
+
+/* Error codes for the CMC functions. */
+
+/* Function codes. */
+# define CMC_F_CMC_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define CMC_R_ENGINE_INIT_FAILURE                        100
+# define CMC_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/cmc/cmc_asn1.c b/openssl-1.0.2r/crypto/cmc/cmc_asn1.c
new file mode 100644
index 00000000..70623b0b
--- /dev/null
+++ b/openssl-1.0.2r/crypto/cmc/cmc_asn1.c
@@ -0,0 +1,125 @@
+/* cmc_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/cmc.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int cmc_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)CMC_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        CMC_free((CMC *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(CMCPrivateKey, cmc_cb) = {
+        ASN1_SIMPLE(CMC, version, LONG),
+        ASN1_SIMPLE(CMC, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(CMC, pub_key, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END_cb(CMC, CMCPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(CMC, CMCPrivateKey, CMCPrivateKey)
+
+CMC *d2i_CMCPublicKey(CMC **a, const unsigned char **pp, long length) {
+    CMC *cmc = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    cmc = CMC_new();
+    if (cmc == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        CMC_free(cmc);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            CMC_free(*a);
+        *a = cmc;
+    }
+
+    cmc->pub_key = pub_key;
+    return cmc;
+}
+
+int i2d_CMCPublicKey(const CMC *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
+
+
+ASN1_SEQUENCE_cb(CMCKemInfo, cmc_cb) = {
+        ASN1_SIMPLE(CMC, kem_info, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(CMC, CMCKemInfo)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(CMC, CMCKemInfo, CMCKemInfo)
diff --git a/openssl-1.0.2r/crypto/cmc/cmc_err.c b/openssl-1.0.2r/crypto/cmc/cmc_err.c
new file mode 100644
index 00000000..891ef3d5
--- /dev/null
+++ b/openssl-1.0.2r/crypto/cmc/cmc_err.c
@@ -0,0 +1,94 @@
+/* crypto/cmc/cmc_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/cmc.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_CMC,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_CMC,0,reason)
+
+static ERR_STRING_DATA CMC_str_functs[] = {
+    {ERR_FUNC(CMC_F_CMC_NEW_WITH_ENGINE), "CMC_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA CMC_str_reasons[] = {
+    {ERR_REASON(CMC_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(CMC_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_CMC_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(CMC_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, CMC_str_functs);
+        ERR_load_strings(0, CMC_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/cmc/cmc_lib.c b/openssl-1.0.2r/crypto/cmc/cmc_lib.c
new file mode 100644
index 00000000..35bb9b98
--- /dev/null
+++ b/openssl-1.0.2r/crypto/cmc/cmc_lib.c
@@ -0,0 +1,194 @@
+/* crypto/cmc/cmc_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/cmc.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char CMC_version[] = "CMC" OPENSSL_VERSION_PTEXT;
+
+CMC *CMC_new(void)
+{
+    return CMC_new_with_engine(NULL);
+}
+
+CMC *CMC_new_with_engine(ENGINE *engine)
+{
+    CMC *ret;
+
+    ret = (CMC *)OPENSSL_malloc(sizeof(CMC));
+    if (ret == NULL) {
+        CMCerr(CMC_F_CMC_NEW_WITH_ENGINE, CMC_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            CMCerr(CMC_F_CMC_NEW_WITH_ENGINE, CMC_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->references = 1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->kem_shared_key = NULL;
+    ret->kem_info = NULL;
+    ret->parameter_set = -1;
+
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_CMC, ret, &ret->ex_data);
+    return (ret);
+}
+
+void CMC_free(CMC *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_CMC);
+#ifdef REF_PRINT
+    REF_PRINT("CMC", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "CMC_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_CMC, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->kem_info != NULL)
+        ASN1_OCTET_STRING_free(r->kem_info);
+    if (r->kem_shared_key != NULL) {
+        OPENSSL_cleanse(r->kem_shared_key->data, (size_t)r->kem_shared_key->length);
+        ASN1_OCTET_STRING_free(r->kem_shared_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int CMC_up_ref(CMC *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_CMC);
+#ifdef REF_PRINT
+    REF_PRINT("CMC", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "CMC_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int CMC_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_CMC, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int CMC_set_ex_data(CMC *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *CMC_get_ex_data(CMC *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/cms/cms.h b/openssl-1.0.2r/crypto/cms/cms.h
index e6c7f964..f31407ad 100644
--- a/openssl-1.0.2r/crypto/cms/cms.h
+++ b/openssl-1.0.2r/crypto/cms/cms.h
@@ -263,6 +263,7 @@ int CMS_SignedData_init(CMS_ContentInfo *cms);
 CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
                                 X509 *signer, EVP_PKEY *pk, const EVP_MD *md,
                                 unsigned int flags);
+int CMS_SignerInfo_set1_altpriv(CMS_SignerInfo *si, EVP_PKEY *altpriv);
 EVP_PKEY_CTX *CMS_SignerInfo_get0_pkey_ctx(CMS_SignerInfo *si);
 EVP_MD_CTX *CMS_SignerInfo_get0_md_ctx(CMS_SignerInfo *si);
 STACK_OF(CMS_SignerInfo) *CMS_get0_SignerInfos(CMS_ContentInfo *cms);
@@ -279,7 +280,9 @@ void CMS_SignerInfo_get0_algs(CMS_SignerInfo *si, EVP_PKEY **pk,
                               X509_ALGOR **psig);
 ASN1_OCTET_STRING *CMS_SignerInfo_get0_signature(CMS_SignerInfo *si);
 int CMS_SignerInfo_sign(CMS_SignerInfo *si);
+int CMS_SignerInfo_altsign(CMS_SignerInfo *si, unsigned char *cont, long contlen);
 int CMS_SignerInfo_verify(CMS_SignerInfo *si);
+int CMS_SignerInfo_altverify(CMS_SignerInfo *si, BIO *bio_cont);
 int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain);
 
 int CMS_add_smimecap(CMS_SignerInfo *si, STACK_OF(X509_ALGOR) *algs);
@@ -378,6 +381,7 @@ int CMS_SharedInfo_encode(unsigned char **pder, X509_ALGOR *kekalg,
  * The following lines are auto generated by the script mkerr.pl. Any changes
  * made after this point may be overwritten when the script is next run.
  */
+
 void ERR_load_CMS_strings(void);
 
 /* Error codes for the CMS functions. */
@@ -451,9 +455,12 @@ void ERR_load_CMS_strings(void);
 # define CMS_F_CMS_SET1_IAS                               176
 # define CMS_F_CMS_SET1_KEYID                             177
 # define CMS_F_CMS_SET1_SIGNERIDENTIFIER                  146
+# define CMS_F_CMS_SET_ALTSIGNER                          183
 # define CMS_F_CMS_SET_DETACHED                           147
 # define CMS_F_CMS_SIGN                                   148
 # define CMS_F_CMS_SIGNED_DATA_INIT                       149
+# define CMS_F_CMS_SIGNERINFO_ALTSIGN                     184
+# define CMS_F_CMS_SIGNERINFO_ALTVERIFY                   185
 # define CMS_F_CMS_SIGNERINFO_CONTENT_SIGN                150
 # define CMS_F_CMS_SIGNERINFO_SIGN                        151
 # define CMS_F_CMS_SIGNERINFO_VERIFY                      152
@@ -468,6 +475,7 @@ void ERR_load_CMS_strings(void);
 # define CMS_R_ADD_SIGNER_ERROR                           99
 # define CMS_R_CERTIFICATE_ALREADY_PRESENT                175
 # define CMS_R_CERTIFICATE_HAS_NO_KEYID                   160
+# define CMS_R_CERTIFICATE_MISMATCH                       183
 # define CMS_R_CERTIFICATE_VERIFY_ERROR                   100
 # define CMS_R_CIPHER_INITIALISATION_ERROR                101
 # define CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR      102
@@ -534,6 +542,8 @@ void ERR_load_CMS_strings(void);
 # define CMS_R_TYPE_NOT_ENCRYPTED_DATA                    145
 # define CMS_R_TYPE_NOT_ENVELOPED_DATA                    146
 # define CMS_R_UNABLE_TO_FINALIZE_CONTEXT                 147
+# define CMS_R_UNEXPECTED_NON_NULL_PARAMETER              184
+# define CMS_R_UNEXPECTED_NULL_PARAMETER                  185
 # define CMS_R_UNKNOWN_CIPHER                             148
 # define CMS_R_UNKNOWN_DIGEST_ALGORIHM                    149
 # define CMS_R_UNKNOWN_ID                                 150
@@ -549,7 +559,7 @@ void ERR_load_CMS_strings(void);
 # define CMS_R_VERIFICATION_FAILURE                       158
 # define CMS_R_WRAP_ERROR                                 159
 
-#ifdef  __cplusplus
+# ifdef  __cplusplus
 }
-#endif
+# endif
 #endif
diff --git a/openssl-1.0.2r/crypto/cms/cms_err.c b/openssl-1.0.2r/crypto/cms/cms_err.c
index 15572ea3..9f0921ec 100644
--- a/openssl-1.0.2r/crypto/cms/cms_err.c
+++ b/openssl-1.0.2r/crypto/cms/cms_err.c
@@ -166,9 +166,12 @@ static ERR_STRING_DATA CMS_str_functs[] = {
     {ERR_FUNC(CMS_F_CMS_SET1_IAS), "cms_set1_ias"},
     {ERR_FUNC(CMS_F_CMS_SET1_KEYID), "cms_set1_keyid"},
     {ERR_FUNC(CMS_F_CMS_SET1_SIGNERIDENTIFIER), "cms_set1_SignerIdentifier"},
+    {ERR_FUNC(CMS_F_CMS_SET_ALTSIGNER), "CMS_SET_ALTSIGNER"},
     {ERR_FUNC(CMS_F_CMS_SET_DETACHED), "CMS_set_detached"},
     {ERR_FUNC(CMS_F_CMS_SIGN), "CMS_sign"},
     {ERR_FUNC(CMS_F_CMS_SIGNED_DATA_INIT), "CMS_SIGNED_DATA_INIT"},
+    {ERR_FUNC(CMS_F_CMS_SIGNERINFO_ALTSIGN), "CMS_SignerInfo_altsign"},
+    {ERR_FUNC(CMS_F_CMS_SIGNERINFO_ALTVERIFY), "CMS_SignerInfo_altverify"},
     {ERR_FUNC(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN),
      "CMS_SIGNERINFO_CONTENT_SIGN"},
     {ERR_FUNC(CMS_F_CMS_SIGNERINFO_SIGN), "CMS_SignerInfo_sign"},
@@ -189,6 +192,7 @@ static ERR_STRING_DATA CMS_str_reasons[] = {
     {ERR_REASON(CMS_R_CERTIFICATE_ALREADY_PRESENT),
      "certificate already present"},
     {ERR_REASON(CMS_R_CERTIFICATE_HAS_NO_KEYID), "certificate has no keyid"},
+    {ERR_REASON(CMS_R_CERTIFICATE_MISMATCH), "certificate mismatch"},
     {ERR_REASON(CMS_R_CERTIFICATE_VERIFY_ERROR), "certificate verify error"},
     {ERR_REASON(CMS_R_CIPHER_INITIALISATION_ERROR),
      "cipher initialisation error"},
@@ -273,6 +277,10 @@ static ERR_STRING_DATA CMS_str_reasons[] = {
     {ERR_REASON(CMS_R_TYPE_NOT_ENVELOPED_DATA), "type not enveloped data"},
     {ERR_REASON(CMS_R_UNABLE_TO_FINALIZE_CONTEXT),
      "unable to finalize context"},
+    {ERR_REASON(CMS_R_UNEXPECTED_NON_NULL_PARAMETER),
+     "unexpected non null parameter"},
+    {ERR_REASON(CMS_R_UNEXPECTED_NULL_PARAMETER),
+     "unexpected null parameter"},
     {ERR_REASON(CMS_R_UNKNOWN_CIPHER), "unknown cipher"},
     {ERR_REASON(CMS_R_UNKNOWN_DIGEST_ALGORIHM), "unknown digest algorihm"},
     {ERR_REASON(CMS_R_UNKNOWN_ID), "unknown id"},
diff --git a/openssl-1.0.2r/crypto/cms/cms_lcl.h b/openssl-1.0.2r/crypto/cms/cms_lcl.h
index 20f2c25f..df40bb29 100644
--- a/openssl-1.0.2r/crypto/cms/cms_lcl.h
+++ b/openssl-1.0.2r/crypto/cms/cms_lcl.h
@@ -139,6 +139,7 @@ struct CMS_SignerInfo_st {
     /* Digest and public key context for alternative parameters */
     EVP_MD_CTX mctx;
     EVP_PKEY_CTX *pctx;
+    EVP_PKEY *altpriv;
 };
 
 struct CMS_SignerIdentifier_st {
diff --git a/openssl-1.0.2r/crypto/cms/cms_sd.c b/openssl-1.0.2r/crypto/cms/cms_sd.c
index a41aca8e..ae33d6df 100644
--- a/openssl-1.0.2r/crypto/cms/cms_sd.c
+++ b/openssl-1.0.2r/crypto/cms/cms_sd.c
@@ -66,6 +66,167 @@
 
 DECLARE_ASN1_ITEM(CMS_SignedData)
 
+static X509_ATTRIBUTE *create_ALTSIG_ATTRIBUTE(ASN1_OCTET_STRING *altsig) {
+    X509_ATTRIBUTE *attr = NULL;
+
+    attr = X509_ATTRIBUTE_create(NID_cmsAltSignatureValue, V_ASN1_OCTET_STRING, altsig);
+    if (attr == NULL) {
+        fprintf(stderr, "Failed to create the ALTSIG attribute.\n");
+        goto end;
+    }
+
+end:
+    return attr;
+}
+
+static X509_ATTRIBUTE *create_ALTSIGALG_ATTRIBUTE(X509_ALGOR *altsigalg) {
+    X509_ATTRIBUTE *attr = NULL;
+    unsigned char *p = NULL;
+    unsigned char *data = NULL;
+    ASN1_STRING *astr = NULL;
+    int i = 0;
+
+    i = i2d_X509_ALGOR(altsigalg, NULL);
+    if (i < 0) {
+        fprintf(stderr, "Failed to get ASN.1 size of ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+    data = OPENSSL_malloc(i);
+    if (data == NULL) {
+        fprintf(stderr, "Memory failure during ALTSIGALG attribute creation.\n");
+        goto end;
+    }
+
+    p=data;
+    i = i2d_X509_ALGOR(altsigalg, &p);
+    if (i < 0) {
+        fprintf(stderr, "Failed to ASN.1 encode the ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+    astr = ASN1_STRING_new();
+    if (!ASN1_STRING_set(astr, data, i)) {
+        fprintf(stderr, "Failed to alloc/set string for ALTSIGALG attribute.\n");
+        ASN1_STRING_free(astr);
+        goto end;
+    }
+
+    attr = X509_ATTRIBUTE_create(NID_cmsAltSignatureAlgorithm, V_ASN1_SEQUENCE, astr);
+    if (attr == NULL) {
+        ASN1_STRING_free(astr);
+        fprintf(stderr, "Failed to create the ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+end:
+    OPENSSL_free(data);
+    return attr;
+}
+
+static EVP_PKEY *get_pubkey_from_SAPKI(SUBJECT_ALT_PUBLIC_KEY_INFO *sapki) {
+    X509_PUBKEY *x509_pub_qs = NULL;
+    EVP_PKEY *qs_pub_key = NULL;
+
+    /* Convert the x509 formatted public key into a pkey */
+    x509_pub_qs = X509_PUBKEY_new();
+    if (x509_pub_qs == NULL) {
+        fprintf(stderr, "Memory allocation error.\n");
+        goto end;
+    }
+    X509_ALGOR_free(x509_pub_qs->algor);
+    ASN1_BIT_STRING_free(x509_pub_qs->public_key);
+
+    x509_pub_qs->algor = sapki->algor;
+    x509_pub_qs->public_key = sapki->public_key;
+    x509_pub_qs->pkey = NULL;
+
+    qs_pub_key = X509_PUBKEY_get(x509_pub_qs);
+
+    x509_pub_qs->algor = NULL;
+    x509_pub_qs->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_qs);
+    x509_pub_qs = NULL;
+
+    if (qs_pub_key == NULL) {
+        fprintf(stderr, "Error converting ALT public key into a PKEY.\n");
+        goto end;
+    }
+
+end:
+
+    return qs_pub_key;
+}
+
+static EVP_PKEY *get_SAPKI_from_x509(X509 *cert) {
+    int qs_pub_key_ind = -1;
+    X509_EXTENSION *qs_pub_key_ext = NULL;
+    EVP_PKEY *pk = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+
+    /* Find the issuer's ALT public key extension. */
+    qs_pub_key_ind = X509_get_ext_by_NID(cert, NID_subjectAltPublicKeyInfo, -1);
+    if (qs_pub_key_ind < 0) {
+        goto end;
+    }
+
+    qs_pub_key_ext = X509_get_ext(cert, qs_pub_key_ind);
+    if (qs_pub_key_ext == NULL) {
+        goto end;
+    }
+
+    sapki = X509V3_EXT_d2i(qs_pub_key_ext);
+    if (sapki == NULL) {
+        goto end;
+    }
+
+    pk = get_pubkey_from_SAPKI(sapki);
+    if (pk == NULL) {
+        goto end;
+    }
+
+end:
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+
+    return pk;
+}
+
+static ASN1_OCTET_STRING *get_ALTSIG_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_cmsAltSignatureValue);
+    ASN1_OCTET_STRING *altsig = NULL;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_OCTET_STRING)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    altsig = X509_ATTRIBUTE_get0_data(attr, 0, V_ASN1_OCTET_STRING, NULL);
+    if (altsig == NULL) {
+        fprintf (stderr, "Couldn't get ASN1 data from attribute.\n") ;
+        goto err;
+    }
+
+    return altsig;
+
+err:
+    return NULL;
+}
+
 static CMS_SignedData *cms_get0_signed(CMS_ContentInfo *cms)
 {
     if (OBJ_obj2nid(cms->contentType) != NID_pkcs7_signed) {
@@ -307,12 +468,22 @@ CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
 
     if (md == NULL) {
         int def_nid;
-        if (EVP_PKEY_get_default_digest_nid(pk, &def_nid) <= 0)
+        if (EVP_PKEY_get_default_digest_nid(pk, &def_nid) <= 0) {
+            CMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DEFAULT_DIGEST);
             goto err;
+        }
         md = EVP_get_digestbynid(def_nid);
         if (md == NULL) {
-            CMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DEFAULT_DIGEST);
-            goto err;
+            /* Now lets try the cms specific message digest */
+            if (EVP_PKEY_get_cms_digest_nid(pk, &def_nid) <= 0) {
+                CMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DEFAULT_DIGEST);
+                goto err;
+            }
+            md = EVP_get_digestbynid(def_nid);
+            if (md == NULL) {
+                CMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DEFAULT_DIGEST);
+                goto err;
+            }
         }
     }
 
@@ -410,6 +581,15 @@ CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
 
 }
 
+int CMS_SignerInfo_set1_altpriv(CMS_SignerInfo *si, EVP_PKEY *altpriv) {
+    if (si == NULL)
+        return 0;
+    if (altpriv == NULL)
+        return 0;
+    si->altpriv = altpriv;
+    return 1;
+}
+
 static int cms_add1_signingTime(CMS_SignerInfo *si, ASN1_TIME *t)
 {
     ASN1_TIME *tt;
@@ -573,12 +753,56 @@ ASN1_OCTET_STRING *CMS_SignerInfo_get0_signature(CMS_SignerInfo *si)
     return si->signature;
 }
 
+static int cms_SignerInfo_rawsign(EVP_PKEY *pkey, unsigned char *abuf, int alen, unsigned char **sig, size_t *siglen) {
+    int ret = 0;
+    *sig = NULL;
+    *siglen = 0;
+
+    EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey, NULL);
+    if (pctx == NULL) {
+        goto end;
+    }
+
+    if (EVP_PKEY_sign_init(pctx) <= 0) {
+        goto end;
+    }
+
+    if (EVP_PKEY_sign(pctx, NULL, siglen, abuf, alen) <= 0) {
+        goto end;
+    }
+
+    *sig = OPENSSL_malloc(*siglen);
+    if (*sig == NULL) {
+        goto end;
+    }
+
+    if (EVP_PKEY_sign(pctx, *sig, siglen, abuf, alen) <= 0) {
+        goto end;
+    }
+
+    ret = 1;
+
+end:
+    EVP_PKEY_CTX_free(pctx);
+
+    if ((ret == 0 ) && (*sig != NULL)) {
+        OPENSSL_free(*sig);
+        *sig = NULL;
+    }
+
+    return ret;
+}
+
 static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,
                                        CMS_SignerInfo *si, BIO *chain)
 {
     EVP_MD_CTX mctx;
     int r = 0;
     EVP_PKEY_CTX *pctx = NULL;
+    int default_digest_nid = 0;
+    unsigned char *cont = NULL;
+    long contlen = 0;
+
     EVP_MD_CTX_init(&mctx);
 
     if (!si->pkey) {
@@ -586,63 +810,102 @@ static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,
         return 0;
     }
 
-    if (!cms_DigestAlgorithm_find_ctx(&mctx, chain, si->digestAlgorithm))
+    chain = BIO_find_type(chain, BIO_TYPE_STORE);
+    if (chain == NULL)
         goto err;
-    /* Set SignerInfo algortihm details if we used custom parametsr */
-    if (si->pctx && !cms_sd_asn1_ctrl(si, 0))
+
+    contlen = BIO_get_store_data(chain, &cont);
+    if (contlen <= 0)
         goto err;
 
-    /*
-     * If any signed attributes calculate and add messageDigest attribute
-     */
+    if ((CMS_signed_get_attr_count(si) < 0)
+        && (EVP_PKEY_get_default_digest_nid(si->pkey, &default_digest_nid) > 0)
+        && (default_digest_nid == NID_undef)) {
+        /* There are no signed attributes and the pkey wants to do raw signing,
+         * so do it against the content. The chain should have a store BIO.
+         * Find it and sign the content of that BIO.
+         */
+        unsigned char *sig = NULL;
+        size_t siglen = 0;
 
-    if (CMS_signed_get_attr_count(si) >= 0) {
-        ASN1_OBJECT *ctype =
-            cms->d.signedData->encapContentInfo->eContentType;
-        unsigned char md[EVP_MAX_MD_SIZE];
-        unsigned int mdlen;
-        if (!EVP_DigestFinal_ex(&mctx, md, &mdlen))
-            goto err;
-        if (!CMS_signed_add1_attr_by_NID(si, NID_pkcs9_messageDigest,
-                                         V_ASN1_OCTET_STRING, md, mdlen))
-            goto err;
-        /* Copy content type across */
-        if (CMS_signed_add1_attr_by_NID(si, NID_pkcs9_contentType,
-                                        V_ASN1_OBJECT, ctype, -1) <= 0)
-            goto err;
-        if (!CMS_SignerInfo_sign(si))
-            goto err;
-    } else if (si->pctx) {
-        unsigned char *sig;
-        size_t siglen;
-        unsigned char md[EVP_MAX_MD_SIZE];
-        unsigned int mdlen;
-        pctx = si->pctx;
-        if (!EVP_DigestFinal_ex(&mctx, md, &mdlen))
-            goto err;
-        siglen = EVP_PKEY_size(si->pkey);
-        sig = OPENSSL_malloc(siglen);
-        if (!sig) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);
-            goto err;
-        }
-        if (EVP_PKEY_sign(pctx, sig, &siglen, md, mdlen) <= 0)
+        if (cms_SignerInfo_rawsign(si->pkey, cont, (size_t)contlen, &sig, &siglen) <= 0)
             goto err;
+
         ASN1_STRING_set0(si->signature, sig, siglen);
+
+        if (si->altpriv != NULL)
+            if (!CMS_SignerInfo_altsign(si, cont, contlen))
+                goto err;
     } else {
-        unsigned char *sig;
-        unsigned int siglen;
-        sig = OPENSSL_malloc(EVP_PKEY_size(si->pkey));
-        if (!sig) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);
+        if (!cms_DigestAlgorithm_find_ctx(&mctx, chain, si->digestAlgorithm))
             goto err;
-        }
-        if (!EVP_SignFinal(&mctx, sig, &siglen, si->pkey)) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_SIGNFINAL_ERROR);
-            OPENSSL_free(sig);
+        /* Set SignerInfo algortihm details if we used custom parametsr */
+        if (si->pctx && !cms_sd_asn1_ctrl(si, 0))
             goto err;
+
+        /*
+         * If any signed attributes calculate and add messageDigest attribute
+         */
+
+        if (CMS_signed_get_attr_count(si) >= 0) {
+            ASN1_OBJECT *ctype =
+                cms->d.signedData->encapContentInfo->eContentType;
+            unsigned char md[EVP_MAX_MD_SIZE];
+            unsigned int mdlen;
+            if (!EVP_DigestFinal_ex(&mctx, md, &mdlen))
+                goto err;
+            if (!CMS_signed_add1_attr_by_NID(si, NID_pkcs9_messageDigest,
+                                             V_ASN1_OCTET_STRING, md, mdlen))
+                goto err;
+            /* Copy content type across */
+            if (CMS_signed_add1_attr_by_NID(si, NID_pkcs9_contentType,
+                                            V_ASN1_OBJECT, ctype, -1) <= 0)
+                goto err;
+            if (!CMS_SignerInfo_sign(si))
+                goto err;
+            if (si->altpriv != NULL)
+                if (!CMS_SignerInfo_altsign(si, NULL, 0))
+                    goto err;
+        } else if (si->pctx) {
+            unsigned char *sig;
+            size_t siglen;
+            unsigned char md[EVP_MAX_MD_SIZE];
+            unsigned int mdlen;
+            pctx = si->pctx;
+            if (!EVP_DigestFinal_ex(&mctx, md, &mdlen))
+                goto err;
+            siglen = EVP_PKEY_size(si->pkey);
+            sig = OPENSSL_malloc(siglen);
+            if (!sig) {
+                CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);
+                goto err;
+            }
+            if (EVP_PKEY_sign(pctx, sig, &siglen, md, mdlen) <= 0)
+                goto err;
+            ASN1_STRING_set0(si->signature, sig, siglen);
+
+            if (si->altpriv != NULL)
+                if (!CMS_SignerInfo_altsign(si, cont, contlen))
+                    goto err;
+        } else {
+            unsigned char *sig;
+            unsigned int siglen;
+            sig = OPENSSL_malloc(EVP_PKEY_size(si->pkey));
+            if (!sig) {
+                CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);
+                goto err;
+            }
+            if (!EVP_SignFinal(&mctx, sig, &siglen, si->pkey)) {
+                CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_SIGNFINAL_ERROR);
+                OPENSSL_free(sig);
+                goto err;
+            }
+            ASN1_STRING_set0(si->signature, sig, siglen);
+
+            if (si->altpriv != NULL)
+                if (!CMS_SignerInfo_altsign(si, cont, contlen))
+                    goto err;
         }
-        ASN1_STRING_set0(si->signature, sig, siglen);
     }
 
     r = 1;
@@ -673,11 +936,13 @@ int cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)
 int CMS_SignerInfo_sign(CMS_SignerInfo *si)
 {
     EVP_MD_CTX *mctx = &si->mctx;
-    EVP_PKEY_CTX *pctx;
+    EVP_PKEY_CTX *pctx = NULL;
     unsigned char *abuf = NULL;
     int alen;
-    size_t siglen;
+    unsigned char *sig = NULL;
+    size_t siglen = 0;
     const EVP_MD *md = NULL;
+    int default_digest_nid = -1;
 
     md = EVP_get_digestbyobj(si->digestAlgorithm->algorithm);
     if (md == NULL)
@@ -688,6 +953,25 @@ int CMS_SignerInfo_sign(CMS_SignerInfo *si)
             goto err;
     }
 
+    alen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,
+                         ASN1_ITEM_rptr(CMS_Attributes_Sign));
+    if (!abuf)
+        goto err;
+
+    /* If EVP_PKEY_get_default_digest_nid() returns NID_UNDEF, then this
+     * algorithm  wants to do raw signing, otherwise hash and sign.
+     *
+     * We couldn't just set si->digestAlgorithm to NULL because we still need
+     * that to indicate which hash algo to use to hash the content.
+     */
+    if ((EVP_PKEY_get_default_digest_nid(si->pkey, &default_digest_nid) > 0)
+        && (default_digest_nid == NID_undef)) {
+        int ret = cms_SignerInfo_rawsign(si->pkey, abuf, alen, &sig, &siglen);
+        ASN1_STRING_set0(si->signature, sig, siglen);
+        OPENSSL_free(abuf);
+        return ret;
+    }
+
     if (si->pctx)
         pctx = si->pctx;
     else {
@@ -702,10 +986,6 @@ int CMS_SignerInfo_sign(CMS_SignerInfo *si)
         goto err;
     }
 
-    alen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,
-                         ASN1_ITEM_rptr(CMS_Attributes_Sign));
-    if (!abuf)
-        goto err;
     if (EVP_DigestSignUpdate(mctx, abuf, alen) <= 0)
         goto err;
     if (EVP_DigestSignFinal(mctx, NULL, &siglen) <= 0)
@@ -737,21 +1017,195 @@ int CMS_SignerInfo_sign(CMS_SignerInfo *si)
 
 }
 
+int CMS_SignerInfo_altsign(CMS_SignerInfo *si, unsigned char *cont, long contlen) {
+    EVP_MD_CTX mctx;
+    EVP_PKEY_CTX *pctx = NULL;
+    unsigned char *abuf = NULL;
+    int alen = 0;
+    unsigned char *sigbuf = NULL;
+    size_t siglen = 0;
+    const EVP_MD *md = NULL;
+    ASN1_OCTET_STRING *sigoct = NULL;
+    X509_ATTRIBUTE *sigalg = NULL;
+    X509_ATTRIBUTE *sigval = NULL;
+    X509_ALGOR *algor = NULL;
+    int signid = 0;
+    int status = 0;
+    int default_digest_nid = -1;
+
+    EVP_MD_CTX_init(&mctx);
+
+    md = EVP_get_digestbyobj(si->digestAlgorithm->algorithm);
+    if (md == NULL)
+        goto err;
+
+    if (cont == NULL) {
+
+        /* If we're not signing content, then we're signing signed attributes.
+         * Add the signing time attribute.
+         */
+        if (CMS_signed_get_attr_by_NID(si, NID_pkcs9_signingTime, -1) < 0) {
+            if (!cms_add1_signingTime(si, NULL))
+                goto err;
+        }
+
+        alen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,
+                             ASN1_ITEM_rptr(CMS_Attributes_Sign));
+        if (!abuf)
+            goto err;
+        cont = abuf;
+        contlen = alen;
+    }
+
+    /* If EVP_PKEY_get_default_digest_nid() returns NID_UNDEF, then this
+     * algorithm  wants to do raw signing, otherwise hash and sign.
+     *
+     * We couldn't just set si->digestAlgorithm to NULL because we still need
+     * that to indicate which hash algo to use to hash the content.
+     */
+    if ((EVP_PKEY_get_default_digest_nid(si->altpriv, &default_digest_nid) > 0)
+        && (default_digest_nid == NID_undef)) {
+        if (cms_SignerInfo_rawsign(si->altpriv, cont, contlen, &sigbuf, &siglen) <= 0) {
+            goto err;
+        }
+
+        /* Since we're doing raw signing... */
+        signid = EVP_PKEY_base_id(si->altpriv);
+    } else {
+        if (EVP_DigestSignInit(&mctx, &pctx, md, NULL, si->altpriv) <= 0)
+            goto err;
+
+        if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
+                              EVP_PKEY_CTRL_CMS_SIGN, 0, si) <= 0) {
+            CMSerr(CMS_F_CMS_SIGNERINFO_ALTSIGN, CMS_R_CTRL_ERROR);
+            goto err;
+        }
+
+        if (EVP_DigestSignUpdate(&mctx, cont, contlen) <= 0)
+            goto err;
+
+        if (EVP_DigestSignFinal(&mctx, NULL, &siglen) <= 0)
+            goto err;
+
+        sigbuf = OPENSSL_malloc(siglen);
+        if (!sigbuf)
+            goto err;
+
+        if (EVP_DigestSignFinal(&mctx, sigbuf, &siglen) <= 0)
+            goto err;
+
+        if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
+                              EVP_PKEY_CTRL_CMS_SIGN, 1, si) <= 0) {
+            CMSerr(CMS_F_CMS_SIGNERINFO_ALTSIGN, CMS_R_CTRL_ERROR);
+            goto err;
+        }
+
+        if (!OBJ_find_sigid_by_algs(&signid, EVP_MD_type(md), EVP_PKEY_base_id(si->altpriv))) {
+            goto err;
+        }
+    }
+
+    algor = X509_ALGOR_new();
+    if (algor == NULL)
+        goto err;
+
+    if (X509_ALGOR_set0(algor, OBJ_nid2obj(signid), V_ASN1_UNDEF, 0) == 0)
+        goto err;
+
+    sigalg = create_ALTSIGALG_ATTRIBUTE(algor);
+    if (sigalg == NULL)
+        goto err;
+
+    sigoct = ASN1_OCTET_STRING_new();
+    if (sigoct == NULL)
+        goto err;
+
+    sigoct->length = siglen;
+    sigoct->data = sigbuf;
+    siglen = 0;
+    sigbuf = NULL;
+
+    sigval = create_ALTSIG_ATTRIBUTE(sigoct);
+    if (sigval == NULL)
+        goto err;
+    sigoct = NULL;
+
+    if (CMS_unsigned_add1_attr(si, sigalg) == 0)
+        goto err;
+
+    if (CMS_unsigned_add1_attr(si, sigval) == 0)
+        goto err;
+
+    status = 1;
+
+err:
+    EVP_MD_CTX_cleanup(&mctx);
+    if (sigbuf)
+        OPENSSL_free(sigbuf);
+    if (abuf)
+        OPENSSL_free(abuf);
+    if (sigoct)
+        ASN1_OCTET_STRING_free(sigoct);
+    if (sigalg)
+        X509_ATTRIBUTE_free(sigalg);
+    if (sigval)
+        X509_ATTRIBUTE_free(sigval);
+    if (algor)
+        X509_ALGOR_free(algor);
+    return status;
+}
+
+static int cms_SignerInfo_rawverify(EVP_PKEY *pkey, unsigned char *abuf, int alen, unsigned char *sig, size_t siglen) {
+    int ret = 0;
+
+    EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey, NULL);
+    if (pctx == NULL) {
+        goto end;
+    }
+
+    if (EVP_PKEY_verify_init(pctx) <= 0) {
+        goto end;
+    }
+
+    if (EVP_PKEY_verify(pctx, sig, siglen, abuf, alen) <= 0) {
+        goto end;
+    }
+
+    ret = 1;
+
+end:
+    EVP_PKEY_CTX_free(pctx);
+    return ret;
+}
+
 int CMS_SignerInfo_verify(CMS_SignerInfo *si)
 {
     EVP_MD_CTX *mctx = &si->mctx;
     unsigned char *abuf = NULL;
     int alen, r = -1;
     const EVP_MD *md = NULL;
+    int default_digest_nid = -1;
 
     if (!si->pkey) {
         CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY, CMS_R_NO_PUBLIC_KEY);
         return -1;
     }
 
+    alen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,
+                         ASN1_ITEM_rptr(CMS_Attributes_Verify));
+    if (!abuf)
+        goto err;
+
+    if ((EVP_PKEY_get_default_digest_nid(si->pkey, &default_digest_nid) > 0)
+        && (default_digest_nid == NID_undef)) {
+        r = cms_SignerInfo_rawverify(si->pkey, abuf, alen, si->signature->data, si->signature->length);
+        OPENSSL_free(abuf);
+        return r;
+    }
+
     md = EVP_get_digestbyobj(si->digestAlgorithm->algorithm);
     if (md == NULL)
-        return -1;
+        goto err;
     EVP_MD_CTX_init(mctx);
     if (EVP_DigestVerifyInit(mctx, &si->pctx, md, NULL, si->pkey) <= 0)
         goto err;
@@ -759,10 +1213,6 @@ int CMS_SignerInfo_verify(CMS_SignerInfo *si)
     if (!cms_sd_asn1_ctrl(si, 1))
         goto err;
 
-    alen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,
-                         ASN1_ITEM_rptr(CMS_Attributes_Verify));
-    if (!abuf)
-        goto err;
     r = EVP_DigestVerifyUpdate(mctx, abuf, alen);
     OPENSSL_free(abuf);
     if (r <= 0) {
@@ -778,8 +1228,103 @@ int CMS_SignerInfo_verify(CMS_SignerInfo *si)
     return r;
 }
 
-/* Create a chain of digest BIOs from a CMS ContentInfo */
+int CMS_SignerInfo_altverify(CMS_SignerInfo *si, BIO *bio_cont) {
+    EVP_MD_CTX *mctx = &si->mctx;
+    unsigned char *abuf = NULL;
+    int alen, r = -1;
+    const EVP_MD *md = NULL;
+    EVP_PKEY *altpk = NULL;
+    int sigind = -1;
+    X509_ATTRIBUTE *sigattr = NULL;
+    ASN1_OCTET_STRING *sigoct = NULL;
+    int default_digest_nid = -1;
+    unsigned char *cont = NULL;
+    long contlen = 0;
+
 
+    EVP_MD_CTX_init(mctx);
+
+    altpk = get_SAPKI_from_x509(si->signer);
+    if (!altpk) {
+        CMSerr(CMS_F_CMS_SIGNERINFO_ALTVERIFY, CMS_R_NO_PUBLIC_KEY);
+        goto err;
+    }
+
+    sigind = CMS_unsigned_get_attr_by_NID(si, NID_cmsAltSignatureValue, -1);
+    if (sigind < 0) {
+        goto err;
+    }
+
+    sigattr = CMS_unsigned_get_attr(si, sigind);
+    if (sigattr == NULL) {
+        goto err;
+    }
+
+    sigoct = get_ALTSIG_from_ATTRIBUTE(sigattr);
+    if (sigoct == NULL) {
+        goto err;
+    }
+
+    if (CMS_signed_get_attr_count(si) < 0) {
+        /* bio_cont is the output from SMIME_read_CMS(). As such it is a store
+         * bio that contains the message content that was signed.
+         */
+        bio_cont = BIO_find_type(bio_cont, BIO_TYPE_STORE);
+        if (bio_cont == NULL)
+            goto err;
+
+        contlen = BIO_get_store_data(bio_cont, &cont);
+        if (contlen <= 0)
+            goto err;
+
+    } else {
+        alen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,
+                             ASN1_ITEM_rptr(CMS_Attributes_Verify));
+
+        if (!abuf)
+            goto err;
+
+        cont = abuf;
+        contlen = alen;
+    }
+
+    if ((EVP_PKEY_get_default_digest_nid(altpk, &default_digest_nid) > 0)
+        && (default_digest_nid == NID_undef)) {
+        r = cms_SignerInfo_rawverify(altpk, cont, contlen, sigoct->data, sigoct->length);
+    } else {
+        md = EVP_get_digestbyobj(si->digestAlgorithm->algorithm);
+        if (md == NULL) {
+            goto err;
+        }
+
+        if (EVP_DigestVerifyInit(mctx, &si->pctx, md, NULL, altpk) <= 0)
+            goto err;
+
+        if (!cms_sd_asn1_ctrl(si, 1))
+            goto err;
+
+        r = EVP_DigestVerifyUpdate(mctx, cont, contlen);
+        if (r <= 0) {
+            r = -1;
+            goto err;
+        }
+        r = EVP_DigestVerifyFinal(mctx, sigoct->data, sigoct->length);
+        if (r <= 0)
+            CMSerr(CMS_F_CMS_SIGNERINFO_ALTVERIFY, CMS_R_VERIFICATION_FAILURE);
+    }
+
+ err:
+    if (altpk)
+        EVP_PKEY_free(altpk);
+    if (abuf)
+        OPENSSL_free(abuf);
+    EVP_MD_CTX_cleanup(mctx);
+    return r;
+}
+
+/* Create a chain of digest BIOs from a CMS ContentInfo. Add a store BIO
+ * in case we want to do raw signing.
+ */
 BIO *cms_SignedData_init_bio(CMS_ContentInfo *cms)
 {
     int i;
@@ -790,6 +1335,11 @@ BIO *cms_SignedData_init_bio(CMS_ContentInfo *cms)
         return NULL;
     if (cms->d.signedData->encapContentInfo->partial)
         cms_sd_set_version(sd);
+
+    chain = BIO_new(BIO_f_store());
+    if (!chain)
+        goto err;
+
     for (i = 0; i < sk_X509_ALGOR_num(sd->digestAlgorithms); i++) {
         X509_ALGOR *digestAlgorithm;
         BIO *mdbio;
@@ -797,10 +1347,7 @@ BIO *cms_SignedData_init_bio(CMS_ContentInfo *cms)
         mdbio = cms_DigestAlgorithm_init_bio(digestAlgorithm);
         if (!mdbio)
             goto err;
-        if (chain)
-            BIO_push(chain, mdbio);
-        else
-            chain = mdbio;
+        BIO_push(chain, mdbio);
     }
     return chain;
  err:
@@ -817,64 +1364,91 @@ int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain)
     int r = -1;
     unsigned char mval[EVP_MAX_MD_SIZE];
     unsigned int mlen;
+    int default_digest_nid = -1;
     EVP_MD_CTX_init(&mctx);
-    /* If we have any signed attributes look for messageDigest value */
-    if (CMS_signed_get_attr_count(si) >= 0) {
-        os = CMS_signed_get0_data_by_OBJ(si,
-                                         OBJ_nid2obj(NID_pkcs9_messageDigest),
-                                         -3, V_ASN1_OCTET_STRING);
-        if (!os) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);
-            goto err;
-        }
-    }
-
-    if (!cms_DigestAlgorithm_find_ctx(&mctx, chain, si->digestAlgorithm))
-        goto err;
 
-    if (EVP_DigestFinal_ex(&mctx, mval, &mlen) <= 0) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-               CMS_R_UNABLE_TO_FINALIZE_CONTEXT);
-        goto err;
-    }
 
-    /* If messageDigest found compare it */
+    if ((CMS_signed_get_attr_count(si) < 0)
+        && (EVP_PKEY_get_default_digest_nid(si->pkey, &default_digest_nid) > 0)
+        && (default_digest_nid == NID_undef)) {
+        /* There are no signed attributes and the pkey did raw signing,
+         * so verify against the content. The chain should have a store BIO.
+         * Find it and verify against the content of that BIO.
+         */
+        unsigned char *cont = NULL;
+        long contlen = 0;
 
-    if (os) {
-        if (mlen != (unsigned int)os->length) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_MESSAGEDIGEST_ATTRIBUTE_WRONG_LENGTH);
+        chain = BIO_find_type(chain, BIO_TYPE_STORE);
+        if (chain == NULL)
             goto err;
-        }
 
-        if (memcmp(mval, os->data, mlen)) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_VERIFICATION_FAILURE);
-            r = 0;
-        } else
-            r = 1;
-    } else {
-        const EVP_MD *md = EVP_MD_CTX_md(&mctx);
-        pkctx = EVP_PKEY_CTX_new(si->pkey, NULL);
-        if (pkctx == NULL)
+        contlen = BIO_get_store_data(chain, &cont);
+        if (contlen <= 0)
             goto err;
-        if (EVP_PKEY_verify_init(pkctx) <= 0)
-            goto err;
-        if (EVP_PKEY_CTX_set_signature_md(pkctx, md) <= 0)
+
+        if (cms_SignerInfo_rawverify(si->pkey, cont, (size_t)contlen, si->signature->data, si->signature->length) <= 0)
             goto err;
-        si->pctx = pkctx;
-        if (!cms_sd_asn1_ctrl(si, 1))
+
+        r = 1;
+
+    } else {
+        /* If we have any signed attributes look for messageDigest value */
+        if (CMS_signed_get_attr_count(si) >= 0) {
+            os = CMS_signed_get0_data_by_OBJ(si,
+                                             OBJ_nid2obj(NID_pkcs9_messageDigest),
+                                             -3, V_ASN1_OCTET_STRING);
+            if (!os) {
+                CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
+                       CMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);
+                goto err;
+            }
+        }
+
+        if (!cms_DigestAlgorithm_find_ctx(&mctx, chain, si->digestAlgorithm))
             goto err;
-        r = EVP_PKEY_verify(pkctx, si->signature->data,
-                            si->signature->length, mval, mlen);
-        if (r <= 0) {
+
+        if (EVP_DigestFinal_ex(&mctx, mval, &mlen) <= 0) {
             CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_VERIFICATION_FAILURE);
-            r = 0;
+                   CMS_R_UNABLE_TO_FINALIZE_CONTEXT);
+            goto err;
         }
-    }
 
+        /* If messageDigest found compare it */
+
+        if (os) {
+            if (mlen != (unsigned int)os->length) {
+                CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
+                       CMS_R_MESSAGEDIGEST_ATTRIBUTE_WRONG_LENGTH);
+                goto err;
+            }
+
+            if (memcmp(mval, os->data, mlen)) {
+                CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
+                       CMS_R_VERIFICATION_FAILURE);
+                r = 0;
+            } else
+                r = 1;
+        } else {
+            const EVP_MD *md = EVP_MD_CTX_md(&mctx);
+            pkctx = EVP_PKEY_CTX_new(si->pkey, NULL);
+            if (pkctx == NULL)
+                goto err;
+            if (EVP_PKEY_verify_init(pkctx) <= 0)
+                goto err;
+            if (EVP_PKEY_CTX_set_signature_md(pkctx, md) <= 0)
+                goto err;
+            si->pctx = pkctx;
+            if (!cms_sd_asn1_ctrl(si, 1))
+                goto err;
+            r = EVP_PKEY_verify(pkctx, si->signature->data,
+                                si->signature->length, mval, mlen);
+            if (r <= 0) {
+                CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
+                       CMS_R_VERIFICATION_FAILURE);
+                r = 0;
+            }
+        }
+    }
  err:
     if (pkctx)
         EVP_PKEY_CTX_free(pkctx);
diff --git a/openssl-1.0.2r/crypto/cms/cms_smime.c b/openssl-1.0.2r/crypto/cms/cms_smime.c
index 07e3472e..0f3f1642 100644
--- a/openssl-1.0.2r/crypto/cms/cms_smime.c
+++ b/openssl-1.0.2r/crypto/cms/cms_smime.c
@@ -367,7 +367,11 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
      * reading from a read write memory BIO when signatures are calculated.
      */
 
-    if (dcont && (BIO_method_type(dcont) == BIO_TYPE_MEM)) {
+    /* Also, there is a possiblity that it is a store. Skip that store to
+     * avoid copies of the content.
+     */
+
+    if (dcont && (BIO_find_type(dcont, BIO_TYPE_MEM) != NULL)) {
         char *ptr;
         long len;
         len = BIO_get_mem_data(dcont, &ptr);
diff --git a/openssl-1.0.2r/crypto/cryptlib.c b/openssl-1.0.2r/crypto/cryptlib.c
index 5fab45b2..9bf060ec 100644
--- a/openssl-1.0.2r/crypto/cryptlib.c
+++ b/openssl-1.0.2r/crypto/cryptlib.c
@@ -166,7 +166,22 @@ static const char *const lock_names[CRYPTO_NUM_LOCKS] = {
     "comp",
     "fips",
     "fips2",
-#if CRYPTO_NUM_LOCKS != 41
+    "hss",
+    "dilithium",
+    "rainbow",
+    "nhdh",
+    "ntrup",
+    "kyber",
+    "sidh",
+    "frododh",
+    "sike"
+    "xmss",
+    "frodokem",
+    "xmssmt",
+    "cmc",
+    "sphincs",
+    "frododh",
+#if CRYPTO_NUM_LOCKS != 56
 # error "Inconsistency between crypto.h and cryptlib.c"
 #endif
 };
diff --git a/openssl-1.0.2r/crypto/crypto.h b/openssl-1.0.2r/crypto/crypto.h
index 6c644ce1..3691ba29 100644
--- a/openssl-1.0.2r/crypto/crypto.h
+++ b/openssl-1.0.2r/crypto/crypto.h
@@ -225,7 +225,22 @@ typedef struct openssl_item_st {
 # define CRYPTO_LOCK_COMP                38
 # define CRYPTO_LOCK_FIPS                39
 # define CRYPTO_LOCK_FIPS2               40
-# define CRYPTO_NUM_LOCKS                41
+# define CRYPTO_LOCK_HSS                 41
+# define CRYPTO_LOCK_DILITHIUM           42
+# define CRYPTO_LOCK_RAINBOW             43
+# define CRYPTO_LOCK_NHDH                44
+# define CRYPTO_LOCK_NTRUP               45
+# define CRYPTO_LOCK_KYBER               46
+# define CRYPTO_LOCK_SIDH                47
+# define CRYPTO_LOCK_FRODODH             48
+# define CRYPTO_LOCK_SIKE                49
+# define CRYPTO_LOCK_XMSS                50
+# define CRYPTO_LOCK_FRODOKEM            51
+# define CRYPTO_LOCK_XMSSMT              52
+# define CRYPTO_LOCK_CMC                 53
+# define CRYPTO_LOCK_SPHINCS             54
+# define CRYPTO_LOCK_SAMWISE             55
+# define CRYPTO_NUM_LOCKS                56
 
 # define CRYPTO_LOCK             1
 # define CRYPTO_UNLOCK           2
@@ -332,6 +347,21 @@ DECLARE_STACK_OF(CRYPTO_EX_DATA_FUNCS)
 # define CRYPTO_EX_INDEX_ECDH            13
 # define CRYPTO_EX_INDEX_COMP            14
 # define CRYPTO_EX_INDEX_STORE           15
+# define CRYPTO_EX_INDEX_HSS             16
+# define CRYPTO_EX_INDEX_DILITHIUM       17
+# define CRYPTO_EX_INDEX_RAINBOW         18
+# define CRYPTO_EX_INDEX_NHDH            19
+# define CRYPTO_EX_INDEX_NTRUP           20
+# define CRYPTO_EX_INDEX_KYBER           21
+# define CRYPTO_EX_INDEX_SIDH            22
+# define CRYPTO_EX_INDEX_FRODODH         23
+# define CRYPTO_EX_INDEX_SIKE            24
+# define CRYPTO_EX_INDEX_XMSS            25
+# define CRYPTO_EX_INDEX_FRODOKEM        26
+# define CRYPTO_EX_INDEX_XMSSMT          27
+# define CRYPTO_EX_INDEX_CMC             28
+# define CRYPTO_EX_INDEX_SPHINCS         29
+# define CRYPTO_EX_INDEX_SAMWISE         30
 
 /*
  * Dynamically assigned indexes start from this value (don't use directly,
diff --git a/openssl-1.0.2r/crypto/dilithium/Makefile b/openssl-1.0.2r/crypto/dilithium/Makefile
new file mode 100644
index 00000000..3820278f
--- /dev/null
+++ b/openssl-1.0.2r/crypto/dilithium/Makefile
@@ -0,0 +1,120 @@
+#
+# OpenSSL/crypto/dilithium/Makefile
+#
+
+DIR=	dilithium
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= dilithium_lib.c dilithium_asn1.c dilithium_err.c
+LIBOBJ= dilithium_lib.o dilithium_asn1.o dilithium_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= dilithium.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+dilithium_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+dilithium_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+dilithium_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+dilithium_asn1.o: ../../include/openssl/dilithium.h
+dilithium_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+dilithium_asn1.o: ../../include/openssl/lhash.h
+dilithium_asn1.o: ../../include/openssl/opensslconf.h
+dilithium_asn1.o: ../../include/openssl/opensslv.h
+dilithium_asn1.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rand.h
+dilithium_asn1.o: ../../include/openssl/safestack.h
+dilithium_asn1.o: ../../include/openssl/stack.h
+dilithium_asn1.o: ../../include/openssl/symhacks.h ../cryptlib.h
+dilithium_asn1.o: dilithium_asn1.c
+dilithium_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+dilithium_err.o: ../../include/openssl/crypto.h
+dilithium_err.o: ../../include/openssl/dilithium.h
+dilithium_err.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+dilithium_err.o: ../../include/openssl/lhash.h
+dilithium_err.o: ../../include/openssl/opensslconf.h
+dilithium_err.o: ../../include/openssl/opensslv.h
+dilithium_err.o: ../../include/openssl/ossl_typ.h
+dilithium_err.o: ../../include/openssl/safestack.h
+dilithium_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+dilithium_err.o: dilithium_err.c
+dilithium_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+dilithium_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+dilithium_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+dilithium_lib.o: ../../include/openssl/dilithium.h
+dilithium_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+dilithium_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+dilithium_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+dilithium_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+dilithium_lib.o: ../../include/openssl/obj_mac.h
+dilithium_lib.o: ../../include/openssl/objects.h
+dilithium_lib.o: ../../include/openssl/opensslconf.h
+dilithium_lib.o: ../../include/openssl/opensslv.h
+dilithium_lib.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+dilithium_lib.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+dilithium_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+dilithium_lib.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+dilithium_lib.o: ../cryptlib.h dilithium_lib.c
diff --git a/openssl-1.0.2r/crypto/dilithium/dilithium.h b/openssl-1.0.2r/crypto/dilithium/dilithium.h
new file mode 100644
index 00000000..04077f74
--- /dev/null
+++ b/openssl-1.0.2r/crypto/dilithium/dilithium.h
@@ -0,0 +1,145 @@
+/* crypto/dilithium/dilithium.h based off of crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_DILITHIUM_H
+# define HEADER_DILITHIUM_H
+
+# include <openssl/e_os2.h>
+
+# ifdef OPENSSL_NO_DILITHIUM
+#  error DILITHIUM is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_DILITHIUM_PARAMETER_SET  (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string          "parameter_set"
+
+#define DILITHIUM_III_SHAKE_R2                 1
+#define DILITHIUM_IV_SHAKE_R2                  2
+
+struct dilithium_st {
+    /* This first variable is used to pick up errors where a DILITHIUM is passed
+     * instead of a EVP_PKEY. These first 2 members are standard for all
+     *  the algorithms.
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    /* The parameters of DILITHIUM.  Please see the spec */
+    long parameter_set;
+
+    /* public key */
+    ASN1_OCTET_STRING *pub_key;
+    /* private key */
+    ASN1_OCTET_STRING *priv_key;
+
+    int flags;
+    int references;
+
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+/* memory management methods for the DILITHIUM struct */
+DILITHIUM *DILITHIUM_new(void);
+DILITHIUM *DILITHIUM_new_with_engine(ENGINE *engine);
+void DILITHIUM_free(DILITHIUM *r);
+int DILITHIUM_up_ref(DILITHIUM *r);
+
+/* ASN.1 for public key */
+DILITHIUM *d2i_DILITHIUMPublicKey(DILITHIUM **a, const unsigned char **pp, long length);
+int i2d_DILITHIUMPublicKey(const DILITHIUM *a, unsigned char **pp);
+
+/* ASN.1 for private key */
+DILITHIUM *d2i_DILITHIUMPrivateKey(DILITHIUM **a, const unsigned char **pp, long length);
+int i2d_DILITHIUMPrivateKey(const DILITHIUM *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_DILITHIUM_strings(void);
+
+/* Error codes for the DILITHIUM functions. */
+
+/* Function codes. */
+# define DILITHIUM_F_DILITHIUM_NEW_WITH_ENGINE                  100
+
+/* Reason codes. */
+# define DILITHIUM_R_ENGINE_INIT_FAILURE                        100
+# define DILITHIUM_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/dilithium/dilithium_asn1.c b/openssl-1.0.2r/crypto/dilithium/dilithium_asn1.c
new file mode 100644
index 00000000..bde40638
--- /dev/null
+++ b/openssl-1.0.2r/crypto/dilithium/dilithium_asn1.c
@@ -0,0 +1,119 @@
+/* dilithium_asn1.c based off of dsa_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/dilithium.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int dilithium_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)DILITHIUM_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        DILITHIUM_free((DILITHIUM *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(DILITHIUMPrivateKey, dilithium_cb) = {
+        ASN1_SIMPLE(DILITHIUM, version, LONG),
+        ASN1_SIMPLE(DILITHIUM, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(DILITHIUM, pub_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(DILITHIUM, DILITHIUMPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DILITHIUM, DILITHIUMPrivateKey, DILITHIUMPrivateKey)
+
+DILITHIUM *d2i_DILITHIUMPublicKey(DILITHIUM **a, const unsigned char **pp, long length) {
+    DILITHIUM *dilithium = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    dilithium = DILITHIUM_new();
+    if (dilithium == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        DILITHIUM_free(dilithium);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            DILITHIUM_free(*a);
+        *a = dilithium;
+    }
+
+    dilithium->pub_key = pub_key;
+    return dilithium;
+}
+
+int i2d_DILITHIUMPublicKey(const DILITHIUM *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
+
diff --git a/openssl-1.0.2r/crypto/dilithium/dilithium_err.c b/openssl-1.0.2r/crypto/dilithium/dilithium_err.c
new file mode 100644
index 00000000..1109b6d3
--- /dev/null
+++ b/openssl-1.0.2r/crypto/dilithium/dilithium_err.c
@@ -0,0 +1,94 @@
+/* crypto/dilithium/dilithium_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2017 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/dilithium.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_DILITHIUM,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_DILITHIUM,0,reason)
+
+static ERR_STRING_DATA DILITHIUM_str_functs[] = {
+    {ERR_FUNC(DILITHIUM_F_DILITHIUM_NEW_WITH_ENGINE), "DILITHIUM_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA DILITHIUM_str_reasons[] = {
+    {ERR_REASON(DILITHIUM_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(DILITHIUM_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_DILITHIUM_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(DILITHIUM_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, DILITHIUM_str_functs);
+        ERR_load_strings(0, DILITHIUM_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/dilithium/dilithium_lib.c b/openssl-1.0.2r/crypto/dilithium/dilithium_lib.c
new file mode 100644
index 00000000..37752396
--- /dev/null
+++ b/openssl-1.0.2r/crypto/dilithium/dilithium_lib.c
@@ -0,0 +1,172 @@
+/* crypto/dilithium/dilithium_lib.c based off of crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/dilithium.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char DILITHIUM_version[] = "DILITHIUM" OPENSSL_VERSION_PTEXT;
+
+
+DILITHIUM *DILITHIUM_new(void) {
+    return DILITHIUM_new_with_engine(NULL);
+}
+
+DILITHIUM *DILITHIUM_new_with_engine(ENGINE *engine)
+{
+    DILITHIUM *ret;
+
+    ret = (DILITHIUM *)OPENSSL_malloc(sizeof(DILITHIUM));
+    if (ret == NULL) {
+        DILITHIUMerr(DILITHIUM_F_DILITHIUM_NEW_WITH_ENGINE, DILITHIUM_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            DILITHIUMerr(DILITHIUM_F_DILITHIUM_NEW_WITH_ENGINE, DILITHIUM_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+    ret->parameter_set = -1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_DILITHIUM, ret, &ret->ex_data);
+    return (ret);
+}
+
+void DILITHIUM_free(DILITHIUM *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DILITHIUM);
+#ifdef REF_PRINT
+    REF_PRINT("DILITHIUM", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "DILITHIUM_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+#ifndef OPENSSL_NO_ENGINE
+    if (r->engine)
+        ENGINE_finish(r->engine);
+#endif
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DILITHIUM, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int DILITHIUM_up_ref(DILITHIUM *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_DILITHIUM);
+#ifdef REF_PRINT
+    REF_PRINT("DILITHIUM", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "DILITHIUM_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
diff --git a/openssl-1.0.2r/crypto/err/err.c b/openssl-1.0.2r/crypto/err/err.c
index 5ce774a3..14c00dd2 100644
--- a/openssl-1.0.2r/crypto/err/err.c
+++ b/openssl-1.0.2r/crypto/err/err.c
@@ -156,6 +156,21 @@ static ERR_STRING_DATA ERR_str_libraries[] = {
     {ERR_PACK(ERR_LIB_FIPS, 0, 0), "FIPS routines"},
     {ERR_PACK(ERR_LIB_CMS, 0, 0), "CMS routines"},
     {ERR_PACK(ERR_LIB_HMAC, 0, 0), "HMAC routines"},
+    {ERR_PACK(ERR_LIB_HSS, 0, 0), "HSS routines"},
+    {ERR_PACK(ERR_LIB_XMSS, 0, 0), "XMSS routines"},
+    {ERR_PACK(ERR_LIB_XMSSMT, 0, 0), "XMSSMT routines"},
+    {ERR_PACK(ERR_LIB_DILITHIUM, 0, 0), "Dilithium routines"},
+    {ERR_PACK(ERR_LIB_SPHINCS, 0, 0), "Sphincs routines"},
+    {ERR_PACK(ERR_LIB_RAINBOW, 0, 0), "Rainbow routines"},
+    {ERR_PACK(ERR_LIB_NHDH, 0, 0), "NHDH routines"},
+    {ERR_PACK(ERR_LIB_CMC, 0, 0), "Classic McEliece routines"},
+    {ERR_PACK(ERR_LIB_NTRUP, 0, 0), "NTRU Prime routines"},
+    {ERR_PACK(ERR_LIB_KYBER, 0, 0), "Kyber routines"},
+    {ERR_PACK(ERR_LIB_SIDH, 0, 0), "SIDH routines"},
+    {ERR_PACK(ERR_LIB_FRODODH, 0, 0), "FRODODH routines"},
+    {ERR_PACK(ERR_LIB_SIKE, 0, 0), "SIKE routines"},
+    {ERR_PACK(ERR_LIB_FRODOKEM, 0, 0), "FRODOKEM routines"},
+    {ERR_PACK(ERR_LIB_SAMWISE, 0, 0), "SAMWISE routines"},
     {0, NULL},
 };
 
diff --git a/openssl-1.0.2r/crypto/err/err.h b/openssl-1.0.2r/crypto/err/err.h
index f4236562..5f24cf70 100644
--- a/openssl-1.0.2r/crypto/err/err.h
+++ b/openssl-1.0.2r/crypto/err/err.h
@@ -197,6 +197,21 @@ typedef struct err_state_st {
 # define ERR_LIB_TS              47
 # define ERR_LIB_HMAC            48
 # define ERR_LIB_JPAKE           49
+# define ERR_LIB_HSS            100
+# define ERR_LIB_DILITHIUM      101
+# define ERR_LIB_RAINBOW        102
+# define ERR_LIB_NHDH           103
+# define ERR_LIB_NTRUP          104
+# define ERR_LIB_KYBER          105
+# define ERR_LIB_SIDH           106
+# define ERR_LIB_FRODODH        107
+# define ERR_LIB_SIKE           108
+# define ERR_LIB_XMSS           109
+# define ERR_LIB_XMSSMT         110
+# define ERR_LIB_FRODOKEM       111
+# define ERR_LIB_CMC            112
+# define ERR_LIB_SPHINCS        113
+# define ERR_LIB_SAMWISE        114
 
 # define ERR_LIB_USER            128
 
@@ -233,6 +248,21 @@ typedef struct err_state_st {
 # define TSerr(f,r) ERR_PUT_error(ERR_LIB_TS,(f),(r),__FILE__,__LINE__)
 # define HMACerr(f,r) ERR_PUT_error(ERR_LIB_HMAC,(f),(r),__FILE__,__LINE__)
 # define JPAKEerr(f,r) ERR_PUT_error(ERR_LIB_JPAKE,(f),(r),__FILE__,__LINE__)
+# define HSSerr(f,r) ERR_PUT_error(ERR_LIB_HSS,(f),(r),__FILE__,__LINE__)
+# define XMSSerr(f,r) ERR_PUT_error(ERR_LIB_XMSS,(f),(r),__FILE__,__LINE__)
+# define XMSSMTerr(f,r) ERR_PUT_error(ERR_LIB_XMSSMT,(f),(r),__FILE__,__LINE__)
+# define DILITHIUMerr(f,r) ERR_PUT_error(ERR_LIB_DILITHIUM,(f),(r),__FILE__,__LINE__)
+# define SPHINCSerr(f,r) ERR_PUT_error(ERR_LIB_SPHINCS,(f),(r),__FILE__,__LINE__)
+# define FRODODHerr(f,r) ERR_PUT_error(ERR_LIB_FRODODH,(f),(r),__FILE__,__LINE__)
+# define RAINBOWerr(f,r) ERR_PUT_error(ERR_LIB_RAINBOW,(f),(r),__FILE__,__LINE__)
+# define NHDHerr(f,r) ERR_PUT_error(ERR_LIB_NHDH,(f),(r),__FILE__,__LINE__)
+# define CMCerr(f,r) ERR_PUT_error(ERR_LIB_CMC,(f),(r),__FILE__,__LINE__)
+# define NTRUPerr(f,r) ERR_PUT_error(ERR_LIB_NTRUP,(f),(r),__FILE__,__LINE__)
+# define KYBERerr(f,r) ERR_PUT_error(ERR_LIB_KYBER,(f),(r),__FILE__,__LINE__)
+# define SIDHerr(f,r) ERR_PUT_error(ERR_LIB_SIDH,(f),(r),__FILE__,__LINE__)
+# define SIKEerr(f,r) ERR_PUT_error(ERR_LIB_SIKE,(f),(r),__FILE__,__LINE__)
+# define FRODOKEMerr(f,r) ERR_PUT_error(ERR_LIB_FRODOKEM,(f),(r),__FILE__,__LINE__)
+# define SAMWISEerr(f,r) ERR_PUT_error(ERR_LIB_SAMWISE,(f),(r),__FILE__,__LINE__)
 
 /*
  * Borland C seems too stupid to be able to shift and do longs in the
diff --git a/openssl-1.0.2r/crypto/err/err_all.c b/openssl-1.0.2r/crypto/err/err_all.c
index d7575a7e..35e94761 100644
--- a/openssl-1.0.2r/crypto/err/err_all.c
+++ b/openssl-1.0.2r/crypto/err/err_all.c
@@ -107,6 +107,51 @@
 #ifndef OPENSSL_NO_JPAKE
 # include <openssl/jpake.h>
 #endif
+# ifndef OPENSSL_NO_HSS
+# include <openssl/hss.h>
+# endif
+# ifndef OPENSSL_NO_XMSS
+# include <openssl/xmss.h>
+# endif
+# ifndef OPENSSL_NO_XMSSMT
+# include <openssl/xmssmt.h>
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+# endif
+# ifndef OPENSSL_NO_SPHINCS
+# include <openssl/sphincs.h>
+# endif
+# ifndef OPENSSL_NO_FRODODH
+# include <openssl/frododh.h>
+# endif
+# ifndef OPENSSL_NO_SAMWISE
+# include <openssl/samwise.h>
+# endif
+# ifndef OPENSSL_NO_RAINBOW
+# include <openssl/rainbow.h>
+# endif
+# if !defined(OPENSSL_NO_NHDH)
+# include <openssl/nhdh.h>
+# endif
+# ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+# endif
+# ifndef OPENSSL_NO_CMC
+# include <openssl/cmc.h>
+# endif
+# ifndef OPENSSL_NO_NTRUP
+# include <openssl/ntrup.h>
+# endif
+# ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+# endif
+# ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+# endif
+# ifndef OPENSSL_NO_FRODOKEM
+# include <openssl/frodokem.h>
+# endif
 
 void ERR_load_crypto_strings(void)
 {
@@ -164,5 +209,50 @@ void ERR_load_crypto_strings(void)
 # ifndef OPENSSL_NO_JPAKE
     ERR_load_JPAKE_strings();
 # endif
+# ifndef OPENSSL_NO_HSS
+    ERR_load_HSS_strings();
+# endif
+# ifndef OPENSSL_NO_XMSS
+    ERR_load_XMSS_strings();
+# endif
+# ifndef OPENSSL_NO_XMSSMT
+    ERR_load_XMSSMT_strings();
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+    ERR_load_DILITHIUM_strings();
+# endif
+# ifndef OPENSSL_NO_SPHINCS
+    ERR_load_SPHINCS_strings();
+# endif
+# ifndef OPENSSL_NO_FRODODH
+    ERR_load_FRODODH_strings();
+# endif
+# ifndef OPENSSL_NO_SAMWISE
+    ERR_load_SAMWISE_strings();
+# endif
+# ifndef OPENSSL_NO_RAINBOW
+    ERR_load_RAINBOW_strings();
+# endif
+# if !defined(OPENSSL_NO_NHDH)
+    ERR_load_NHDH_strings();
+# endif
+# ifndef OPENSSL_NO_SIDH
+    ERR_load_SIDH_strings();
+# endif
+# ifndef OPENSSL_NO_CMC
+    ERR_load_CMC_strings();
+# endif
+# ifndef OPENSSL_NO_NTRUP
+    ERR_load_NTRUP_strings();
+# endif
+# ifndef OPENSSL_NO_KYBER
+    ERR_load_KYBER_strings();
+# endif
+# ifndef OPENSSL_NO_SIKE
+    ERR_load_SIKE_strings();
+# endif
+# ifndef OPENSSL_NO_FRODOKEM
+    ERR_load_FRODOKEM_strings();
+# endif
 #endif
 }
diff --git a/openssl-1.0.2r/crypto/err/openssl.ec b/openssl-1.0.2r/crypto/err/openssl.ec
index 04dc9ce6..b5939dd8 100644
--- a/openssl-1.0.2r/crypto/err/openssl.ec
+++ b/openssl-1.0.2r/crypto/err/openssl.ec
@@ -35,6 +35,21 @@ L TS		crypto/ts/ts.h			crypto/ts/ts_err.c
 #L HMAC		crypto/hmac/hmac.h		crypto/hmac/hmac_err.c
 L CMS		crypto/cms/cms.h		crypto/cms/cms_err.c
 L JPAKE		crypto/jpake/jpake.h		crypto/jpake/jpake_err.c
+L HSS		crypto/hss/hss.h		crypto/hss/hss_err.c
+L XMSS		crypto/xmss/xmss.h		crypto/xmss/xmss_err.c
+L XMSSMT	crypto/xmssmt/xmssmt.h		crypto/xmssmt/xmssmt_err.c
+L FRODODH	crypto/frododh/frododh.h		crypto/frododh/frododh_err.c
+L SAMWISE	crypto/samwise/samwise.h		crypto/samwise/samwise_err.c
+L FRODOKEM	crypto/frodokem/frodokem.h		crypto/frodokem/frodokem_err.c
+L DILITHIUM	crypto/dilithium/dilithium.h	crypto/dilithium/dilithium_err.c
+L SPHINCS	crypto/sphincs/sphincs.h	crypto/sphincs/sphincs_err.c
+L RAINBOW	crypto/rainbow/rainbow.h	crypto/rainbow/rainbow_err.c
+L NHDH		crypto/nhdh/nhdh.h		crypto/nhdh/nhdh_err.c
+L CMC		crypto/cmc/cmc.h		crypto/cmc/cmc_err.c
+L NTRUP		crypto/ntrup/ntrup.h	crypto/ntrup/ntrup_err.c
+L KYBER		crypto/kyber/kyber.h	crypto/kyber/kyber_err.c
+L SIDH      crypto/sidh/sidh.h      crypto/sidh/sidh_err.c
+L SIKE		crypto/sike/sike.h		crypto/sike/sike_err.c
 
 # additional header files to be scanned for function names
 L NONE		crypto/x509/x509_vfy.h		NONE
diff --git a/openssl-1.0.2r/crypto/evp/evp.h b/openssl-1.0.2r/crypto/evp/evp.h
index 883a9434..ef2e4b1a 100644
--- a/openssl-1.0.2r/crypto/evp/evp.h
+++ b/openssl-1.0.2r/crypto/evp/evp.h
@@ -103,6 +103,20 @@
 # define EVP_PKS_RSA     0x0100
 # define EVP_PKS_DSA     0x0200
 # define EVP_PKS_EC      0x0400
+# define EVP_PK_HSS        0x0800
+# define EVP_PKS_HSS       0x1000
+# define EVP_PK_DILITHIUM  0x2000
+# define EVP_PKS_DILITHIUM 0x4000
+# define EVP_PK_RAINBOW    0x8000
+# define EVP_PKS_RAINBOW   0x10000
+# define EVP_PK_XMSS       0x20000
+# define EVP_PKS_XMSS      0x40000
+# define EVP_PK_XMSSMT     0x80000
+# define EVP_PKS_XMSSMT    0x100000
+# define EVP_PK_SPHINCS    0x200000
+# define EVP_PKS_SPHINCS   0x400000
+
+
 
 # define EVP_PKEY_NONE   NID_undef
 # define EVP_PKEY_RSA    NID_rsaEncryption
@@ -117,6 +131,21 @@
 # define EVP_PKEY_EC     NID_X9_62_id_ecPublicKey
 # define EVP_PKEY_HMAC   NID_hmac
 # define EVP_PKEY_CMAC   NID_cmac
+# define EVP_PKEY_HSS    NID_hss
+# define EVP_PKEY_XMSS   NID_xmss
+# define EVP_PKEY_XMSSMT NID_xmssmt
+# define EVP_PKEY_DILITHIUM NID_dilithium
+# define EVP_PKEY_SPHINCS NID_sphincs
+# define EVP_PKEY_RAINBOW NID_rainbow
+# define EVP_PKEY_NHDH   NID_nhdh
+# define EVP_PKEY_SIDH   NID_sidh
+# define EVP_PKEY_CMC    NID_cmc
+# define EVP_PKEY_NTRUP  NID_ntrup
+# define EVP_PKEY_KYBER  NID_kyber
+# define EVP_PKEY_FRODOKEM  NID_frodokem
+# define EVP_PKEY_FRODODH  NID_frododh
+# define EVP_PKEY_SIKE   NID_sike
+# define EVP_PKEY_SAMWISE NID_samwise
 
 #ifdef  __cplusplus
 extern "C" {
@@ -145,6 +174,51 @@ struct evp_pkey_st {
 # endif
 # ifndef OPENSSL_NO_EC
         struct ec_key_st *ec;   /* ECC */
+# endif
+# ifndef OPENSSL_NO_HSS
+        struct hss_st *hss;     /* HSS */
+# endif
+# ifndef OPENSSL_NO_XMSS
+        struct xmss_st *xmss;   /* XMSS */
+# endif
+# ifndef OPENSSL_NO_XMSSMT
+        struct xmssmt_st *xmssmt; /* XMSSMT */
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+        struct dilithium_st *dilithium; /* DILITHIUM */
+# endif
+# ifndef OPENSSL_NO_SPHINCS
+        struct sphincs_st *sphincs; /* SPHINCS */
+# endif
+# ifndef OPENSSL_NO_FRODODH
+        struct frododh_st *frododh;     /* FRODODH */
+# endif
+# ifndef OPENSSL_NO_SAMWISE
+        struct samwise_st *samwise;     /* SAMWISE */
+# endif
+# ifndef OPENSSL_NO_RAINBOW
+        struct rainbow_st *rainbow; /* RAINBOW */
+# endif
+#ifndef OPENSSL_NO_NHDH
+        struct nhdh_st *nhdh;       /* NHDH */
+# endif
+# ifndef OPENSSL_NO_SIDH
+        struct sidh_st *sidh;     /* SIDH */
+# endif
+# ifndef OPENSSL_NO_CMC
+        struct cmc_st *cmc;       /* CMC */
+# endif
+# ifndef OPENSSL_NO_NTRUP
+        struct ntrup_st *ntrup;  /* NTRUP */
+# endif
+# ifndef OPENSSL_NO_KYBER
+        struct kyber_st *kyber;  /* KYBER */
+# endif
+# ifndef OPENSSL_NO_FRODOKEM
+        struct frodokem_st *frodokem;  /* FRODOKEM */
+# endif
+# ifndef OPENSSL_NO_SIKE
+        struct sike_st *sike;    /* SIKE */
 # endif
     } pkey;
     int save_parameters;
@@ -497,6 +571,81 @@ typedef int (EVP_PBE_KEYGEN) (EVP_CIPHER_CTX *ctx, const char *pass,
                                         (char *)(dsa))
 # endif
 
+# ifndef OPENSSL_NO_HSS
+#  define EVP_PKEY_assign_HSS(pkey,hss) EVP_PKEY_assign((pkey),EVP_PKEY_HSS,\
+                                        (char *)(hss))
+# endif
+
+# ifndef OPENSSL_NO_XMSS
+#  define EVP_PKEY_assign_XMSS(pkey,xmss) EVP_PKEY_assign((pkey),EVP_PKEY_XMSS,\
+                                        (char *)(xmss))
+# endif
+
+# ifndef OPENSSL_NO_XMSSMT
+#  define EVP_PKEY_assign_XMSSMT(pkey,xmssmt) EVP_PKEY_assign((pkey),EVP_PKEY_XMSSMT,\
+                                        (char *)(xmssmt))
+# endif
+
+# ifndef OPENSSL_NO_DILITHIUM
+#  define EVP_PKEY_assign_DILITHIUM(pkey,dilithium) EVP_PKEY_assign((pkey),EVP_PKEY_DILITHIUM,\
+                                        (char *)(dilithium))
+# endif
+
+# ifndef OPENSSL_NO_SPHINCS
+#  define EVP_PKEY_assign_SPHINCS(pkey,sphincs) EVP_PKEY_assign((pkey),EVP_PKEY_SPHINCS,\
+                                        (char *)(sphincs))
+# endif
+
+# ifndef OPENSSL_NO_FRODODH
+#  define EVP_PKEY_assign_FRODODH(pkey,frododh) EVP_PKEY_assign((pkey),EVP_PKEY_FRODODH,\
+                                        (char *)(frododh))
+# endif
+
+# ifndef OPENSSL_NO_SAMWISE
+#  define EVP_PKEY_assign_SAMWISE(pkey,samwise) EVP_PKEY_assign((pkey),EVP_PKEY_SAMWISE,\
+                                        (char *)(samwise))
+# endif
+
+# ifndef OPENSSL_NO_RAINBOW
+#  define EVP_PKEY_assign_RAINBOW(pkey,rainbow) EVP_PKEY_assign((pkey),EVP_PKEY_RAINBOW,\
+                                        (char *)(rainbow))
+# endif
+
+# ifndef OPENSSL_NO_NHDH
+#  define EVP_PKEY_assign_NHDH(pkey,nhdh) EVP_PKEY_assign((pkey),EVP_PKEY_NHDH,\
+                                        (char *)(nhdh))
+# endif
+
+# ifndef OPENSSL_NO_SIDH
+#  define EVP_PKEY_assign_SIDH(pkey,sidh) EVP_PKEY_assign((pkey),EVP_PKEY_SIDH,\
+                                        (char *)(sidh))
+# endif
+
+# ifndef OPENSSL_NO_CMC
+#  define EVP_PKEY_assign_CMC(pkey,cmc) EVP_PKEY_assign((pkey),EVP_PKEY_CMC,\
+                                        (char *)(cmc))
+# endif
+
+# ifndef OPENSSL_NO_NTRUP
+#  define EVP_PKEY_assign_NTRUP(pkey,ntrup) EVP_PKEY_assign((pkey),EVP_PKEY_NTRUP,\
+                                        (char *)(ntrup))
+# endif
+
+# ifndef OPENSSL_NO_KYBER
+#  define EVP_PKEY_assign_KYBER(pkey,kyber) EVP_PKEY_assign((pkey),EVP_PKEY_KYBER,\
+                                        (char *)(kyber))
+# endif
+
+# ifndef OPENSSL_NO_FRODOKEM
+#  define EVP_PKEY_assign_FRODOKEM(pkey,frodokem) EVP_PKEY_assign((pkey),EVP_PKEY_FRODOKEM,\
+                                        (char *)(frodokem))
+# endif
+
+# ifndef OPENSSL_NO_SIKE
+#  define EVP_PKEY_assign_SIKE(pkey,sike) EVP_PKEY_assign((pkey),EVP_PKEY_SIKE,\
+                                        (char *)(sike))
+# endif
+
 # ifndef OPENSSL_NO_DH
 #  define EVP_PKEY_assign_DH(pkey,dh) EVP_PKEY_assign((pkey),EVP_PKEY_DH,\
                                         (char *)(dh))
@@ -966,6 +1115,71 @@ struct dsa_st;
 int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, struct dsa_st *key);
 struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);
 # endif
+# ifndef OPENSSL_NO_HSS
+struct hss_st;
+int EVP_PKEY_set1_HSS(EVP_PKEY *pkey, struct hss_st *key);
+struct hss_st *EVP_PKEY_get1_HSS(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_XMSS
+struct xmss_st;
+int EVP_PKEY_set1_XMSS(EVP_PKEY *pkey, struct xmss_st *key);
+struct xmss_st *EVP_PKEY_get1_XMSS(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_XMSSMT
+struct xmssmt_st;
+int EVP_PKEY_set1_XMSSMT(EVP_PKEY *pkey, struct xmssmt_st *key);
+struct xmssmt_st *EVP_PKEY_get1_XMSSMT(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+struct dilithium_st;
+int EVP_PKEY_set1_DILITHIUM(EVP_PKEY *pkey, struct dilithium_st *key);
+struct dilithium_st *EVP_PKEY_get1_DILITHIUM(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_SPHINCS
+struct sphincs_st;
+int EVP_PKEY_set1_SPHINCS(EVP_PKEY *pkey, struct sphincs_st *key);
+struct sphincs_st *EVP_PKEY_get1_SPHINCS(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_FRODODH
+struct frododh_st;
+int EVP_PKEY_set1_FRODODH(EVP_PKEY *pkey, struct frododh_st *key);
+struct frododh_st *EVP_PKEY_get1_FRODODH(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_SAMWISE
+struct samwise_st;
+int EVP_PKEY_set1_SAMWISE(EVP_PKEY *pkey, struct samwise_st *key);
+struct samwise_st *EVP_PKEY_get1_SAMWISE(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_RAINBOW
+struct rainbow_st;
+int EVP_PKEY_set1_RAINBOW(EVP_PKEY *pkey, struct rainbow_st *key);
+struct rainbow_st *EVP_PKEY_get1_RAINBOW(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_CMC
+struct cmc_st;
+int EVP_PKEY_set1_CMC(EVP_PKEY *pkey, struct cmc_st *key);
+struct cmc_st *EVP_PKEY_get1_CMC(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_NTRUP
+struct ntrup_st;
+int EVP_PKEY_set1_NTRUP(EVP_PKEY *pkey, struct ntrup_st *key);
+struct ntrup_st *EVP_PKEY_get1_NTRUP(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_KYBER
+struct kyber_st;
+int EVP_PKEY_set1_KYBER(EVP_PKEY *pkey, struct kyber_st *key);
+struct kyber_st *EVP_PKEY_get1_KYBER(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_FRODOKEM
+struct frodokem_st;
+int EVP_PKEY_set1_FRODOKEM(EVP_PKEY *pkey, struct frodokem_st *key);
+struct frodokem_st *EVP_PKEY_get1_FRODOKEM(EVP_PKEY *pkey);
+# endif
+# ifndef OPENSSL_NO_SIKE
+struct sike_st;
+int EVP_PKEY_set1_SIKE(EVP_PKEY *pkey, struct sike_st *key);
+struct sike_st *EVP_PKEY_get1_SIKE(EVP_PKEY *pkey);
+# endif
 # ifndef OPENSSL_NO_DH
 struct dh_st;
 int EVP_PKEY_set1_DH(EVP_PKEY *pkey, struct dh_st *key);
@@ -977,13 +1191,56 @@ int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, struct ec_key_st *key);
 struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
 # endif
 
+#define EVP_PKEY_is_QS(type) (  EVP_PKEY_is_QS_auth(type) \
+                             || EVP_PKEY_is_QS_kem(type) \
+                             || EVP_PKEY_is_QS_dh(type))
+
+#define EVP_PKEY_is_QS_auth(type) (  (type == NID_dilithium) \
+                                  || (type == NID_rainbow)   \
+                                  || (type == NID_sphincs)   \
+                                  || (type == NID_hss)       \
+                                  || (type == NID_xmss)      \
+                                  || (type == NID_xmssmt))
+
+#define EVP_PKEY_is_QS_kem(type) (  (type == NID_cmc)      \
+                                 || (type == NID_frodokem) \
+                                 || (type == NID_kyber)    \
+                                 || (type == NID_ntrup)    \
+                                 || (type == NID_sike))
+
+#define EVP_PKEY_is_QS_dh(type) (  (type == NID_frododh) \
+                                || (type == NID_samwise) \
+                                || (type == NID_nhdh)    \
+                                || (type == NID_sidh))
+
+
 EVP_PKEY *EVP_PKEY_new(void);
 void EVP_PKEY_free(EVP_PKEY *pkey);
 
+/* Note that this function gives ownership of the returned buffer pointed to by
+ * *pp. The user must still free the memory pointed to by *pp. Note that this
+ *  will only work for Quantum-Safe key exchanges.
+ */
+int i2o_PublicKey(EVP_PKEY *a, unsigned char **pp);
+/* Note that this function does NOT transfer ownership of the buffer to the
+ * returned EVP_PKEY. The user must still free the memory pointed to by p. Note
+ * that this will only work for quantum-safe key exchanges.
+ */
+EVP_PKEY *o2i_PublicKey(int type, EVP_PKEY **a, const unsigned char *p,
+                        long length);
+
 EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
                         long length);
 int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);
 
+EVP_PKEY *d2i_KemInfo(int type, EVP_PKEY **a, const unsigned char **pp,
+                      long length);
+int i2d_KemInfo(EVP_PKEY *a, unsigned char **pp);
+
+EVP_PKEY *o2i_KemInfo(int type, EVP_PKEY **a, const unsigned char *p,
+                        long length);
+int i2o_KemInfo(EVP_PKEY *a, unsigned char **pp);
+
 EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
                          long length);
 EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
@@ -1005,6 +1262,7 @@ int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
                           int indent, ASN1_PCTX *pctx);
 
 int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);
+int EVP_PKEY_get_cms_digest_nid(EVP_PKEY *pkey, int *pnid);
 
 int EVP_CIPHER_type(const EVP_CIPHER *ctx);
 
@@ -1060,6 +1318,7 @@ void EVP_PBE_cleanup(void);
 # define ASN1_PKEY_CTRL_CMS_SIGN         0x5
 # define ASN1_PKEY_CTRL_CMS_ENVELOPE     0x7
 # define ASN1_PKEY_CTRL_CMS_RI_TYPE      0x8
+# define ASN1_PKEY_CTRL_CMS_MD_NID       0x9
 
 int EVP_PKEY_asn1_get_count(void);
 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);
@@ -1515,11 +1774,26 @@ void ERR_load_EVP_strings(void);
 # define EVP_F_EVP_PKEY_ENCRYPT                           105
 # define EVP_F_EVP_PKEY_ENCRYPT_INIT                      139
 # define EVP_F_EVP_PKEY_ENCRYPT_OLD                       152
+# define EVP_F_EVP_PKEY_GET1_CMC                          182
 # define EVP_F_EVP_PKEY_GET1_DH                           119
+# define EVP_F_EVP_PKEY_GET1_DILITHIUM                    183
 # define EVP_F_EVP_PKEY_GET1_DSA                          120
 # define EVP_F_EVP_PKEY_GET1_ECDSA                        130
 # define EVP_F_EVP_PKEY_GET1_EC_KEY                       131
+# define EVP_F_EVP_PKEY_GET1_FRODODH                      184
+# define EVP_F_EVP_PKEY_GET1_FRODOKEM                     185
+# define EVP_F_EVP_PKEY_GET1_HSS                          186
+# define EVP_F_EVP_PKEY_GET1_KYBER                        187
+# define EVP_F_EVP_PKEY_GET1_NHDH                         188
+# define EVP_F_EVP_PKEY_GET1_NTRUP                        189
+# define EVP_F_EVP_PKEY_GET1_RAINBOW                      190
 # define EVP_F_EVP_PKEY_GET1_RSA                          121
+# define EVP_F_EVP_PKEY_GET1_SAMWISE                      196
+# define EVP_F_EVP_PKEY_GET1_SIDH                         191
+# define EVP_F_EVP_PKEY_GET1_SIKE                         192
+# define EVP_F_EVP_PKEY_GET1_SPHINCS                      193
+# define EVP_F_EVP_PKEY_GET1_XMSS                         194
+# define EVP_F_EVP_PKEY_GET1_XMSSMT                       195
 # define EVP_F_EVP_PKEY_KEYGEN                            146
 # define EVP_F_EVP_PKEY_KEYGEN_INIT                       147
 # define EVP_F_EVP_PKEY_NEW                               106
@@ -1574,11 +1848,26 @@ void ERR_load_EVP_strings(void);
 # define EVP_R_ERROR_LOADING_SECTION                      165
 # define EVP_R_ERROR_SETTING_FIPS_MODE                    166
 # define EVP_R_EVP_PBE_CIPHERINIT_ERROR                   119
+# define EVP_R_EXPECTING_AN_FRODODH_KEY                   172
+# define EVP_R_EXPECTING_AN_HSS_KEY                       173
+# define EVP_R_EXPECTING_AN_NHDH_KEY                      174
 # define EVP_R_EXPECTING_AN_RSA_KEY                       127
+# define EVP_R_EXPECTING_AN_SAMWISE_KEY                   186
+# define EVP_R_EXPECTING_AN_XMSSMT_KEY                    175
+# define EVP_R_EXPECTING_AN_XMSS_KEY                      176
+# define EVP_R_EXPECTING_A_CMC_KEY                        177
 # define EVP_R_EXPECTING_A_DH_KEY                         128
+# define EVP_R_EXPECTING_A_DILITHIUM_KEY                  178
 # define EVP_R_EXPECTING_A_DSA_KEY                        129
 # define EVP_R_EXPECTING_A_ECDSA_KEY                      141
 # define EVP_R_EXPECTING_A_EC_KEY                         142
+# define EVP_R_EXPECTING_A_FRODOKEM_KEY                   179
+# define EVP_R_EXPECTING_A_KYBER_KEY                      180
+# define EVP_R_EXPECTING_A_NTRUP_KEY                      181
+# define EVP_R_EXPECTING_A_RAINBOW_KEY                    182
+# define EVP_R_EXPECTING_A_SIDH_KEY                       183
+# define EVP_R_EXPECTING_A_SIKE_KEY                       184
+# define EVP_R_EXPECTING_A_SPHINCS_KEY                    185
 # define EVP_R_FIPS_MODE_NOT_SUPPORTED                    167
 # define EVP_R_INITIALIZATION_ERROR                       134
 # define EVP_R_INPUT_NOT_INITIALIZED                      111
diff --git a/openssl-1.0.2r/crypto/evp/evp_err.c b/openssl-1.0.2r/crypto/evp/evp_err.c
index 11647b92..85a1582d 100644
--- a/openssl-1.0.2r/crypto/evp/evp_err.c
+++ b/openssl-1.0.2r/crypto/evp/evp_err.c
@@ -118,11 +118,26 @@ static ERR_STRING_DATA EVP_str_functs[] = {
     {ERR_FUNC(EVP_F_EVP_PKEY_ENCRYPT), "EVP_PKEY_encrypt"},
     {ERR_FUNC(EVP_F_EVP_PKEY_ENCRYPT_INIT), "EVP_PKEY_encrypt_init"},
     {ERR_FUNC(EVP_F_EVP_PKEY_ENCRYPT_OLD), "EVP_PKEY_encrypt_old"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_CMC), "EVP_PKEY_get1_CMC"},
     {ERR_FUNC(EVP_F_EVP_PKEY_GET1_DH), "EVP_PKEY_get1_DH"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_DILITHIUM), "EVP_PKEY_get1_DILITHIUM"},
     {ERR_FUNC(EVP_F_EVP_PKEY_GET1_DSA), "EVP_PKEY_get1_DSA"},
     {ERR_FUNC(EVP_F_EVP_PKEY_GET1_ECDSA), "EVP_PKEY_GET1_ECDSA"},
     {ERR_FUNC(EVP_F_EVP_PKEY_GET1_EC_KEY), "EVP_PKEY_get1_EC_KEY"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_FRODODH), "EVP_PKEY_get1_FRODODH"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_FRODOKEM), "EVP_PKEY_get1_FRODOKEM"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_HSS), "EVP_PKEY_get1_HSS"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_KYBER), "EVP_PKEY_get1_KYBER"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_NHDH), "EVP_PKEY_GET1_NHDH"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_NTRUP), "EVP_PKEY_get1_NTRUP"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_RAINBOW), "EVP_PKEY_get1_RAINBOW"},
     {ERR_FUNC(EVP_F_EVP_PKEY_GET1_RSA), "EVP_PKEY_get1_RSA"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_SAMWISE), "EVP_PKEY_get1_SAMWISE"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_SIDH), "EVP_PKEY_get1_SIDH"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_SIKE), "EVP_PKEY_get1_SIKE"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_SPHINCS), "EVP_PKEY_get1_SPHINCS"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_XMSS), "EVP_PKEY_get1_XMSS"},
+    {ERR_FUNC(EVP_F_EVP_PKEY_GET1_XMSSMT), "EVP_PKEY_get1_XMSSMT"},
     {ERR_FUNC(EVP_F_EVP_PKEY_KEYGEN), "EVP_PKEY_keygen"},
     {ERR_FUNC(EVP_F_EVP_PKEY_KEYGEN_INIT), "EVP_PKEY_keygen_init"},
     {ERR_FUNC(EVP_F_EVP_PKEY_NEW), "EVP_PKEY_new"},
@@ -184,11 +199,27 @@ static ERR_STRING_DATA EVP_str_reasons[] = {
     {ERR_REASON(EVP_R_ERROR_LOADING_SECTION), "error loading section"},
     {ERR_REASON(EVP_R_ERROR_SETTING_FIPS_MODE), "error setting fips mode"},
     {ERR_REASON(EVP_R_EVP_PBE_CIPHERINIT_ERROR), "evp pbe cipherinit error"},
+    {ERR_REASON(EVP_R_EXPECTING_AN_FRODODH_KEY), "expecting an frododh key"},
+    {ERR_REASON(EVP_R_EXPECTING_AN_HSS_KEY), "expecting an hss key"},
+    {ERR_REASON(EVP_R_EXPECTING_AN_NHDH_KEY), "expecting an nhdh key"},
     {ERR_REASON(EVP_R_EXPECTING_AN_RSA_KEY), "expecting an rsa key"},
+    {ERR_REASON(EVP_R_EXPECTING_AN_SAMWISE_KEY), "expecting an samwise key"},
+    {ERR_REASON(EVP_R_EXPECTING_AN_XMSSMT_KEY), "expecting an xmssmt key"},
+    {ERR_REASON(EVP_R_EXPECTING_AN_XMSS_KEY), "expecting an xmss key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_CMC_KEY), "expecting a cmc key"},
     {ERR_REASON(EVP_R_EXPECTING_A_DH_KEY), "expecting a dh key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_DILITHIUM_KEY),
+     "expecting a dilithium key"},
     {ERR_REASON(EVP_R_EXPECTING_A_DSA_KEY), "expecting a dsa key"},
     {ERR_REASON(EVP_R_EXPECTING_A_ECDSA_KEY), "expecting a ecdsa key"},
     {ERR_REASON(EVP_R_EXPECTING_A_EC_KEY), "expecting a ec key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_FRODOKEM_KEY), "expecting a frodokem key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_KYBER_KEY), "expecting a kyber key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_NTRUP_KEY), "expecting a ntrup key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_RAINBOW_KEY), "expecting a rainbow key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_SIDH_KEY), "expecting a sidh key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_SIKE_KEY), "expecting a sike key"},
+    {ERR_REASON(EVP_R_EXPECTING_A_SPHINCS_KEY), "expecting a sphincs key"},
     {ERR_REASON(EVP_R_FIPS_MODE_NOT_SUPPORTED), "fips mode not supported"},
     {ERR_REASON(EVP_R_INITIALIZATION_ERROR), "initialization error"},
     {ERR_REASON(EVP_R_INPUT_NOT_INITIALIZED), "input not initialized"},
diff --git a/openssl-1.0.2r/crypto/evp/p_lib.c b/openssl-1.0.2r/crypto/evp/p_lib.c
index 545d04fd..93c20f16 100644
--- a/openssl-1.0.2r/crypto/evp/p_lib.c
+++ b/openssl-1.0.2r/crypto/evp/p_lib.c
@@ -73,7 +73,51 @@
 #ifndef OPENSSL_NO_DH
 # include <openssl/dh.h>
 #endif
-
+#ifndef OPENSSL_NO_HSS
+# include <openssl/hss.h>
+#endif
+#ifndef OPENSSL_NO_XMSS
+# include <openssl/xmss.h>
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+# include <openssl/xmssmt.h>
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+# include <openssl/sphincs.h>
+#endif
+#ifndef OPENSSL_NO_FRODODH
+# include <openssl/frododh.h>
+#endif
+#ifndef OPENSSL_NO_SAMWISE
+# include <openssl/samwise.h>
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+# include <openssl/rainbow.h>
+#endif
+#ifndef OPENSSL_NO_CMC
+# include <openssl/cmc.h>
+#endif
+#ifndef OPENSSL_NO_NTRUP
+# include <openssl/ntrup.h>
+#endif
+#ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+#endif
+#ifndef OPENSSL_NO_FRODOKEM
+# include <openssl/frodokem.h>
+#endif
+#ifndef OPENSSL_NO_NHDH
+# include <openssl/nhdh.h>
+#endif
+#ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+#endif
+#ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+#endif
 #ifndef OPENSSL_NO_ENGINE
 # include <openssl/engine.h>
 #endif
@@ -312,6 +356,306 @@ DSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
 }
 #endif
 
+#ifndef OPENSSL_NO_HSS
+int EVP_PKEY_set1_HSS(EVP_PKEY *pkey, HSS *key)
+{
+    int ret = EVP_PKEY_assign_HSS(pkey, key);
+    if (ret)
+        HSS_up_ref(key);
+    return ret;
+}
+
+HSS *EVP_PKEY_get1_HSS(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_HSS) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_HSS, EVP_R_EXPECTING_AN_HSS_KEY);
+        return NULL;
+    }
+    HSS_up_ref(pkey->pkey.hss);
+    return pkey->pkey.hss;
+}
+#endif
+
+#ifndef OPENSSL_NO_XMSS
+int EVP_PKEY_set1_XMSS(EVP_PKEY *pkey, XMSS *key)
+{
+    int ret = EVP_PKEY_assign_XMSS(pkey, key);
+    if (ret)
+        XMSS_up_ref(key);
+    return ret;
+}
+
+XMSS *EVP_PKEY_get1_XMSS(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_XMSS) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_XMSS, EVP_R_EXPECTING_AN_XMSS_KEY);
+        return NULL;
+    }
+    XMSS_up_ref(pkey->pkey.xmss);
+    return pkey->pkey.xmss;
+}
+#endif
+
+#ifndef OPENSSL_NO_XMSSMT
+int EVP_PKEY_set1_XMSSMT(EVP_PKEY *pkey, XMSSMT *key)
+{
+    int ret = EVP_PKEY_assign_XMSSMT(pkey, key);
+    if (ret)
+        XMSSMT_up_ref(key);
+    return ret;
+}
+
+XMSSMT *EVP_PKEY_get1_XMSSMT(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_XMSSMT) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_XMSSMT, EVP_R_EXPECTING_AN_XMSSMT_KEY);
+        return NULL;
+    }
+    XMSSMT_up_ref(pkey->pkey.xmssmt);
+    return pkey->pkey.xmssmt;
+}
+#endif
+
+#ifndef OPENSSL_NO_DILITHIUM
+int EVP_PKEY_set1_DILITHIUM(EVP_PKEY *pkey, DILITHIUM *key)
+{
+    int ret = EVP_PKEY_assign_DILITHIUM(pkey, key);
+    if (ret)
+        DILITHIUM_up_ref(key);
+    return ret;
+}
+
+DILITHIUM *EVP_PKEY_get1_DILITHIUM(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_DILITHIUM) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_DILITHIUM, EVP_R_EXPECTING_A_DILITHIUM_KEY);
+        return NULL;
+    }
+    DILITHIUM_up_ref(pkey->pkey.dilithium);
+    return pkey->pkey.dilithium;
+}
+#endif
+
+#ifndef OPENSSL_NO_SPHINCS
+int EVP_PKEY_set1_SPHINCS(EVP_PKEY *pkey, SPHINCS *key)
+{
+    int ret = EVP_PKEY_assign_SPHINCS(pkey, key);
+    if (ret)
+        SPHINCS_up_ref(key);
+    return ret;
+}
+
+SPHINCS *EVP_PKEY_get1_SPHINCS(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_SPHINCS) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_SPHINCS, EVP_R_EXPECTING_A_SPHINCS_KEY);
+        return NULL;
+    }
+    SPHINCS_up_ref(pkey->pkey.sphincs);
+    return pkey->pkey.sphincs;
+}
+#endif
+
+#ifndef OPENSSL_NO_RAINBOW
+int EVP_PKEY_set1_RAINBOW(EVP_PKEY *pkey, RAINBOW *key)
+{
+    int ret = EVP_PKEY_assign_RAINBOW(pkey, key);
+    if (ret)
+        RAINBOW_up_ref(key);
+    return ret;
+}
+
+RAINBOW *EVP_PKEY_get1_RAINBOW(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_RAINBOW) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_RAINBOW, EVP_R_EXPECTING_A_RAINBOW_KEY);
+        return NULL;
+    }
+    RAINBOW_up_ref(pkey->pkey.rainbow);
+    return pkey->pkey.rainbow;
+}
+#endif
+
+#ifndef OPENSSL_NO_NHDH
+int EVP_PKEY_set1_NHDH(EVP_PKEY *pkey, NHDH *key)
+{
+    int ret = EVP_PKEY_assign_NHDH(pkey, key);
+    if (ret)
+        NHDH_up_ref(key);
+    return ret;
+}
+
+NHDH *EVP_PKEY_get1_NHDH(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_NHDH) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_NHDH, EVP_R_EXPECTING_AN_NHDH_KEY);
+        return NULL;
+    }
+    NHDH_up_ref(pkey->pkey.nhdh);
+    return pkey->pkey.nhdh;
+}
+#endif
+
+#ifndef OPENSSL_NO_FRODODH
+int EVP_PKEY_set1_FRODODH(EVP_PKEY *pkey, FRODODH *key)
+{
+    int ret = EVP_PKEY_assign_FRODODH(pkey, key);
+    if (ret)
+        FRODODH_up_ref(key);
+    return ret;
+}
+
+FRODODH *EVP_PKEY_get1_FRODODH(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_FRODODH) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_FRODODH, EVP_R_EXPECTING_AN_FRODODH_KEY);
+        return NULL;
+    }
+    FRODODH_up_ref(pkey->pkey.frododh);
+    return pkey->pkey.frododh;
+}
+#endif
+
+#ifndef OPENSSL_NO_SAMWISE
+int EVP_PKEY_set1_SAMWISE(EVP_PKEY *pkey, SAMWISE *key)
+{
+    int ret = EVP_PKEY_assign_SAMWISE(pkey, key);
+    if (ret)
+        SAMWISE_up_ref(key);
+    return ret;
+}
+
+SAMWISE *EVP_PKEY_get1_SAMWISE(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_SAMWISE) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_SAMWISE, EVP_R_EXPECTING_AN_SAMWISE_KEY);
+        return NULL;
+    }
+    SAMWISE_up_ref(pkey->pkey.samwise);
+    return pkey->pkey.samwise;
+}
+#endif
+
+#ifndef OPENSSL_NO_SIDH
+int EVP_PKEY_set1_SIDH(EVP_PKEY *pkey, SIDH *key)
+{
+    int ret = EVP_PKEY_assign_SIDH(pkey, key);
+    if (ret)
+        SIDH_up_ref(key);
+    return ret;
+}
+
+SIDH *EVP_PKEY_get1_SIDH(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_SIDH) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_SIDH, EVP_R_EXPECTING_A_SIDH_KEY);
+        return NULL;
+    }
+    SIDH_up_ref(pkey->pkey.sidh);
+    return pkey->pkey.sidh;
+}
+#endif
+
+#ifndef OPENSSL_NO_CMC
+int EVP_PKEY_set1_CMC(EVP_PKEY *pkey, CMC *key)
+{
+    int ret = EVP_PKEY_assign_CMC(pkey, key);
+    if (ret)
+        CMC_up_ref(key);
+    return ret;
+}
+
+CMC *EVP_PKEY_get1_CMC(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_CMC) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_CMC, EVP_R_EXPECTING_A_CMC_KEY);
+        return NULL;
+    }
+    CMC_up_ref(pkey->pkey.cmc);
+    return pkey->pkey.cmc;
+}
+#endif
+
+#ifndef OPENSSL_NO_NTRUP
+int EVP_PKEY_set1_NTRUP(EVP_PKEY *pkey, NTRUP *key)
+{
+    int ret = EVP_PKEY_assign_NTRUP(pkey, key);
+    if (ret)
+        NTRUP_up_ref(key);
+    return ret;
+}
+
+NTRUP *EVP_PKEY_get1_NTRUP(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_NTRUP) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_NTRUP, EVP_R_EXPECTING_A_NTRUP_KEY);
+        return NULL;
+    }
+    NTRUP_up_ref(pkey->pkey.ntrup);
+    return pkey->pkey.ntrup;
+}
+#endif
+
+#ifndef OPENSSL_NO_KYBER
+int EVP_PKEY_set1_KYBER(EVP_PKEY *pkey, KYBER *key)
+{
+    int ret = EVP_PKEY_assign_KYBER(pkey, key);
+    if (ret)
+        KYBER_up_ref(key);
+    return ret;
+}
+
+KYBER *EVP_PKEY_get1_KYBER(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_KYBER) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_KYBER, EVP_R_EXPECTING_A_KYBER_KEY);
+        return NULL;
+    }
+    KYBER_up_ref(pkey->pkey.kyber);
+    return pkey->pkey.kyber;
+}
+#endif
+
+#ifndef OPENSSL_NO_FRODOKEM
+int EVP_PKEY_set1_FRODOKEM(EVP_PKEY *pkey, FRODOKEM *key)
+{
+    int ret = EVP_PKEY_assign_FRODOKEM(pkey, key);
+    if (ret)
+        FRODOKEM_up_ref(key);
+    return ret;
+}
+
+FRODOKEM *EVP_PKEY_get1_FRODOKEM(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_FRODOKEM) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_FRODOKEM, EVP_R_EXPECTING_A_FRODOKEM_KEY);
+        return NULL;
+    }
+    FRODOKEM_up_ref(pkey->pkey.frodokem);
+    return pkey->pkey.frodokem;
+}
+#endif
+
+#ifndef OPENSSL_NO_SIKE
+int EVP_PKEY_set1_SIKE(EVP_PKEY *pkey, SIKE *key)
+{
+    int ret = EVP_PKEY_assign_SIKE(pkey, key);
+    if (ret)
+        SIKE_up_ref(key);
+    return ret;
+}
+
+SIKE *EVP_PKEY_get1_SIKE(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_SIKE) {
+        EVPerr(EVP_F_EVP_PKEY_GET1_SIKE, EVP_R_EXPECTING_A_SIKE_KEY);
+        return NULL;
+    }
+    SIKE_up_ref(pkey->pkey.sike);
+    return pkey->pkey.sike;
+}
+#endif
+
 #ifndef OPENSSL_NO_EC
 
 int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key)
@@ -462,3 +806,11 @@ int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid)
     return pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_DEFAULT_MD_NID,
                                   0, pnid);
 }
+
+int EVP_PKEY_get_cms_digest_nid(EVP_PKEY *pkey, int *pnid)
+{
+    if (!pkey->ameth || !pkey->ameth->pkey_ctrl)
+        return -2;
+    return pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_MD_NID,
+                                  0, pnid);
+}
diff --git a/openssl-1.0.2r/crypto/frododh/Makefile b/openssl-1.0.2r/crypto/frododh/Makefile
new file mode 100644
index 00000000..69896517
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frododh/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/frododh/Makefile
+#
+
+DIR=	frododh
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= frododh_lib.c frododh_asn1.c frododh_err.c
+LIBOBJ= frododh_lib.o frododh_asn1.o frododh_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= frododh.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+frododh_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+frododh_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+frododh_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+frododh_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+frododh_asn1.o: ../../include/openssl/frododh.h ../../include/openssl/lhash.h
+frododh_asn1.o: ../../include/openssl/opensslconf.h
+frododh_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+frododh_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+frododh_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+frododh_asn1.o: ../cryptlib.h frododh_asn1.c
+frododh_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+frododh_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+frododh_err.o: ../../include/openssl/err.h ../../include/openssl/frododh.h
+frododh_err.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+frododh_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+frododh_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+frododh_err.o: ../../include/openssl/symhacks.h frododh_err.c
+frododh_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+frododh_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+frododh_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+frododh_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+frododh_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+frododh_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+frododh_lib.o: ../../include/openssl/evp.h ../../include/openssl/frododh.h
+frododh_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+frododh_lib.o: ../../include/openssl/objects.h
+frododh_lib.o: ../../include/openssl/opensslconf.h
+frododh_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+frododh_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+frododh_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+frododh_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+frododh_lib.o: ../../include/openssl/x509_vfy.h ../cryptlib.h frododh_lib.c
diff --git a/openssl-1.0.2r/crypto/frododh/frododh.h b/openssl-1.0.2r/crypto/frododh/frododh.h
new file mode 100644
index 00000000..bdce115d
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frododh/frododh.h
@@ -0,0 +1,172 @@
+/* crypto/frododh/frododh.h loosly based crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_FRODODH_H
+# define HEADER_FRODODH_H
+
+# include <openssl/e_os2.h>
+
+# if defined(OPENSSL_NO_FRODODH)
+#  error FrodoDH Family is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_FRODODH_ROLE_SET      (EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_FRODODH_PARAMETER_SET (EVP_PKEY_ALG_CTRL + 2)
+
+#define FRODODH_976_AES_R2   1
+#define FRODODH_976_SHAKE_R2 2
+
+struct frododh_st {
+    /*
+     * This first variable is used to pick up errors where a FRODODH is passed
+     * instead of a EVP_PKEY
+     */
+    int pad;
+    long version;
+    int write_params;
+    unsigned int flags;
+
+    int nid;
+    int initiator;
+
+    /* After information generation, if I'm the initiator, then my_public_key
+     * will point to the public key created by libcrypto.  If I'm the responder,
+     * it will remain untouched.
+     *
+     * After secret generation, if I'm the initiator, then my_public_key will
+     * be untouched.  If I'm the responder, it will point to the public key
+     * created by libcrypto.
+     *
+     * Note that since libcrypto is providing what my_public_key points to,
+     * libcrypto will own that memory.  To be as explicit as possible, you, the
+     * user, are expected to not manage the memory.
+     */
+    ASN1_OCTET_STRING *my_public_key;
+
+    /* FRODODH parameter.  Please see the spec. */
+    long parameter_set;
+
+    int references;
+
+    /* not sure we even need this */
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+FRODODH *FRODODH_new(void);
+FRODODH *FRODODH_new_with_engine(ENGINE *engine);
+void FRODODH_free(FRODODH *r);
+int FRODODH_up_ref(FRODODH *r);
+
+/* I don't think i2d and d2i are required as FRODODH enforces ephermeralness
+ * therefore nothing is to be saved. I don't think we need any of the
+ * ex_ stuff either.  No params, so no param printing either. 
+ * 
+ * On the other hand, public keys get passed around in TLS buffers and then
+ * then are supposed to be paired up with the peer key via
+ * EVP_PKEY_derive_set_peer().  This can only happen if the public key as a
+ * buffer can be transformed into a EVP_PKEY.  This would suggest that we
+ * require ameth methods for the public keys.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(FRODODH, FRODODHPublicKey)
+ */
+FRODODH *d2i_FRODODHPublicKey(FRODODH **a, const unsigned char **pp, long length);
+int i2d_FRODODHPublicKey(const FRODODH *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_FRODODH_strings(void);
+
+/* Error codes for the FRODODH functions. */
+
+/* Function codes. */
+# define FRODODH_F_FRODODH_NEW_WITH_ENGINE                          100
+
+/* Reason codes. */
+# define FRODODH_R_ENGINE_INIT_FAILURE                         100
+# define FRODODH_R_MALLOC_FAILURE                              101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/frododh/frododh_asn1.c b/openssl-1.0.2r/crypto/frododh/frododh_asn1.c
new file mode 100644
index 00000000..0448ebea
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frododh/frododh_asn1.c
@@ -0,0 +1,89 @@
+/* frododh_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/frododh.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int frododh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)FRODODH_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        FRODODH_free((FRODODH *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(FRODODHPublicKey, frododh_cb) = {
+        ASN1_SIMPLE(FRODODH, my_public_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(FRODODH, FRODODHPublicKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(FRODODH, FRODODHPublicKey, FRODODHPublicKey)
+
diff --git a/openssl-1.0.2r/crypto/frododh/frododh_err.c b/openssl-1.0.2r/crypto/frododh/frododh_err.c
new file mode 100644
index 00000000..ad1bff2d
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frododh/frododh_err.c
@@ -0,0 +1,94 @@
+/* crypto/frododh/frododh_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/frododh.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_FRODODH,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_FRODODH,0,reason)
+
+static ERR_STRING_DATA FRODODH_str_functs[] = {
+    {ERR_FUNC(FRODODH_F_FRODODH_NEW_WITH_ENGINE), "FRODODH_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA FRODODH_str_reasons[] = {
+    {ERR_REASON(FRODODH_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(FRODODH_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_FRODODH_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(FRODODH_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, FRODODH_str_functs);
+        ERR_load_strings(0, FRODODH_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/frododh/frododh_lib.c b/openssl-1.0.2r/crypto/frododh/frododh_lib.c
new file mode 100644
index 00000000..f215581a
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frododh/frododh_lib.c
@@ -0,0 +1,188 @@
+/* crypto/frododh/frododh_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/frododh.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char FRODODH_version[] = "FRODODH" OPENSSL_VERSION_PTEXT;
+
+FRODODH *FRODODH_new(void)
+{
+    return FRODODH_new_with_engine(NULL);
+}
+
+FRODODH *FRODODH_new_with_engine(ENGINE *engine)
+{
+    FRODODH *ret;
+
+    ret = (FRODODH *)OPENSSL_malloc(sizeof(FRODODH));
+    if (ret == NULL) {
+        FRODODHerr(FRODODH_F_FRODODH_NEW_WITH_ENGINE, FRODODH_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            FRODODHerr(FRODODH_F_FRODODH_NEW_WITH_ENGINE, FRODODH_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+
+    ret->nid = NID_undef;
+    ret->initiator = 0;
+    ret->my_public_key = NULL;
+    ret->parameter_set = -1;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_FRODODH, ret, &ret->ex_data);
+    return (ret);
+}
+
+void FRODODH_free(FRODODH *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_FRODODH);
+#ifdef REF_PRINT
+    REF_PRINT("FRODODH", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "FRODODH_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_FRODODH, r, &r->ex_data);
+
+    if (r->my_public_key != NULL)
+        ASN1_OCTET_STRING_free(r->my_public_key);
+
+    r->initiator = 0;
+    r->my_public_key = NULL;
+
+    OPENSSL_free(r);
+}
+
+int FRODODH_up_ref(FRODODH *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_FRODODH);
+#ifdef REF_PRINT
+    REF_PRINT("FRODODH", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "FRODODH_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int FRODODH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_FRODODH, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int FRODODH_set_ex_data(FRODODH *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *FRODODH_get_ex_data(FRODODH *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/frodokem/Makefile b/openssl-1.0.2r/crypto/frodokem/Makefile
new file mode 100644
index 00000000..2fa3be20
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frodokem/Makefile
@@ -0,0 +1,79 @@
+#
+# OpenSSL/crypto/frodokem/Makefile
+#
+
+DIR=	frodokem
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= frodokem_lib.c frodokem_asn1.c frodokem_err.c
+LIBOBJ= frodokem_lib.o frodokem_asn1.o frodokem_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= frodokem.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
diff --git a/openssl-1.0.2r/crypto/frodokem/frodokem.h b/openssl-1.0.2r/crypto/frodokem/frodokem.h
new file mode 100644
index 00000000..2998c93f
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frodokem/frodokem.h
@@ -0,0 +1,167 @@
+/* crypto/frodokem/frodokem.h loosly based off of crypto/rsa/rsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, FRODOKEM,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_FRODOKEM_H
+# define HEADER_FRODOKEM_H
+
+# include <openssl/asn1.h>
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+# ifdef OPENSSL_NO_FRODOKEM
+#  error FRODOKEM is disabled.
+# endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_FRODOKEM_PARAMETER_SET  (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string         "parameter_set"
+
+#define FRODOKEM_976_AES_R2   1
+#define FRODOKEM_976_SHAKE_R2 2
+
+
+/* Declared already in ossl_typ.h */
+/* typedef struct frodokem_st FRODOKEM; */
+
+struct frodokem_st {
+    /*
+     * The first parameter is used to pickup errors where this is passed
+     * instead of an EVP_PKEY, it is set to 0
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    ENGINE *engine;
+
+    /* FRODOKEM parameter.  Please see the spec. */
+    long parameter_set;
+
+    ASN1_OCTET_STRING *pub_key;                 /* public key */
+    ASN1_OCTET_STRING *priv_key;                /* private key */
+    ASN1_OCTET_STRING *kem_info;                /* KEM public info */
+    ASN1_OCTET_STRING *kem_shared_key;          /* KEM shared secret key */
+
+
+    /* not sure if we need this, keep it for now */
+    CRYPTO_EX_DATA ex_data;
+    int references;
+    int flags;
+};
+
+/* memory management methods for the FRODOKEM struct */
+FRODOKEM *FRODOKEM_new(void);
+FRODOKEM *FRODOKEM_new_with_engine(ENGINE *engine);
+void FRODOKEM_free(FRODOKEM *r);
+int FRODOKEM_up_ref(FRODOKEM *r);
+
+/* We will will need ASN1 because we will need the keys for encryption and
+ * decryption.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(FRODOKEM, FRODOKEMPublicKey)
+ */
+FRODOKEM *d2i_FRODOKEMPublicKey(FRODOKEM **a, const unsigned char **pp, long length);
+int i2d_FRODOKEMPublicKey(const FRODOKEM *a, unsigned char **pp);
+
+/* ASN.1 for public kem info
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(FRODOKEM, FRODOKEMKemInfo)
+ */
+FRODOKEM *d2i_FRODOKEMKemInfo(FRODOKEM **a, const unsigned char **pp, long length);
+int i2d_FRODOKEMKemInfo(const FRODOKEM *a, unsigned char **pp);
+
+/* ASN.1 for private key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(FRODOKEM, FRODOKEMPrivateKey)
+ */
+FRODOKEM *d2i_FRODOKEMPrivateKey(FRODOKEM **a, const unsigned char **pp, long length);
+int i2d_FRODOKEMPrivateKey(const FRODOKEM *a, unsigned char **pp);
+
+/* not sure if we need this, keep for now. */
+int FRODOKEM_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
+int FRODOKEM_set_ex_data(FRODOKEM *r, int idx, void *arg);
+void *FRODOKEM_get_ex_data(FRODOKEM *r, int idx);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_FRODOKEM_strings(void);
+
+/* Error codes for the FRODOKEM functions. */
+
+/* Function codes. */
+# define FRODOKEM_F_FRODOKEM_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define FRODOKEM_R_ENGINE_INIT_FAILURE                        100
+# define FRODOKEM_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/frodokem/frodokem_asn1.c b/openssl-1.0.2r/crypto/frodokem/frodokem_asn1.c
new file mode 100644
index 00000000..180083d8
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frodokem/frodokem_asn1.c
@@ -0,0 +1,125 @@
+/* frodokem_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/frodokem.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int frodokem_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)FRODOKEM_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        FRODOKEM_free((FRODOKEM *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(FRODOKEMPrivateKey, frodokem_cb) = {
+        ASN1_SIMPLE(FRODOKEM, version, LONG),
+        ASN1_SIMPLE(FRODOKEM, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(FRODOKEM, pub_key, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END_cb(FRODOKEM, FRODOKEMPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(FRODOKEM, FRODOKEMPrivateKey, FRODOKEMPrivateKey)
+
+FRODOKEM *d2i_FRODOKEMPublicKey(FRODOKEM **a, const unsigned char **pp, long length) {
+    FRODOKEM *frodokem = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    frodokem = FRODOKEM_new();
+    if (frodokem == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        FRODOKEM_free(frodokem);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            FRODOKEM_free(*a);
+        *a = frodokem;
+    }
+
+    frodokem->pub_key = pub_key;
+    return frodokem;
+}
+
+int i2d_FRODOKEMPublicKey(const FRODOKEM *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
+
+ASN1_SEQUENCE_cb(FRODOKEMKemInfo, frodokem_cb) = {
+        ASN1_SIMPLE(FRODOKEM, kem_info, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(FRODOKEM, FRODOKEMKemInfo)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(FRODOKEM, FRODOKEMKemInfo, FRODOKEMKemInfo)
+
diff --git a/openssl-1.0.2r/crypto/frodokem/frodokem_err.c b/openssl-1.0.2r/crypto/frodokem/frodokem_err.c
new file mode 100644
index 00000000..50344d13
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frodokem/frodokem_err.c
@@ -0,0 +1,94 @@
+/* crypto/frodokem/frodokem_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/frodokem.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_FRODOKEM,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_FRODOKEM,0,reason)
+
+static ERR_STRING_DATA FRODOKEM_str_functs[] = {
+    {ERR_FUNC(FRODOKEM_F_FRODOKEM_NEW_WITH_ENGINE), "FRODOKEM_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA FRODOKEM_str_reasons[] = {
+    {ERR_REASON(FRODOKEM_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(FRODOKEM_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_FRODOKEM_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(FRODOKEM_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, FRODOKEM_str_functs);
+        ERR_load_strings(0, FRODOKEM_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/frodokem/frodokem_lib.c b/openssl-1.0.2r/crypto/frodokem/frodokem_lib.c
new file mode 100644
index 00000000..4745eff0
--- /dev/null
+++ b/openssl-1.0.2r/crypto/frodokem/frodokem_lib.c
@@ -0,0 +1,194 @@
+/* crypto/frodokem/frodokem_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/frodokem.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char FRODOKEM_version[] = "FRODOKEM" OPENSSL_VERSION_PTEXT;
+
+FRODOKEM *FRODOKEM_new(void)
+{
+    return FRODOKEM_new_with_engine(NULL);
+}
+
+FRODOKEM *FRODOKEM_new_with_engine(ENGINE *engine)
+{
+    FRODOKEM *ret;
+
+    ret = (FRODOKEM *)OPENSSL_malloc(sizeof(FRODOKEM));
+    if (ret == NULL) {
+        FRODOKEMerr(FRODOKEM_F_FRODOKEM_NEW_WITH_ENGINE, FRODOKEM_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            FRODOKEMerr(FRODOKEM_F_FRODOKEM_NEW_WITH_ENGINE, FRODOKEM_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->references = 1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->kem_shared_key = NULL;
+    ret->kem_info = NULL;
+    ret->parameter_set = -1;
+
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_FRODOKEM, ret, &ret->ex_data);
+    return (ret);
+}
+
+void FRODOKEM_free(FRODOKEM *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_FRODOKEM);
+#ifdef REF_PRINT
+    REF_PRINT("FRODOKEM", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "FRODOKEM_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_FRODOKEM, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->kem_info != NULL)
+        ASN1_OCTET_STRING_free(r->kem_info);
+    if (r->kem_shared_key != NULL) {
+        OPENSSL_cleanse(r->kem_shared_key->data, (size_t)r->kem_shared_key->length);
+        ASN1_OCTET_STRING_free(r->kem_shared_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int FRODOKEM_up_ref(FRODOKEM *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_FRODOKEM);
+#ifdef REF_PRINT
+    REF_PRINT("FRODOKEM", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "FRODOKEM_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int FRODOKEM_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_FRODOKEM, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int FRODOKEM_set_ex_data(FRODOKEM *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *FRODOKEM_get_ex_data(FRODOKEM *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/hss/Makefile b/openssl-1.0.2r/crypto/hss/Makefile
new file mode 100644
index 00000000..bbba83b4
--- /dev/null
+++ b/openssl-1.0.2r/crypto/hss/Makefile
@@ -0,0 +1,110 @@
+#
+# OpenSSL/crypto/hss/Makefile
+#
+
+DIR=	hss
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= hss_lib.c hss_asn1.c hss_err.c
+LIBOBJ= hss_lib.o hss_asn1.o hss_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= hss.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+hss_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+hss_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+hss_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+hss_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+hss_asn1.o: ../../include/openssl/hss.h ../../include/openssl/lhash.h
+hss_asn1.o: ../../include/openssl/opensslconf.h
+hss_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+hss_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+hss_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+hss_asn1.o: ../cryptlib.h hss_asn1.c
+hss_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+hss_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+hss_err.o: ../../include/openssl/err.h ../../include/openssl/hss.h
+hss_err.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+hss_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+hss_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+hss_err.o: ../../include/openssl/symhacks.h hss_err.c
+hss_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+hss_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+hss_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+hss_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+hss_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+hss_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+hss_lib.o: ../../include/openssl/evp.h ../../include/openssl/hss.h
+hss_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+hss_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+hss_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+hss_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+hss_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+hss_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+hss_lib.o: ../../include/openssl/x509_vfy.h ../cryptlib.h hss_lib.c
diff --git a/openssl-1.0.2r/crypto/hss/hss.h b/openssl-1.0.2r/crypto/hss/hss.h
new file mode 100644
index 00000000..8b220d87
--- /dev/null
+++ b/openssl-1.0.2r/crypto/hss/hss.h
@@ -0,0 +1,185 @@
+/* crypto/hss/hss.h based off of crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_HSS_H
+# define HEADER_HSS_H
+
+# include <openssl/e_os2.h>
+
+# ifdef OPENSSL_NO_HSS
+#  error HSS is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define HSS_SECURITY_SIZE  64
+
+#define set_sign_operations_ctrl_string    "sign_operations"
+#define set_optimization_ctrl_string       "optimization"
+#define set_strategy_ctrl_string           "strategy"
+#define set_state_filename_ctrl_string     "state_filename"
+
+#define sigops_string_2e30                 "2E30"
+#define sigops_string_2e45                 "2E45"
+#define sigops_string_2e65                 "2E65"
+
+#define optimization_string_fast           "fast"
+#define optimization_string_small          "small"
+
+#define strategy_string_cpu_constrained    "cpu_constrained"
+#define strategy_string_memory_constrained "memory_constrained"
+#define strategy_string_full               "full"
+
+#define EVP_PKEY_CTRL_HSS_SIGOPS_SET       (EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_HSS_OPTIMIZATION_SET (EVP_PKEY_ALG_CTRL + 2)
+#define EVP_PKEY_CTRL_HSS_STRATEGY_SET     (EVP_PKEY_ALG_CTRL + 3)
+
+#define HSS_SIGOPS_2E30                    1
+#define HSS_SIGOPS_2E45                    2
+#define HSS_SIGOPS_2E65                    3
+
+#define HSS_OPTIMIZATION_FAST              1
+#define HSS_OPTIMIZATION_SMALL             2
+
+#define HSS_STRATEGY_CPU_CONSTRAINED       1
+#define HSS_STRATEGY_MEMORY_CONSTRAINED    2
+#define HSS_STRATEGY_FULL                  3
+
+struct hss_st {
+    /* This first variable is used to pick up errors where a HSS is passed
+     * instead of a EVP_PKEY. These first 2 members are standard for all
+     *  the algorithms.
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    long sig_ops;
+    long optimization;
+
+    /* public key */
+    ASN1_OCTET_STRING *pub_key;
+    /* private key */
+    ASN1_OCTET_STRING *priv_key;
+    /* private key state */
+    ASN1_OCTET_STRING *priv_state;
+    /* tree strategy */
+    long strategy;
+
+    /* private key state filename */
+    char *state_filename;
+
+    int flags;
+    int references;
+
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+/* memory management methods for the HSS struct */
+HSS *HSS_new(void);
+HSS *HSS_new_with_engine(ENGINE *engine);
+void HSS_free(HSS *r);
+int HSS_up_ref(HSS *r);
+
+/* ASN.1 for public key */
+HSS *d2i_HSSPublicKey(HSS **a, const unsigned char **pp, long length);
+int i2d_HSSPublicKey(const HSS *a, unsigned char **pp);
+
+/* ASN.1 for private key */
+HSS *d2i_HSSPrivateKey(HSS **a, const unsigned char **pp, long length);
+int i2d_HSSPrivateKey(const HSS *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_HSS_strings(void);
+
+/* Error codes for the HSS functions. */
+
+/* Function codes. */
+# define HSS_F_HSS_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define HSS_R_ENGINE_INIT_FAILURE                        100
+# define HSS_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/hss/hss_asn1.c b/openssl-1.0.2r/crypto/hss/hss_asn1.c
new file mode 100644
index 00000000..3c3c7e22
--- /dev/null
+++ b/openssl-1.0.2r/crypto/hss/hss_asn1.c
@@ -0,0 +1,122 @@
+/* hss_asn1.c based off of dsa_asn1.c */
+
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/hss.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int hss_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)HSS_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        HSS_free((HSS *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(HSSPrivateKey, hss_cb) = {
+        ASN1_SIMPLE(HSS, version, LONG),
+        ASN1_SIMPLE(HSS, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(HSS, sig_ops, LONG),
+        ASN1_SIMPLE(HSS, optimization, LONG),
+        ASN1_SIMPLE(HSS, strategy, LONG),
+        ASN1_SIMPLE(HSS, pub_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(HSS, HSSPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(HSS, HSSPrivateKey, HSSPrivateKey)
+
+HSS *d2i_HSSPublicKey(HSS **a, const unsigned char **pp, long length) {
+    HSS *hss = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    hss = HSS_new();
+    if (hss == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        HSS_free(hss);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            HSS_free(*a);
+        *a = hss;
+    }
+
+    hss->pub_key = pub_key;
+    return hss;
+}
+
+int i2d_HSSPublicKey(const HSS *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
diff --git a/openssl-1.0.2r/crypto/hss/hss_err.c b/openssl-1.0.2r/crypto/hss/hss_err.c
new file mode 100644
index 00000000..6168d092
--- /dev/null
+++ b/openssl-1.0.2r/crypto/hss/hss_err.c
@@ -0,0 +1,94 @@
+/* crypto/hss/hss_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2017 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/hss.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_HSS,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_HSS,0,reason)
+
+static ERR_STRING_DATA HSS_str_functs[] = {
+    {ERR_FUNC(HSS_F_HSS_NEW_WITH_ENGINE), "HSS_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA HSS_str_reasons[] = {
+    {ERR_REASON(HSS_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(HSS_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_HSS_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(HSS_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, HSS_str_functs);
+        ERR_load_strings(0, HSS_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/hss/hss_lib.c b/openssl-1.0.2r/crypto/hss/hss_lib.c
new file mode 100644
index 00000000..9d8c17cd
--- /dev/null
+++ b/openssl-1.0.2r/crypto/hss/hss_lib.c
@@ -0,0 +1,184 @@
+/* crypto/hss/hss_lib.c based off of crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/hss.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char HSS_version[] = "HSS" OPENSSL_VERSION_PTEXT;
+
+
+HSS *HSS_new(void) {
+    return HSS_new_with_engine(NULL);
+}
+
+HSS *HSS_new_with_engine(ENGINE *engine)
+{
+    HSS *ret;
+
+    ret = (HSS *)OPENSSL_malloc(sizeof(HSS));
+    if (ret == NULL) {
+        HSSerr(HSS_F_HSS_NEW_WITH_ENGINE, HSS_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            HSSerr(HSS_F_HSS_NEW_WITH_ENGINE, HSS_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->priv_state = NULL;
+    ret->strategy = -1;
+    ret->sig_ops = -1;
+    ret->optimization = -1;
+    ret->state_filename = NULL;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_HSS, ret, &ret->ex_data);
+    return (ret);
+}
+
+void HSS_free(HSS *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_HSS);
+#ifdef REF_PRINT
+    REF_PRINT("HSS", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "HSS_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+#ifndef OPENSSL_NO_ENGINE
+    if (r->engine)
+        ENGINE_finish(r->engine);
+#endif
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_HSS, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->priv_state != NULL) {
+        OPENSSL_cleanse(r->priv_state->data, (size_t)r->priv_state->length);
+        ASN1_OCTET_STRING_free(r->priv_state);
+    }
+    if (r->state_filename != NULL) {
+        OPENSSL_free(r->state_filename);
+    }
+    r->strategy = -1;
+
+    OPENSSL_free(r);
+}
+
+int HSS_up_ref(HSS *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_HSS);
+#ifdef REF_PRINT
+    REF_PRINT("HSS", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "HSS_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
diff --git a/openssl-1.0.2r/crypto/kyber/Makefile b/openssl-1.0.2r/crypto/kyber/Makefile
new file mode 100644
index 00000000..69cc2f84
--- /dev/null
+++ b/openssl-1.0.2r/crypto/kyber/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/kyber/Makefile
+#
+
+DIR=	kyber
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= kyber_lib.c kyber_asn1.c kyber_err.c
+LIBOBJ= kyber_lib.o kyber_asn1.o kyber_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= kyber.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+kyber_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+kyber_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+kyber_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+kyber_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+kyber_asn1.o: ../../include/openssl/kyber.h ../../include/openssl/lhash.h
+kyber_asn1.o: ../../include/openssl/opensslconf.h
+kyber_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+kyber_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+kyber_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+kyber_asn1.o: ../cryptlib.h kyber_asn1.c
+kyber_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+kyber_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+kyber_err.o: ../../include/openssl/err.h ../../include/openssl/kyber.h
+kyber_err.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+kyber_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+kyber_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+kyber_err.o: ../../include/openssl/symhacks.h kyber_err.c
+kyber_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+kyber_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+kyber_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+kyber_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+kyber_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+kyber_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+kyber_lib.o: ../../include/openssl/evp.h ../../include/openssl/kyber.h
+kyber_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+kyber_lib.o: ../../include/openssl/objects.h
+kyber_lib.o: ../../include/openssl/opensslconf.h
+kyber_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+kyber_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+kyber_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+kyber_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+kyber_lib.o: ../../include/openssl/x509_vfy.h ../cryptlib.h kyber_lib.c
diff --git a/openssl-1.0.2r/crypto/kyber/kyber.h b/openssl-1.0.2r/crypto/kyber/kyber.h
new file mode 100644
index 00000000..c131e1f5
--- /dev/null
+++ b/openssl-1.0.2r/crypto/kyber/kyber.h
@@ -0,0 +1,166 @@
+/* crypto/kyber/kyber.h loosly based off of crypto/rsa/rsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, KYBER,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_KYBER_H
+# define HEADER_KYBER_H
+
+# include <openssl/asn1.h>
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+# ifdef OPENSSL_NO_KYBER
+#  error KYBER is disabled.
+# endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_KYBER_PARAMETER_SET  (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string      "parameter_set"
+
+#define KYBER_768_R2  1
+#define KYBER_1024_R2 2
+
+/* Declared already in ossl_typ.h */
+/* typedef struct kyber_st KYBER; */
+
+struct kyber_st {
+    /*
+     * The first parameter is used to pickup errors where this is passed
+     * instead of an EVP_PKEY, it is set to 0
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    ENGINE *engine;
+
+    /* KYBER parameter.  Please see the spec. */
+    long parameter_set;
+
+    ASN1_OCTET_STRING *pub_key;                 /* public key */
+    ASN1_OCTET_STRING *priv_key;                /* private key */
+    ASN1_OCTET_STRING *kem_info;                /* KEM public info */
+    ASN1_OCTET_STRING *kem_shared_key;          /* KEM shared secret key */
+
+
+    /* not sure if we need this, keep it for now */
+    CRYPTO_EX_DATA ex_data;
+    int references;
+    int flags;
+};
+
+/* memory management methods for the KYBER struct */
+KYBER *KYBER_new(void);
+KYBER *KYBER_new_with_engine(ENGINE *engine);
+void KYBER_free(KYBER *r);
+int KYBER_up_ref(KYBER *r);
+
+/* We will will need ASN1 because we will need the keys for encryption and
+ * decryption.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(KYBER, KYBERPublicKey)
+ */
+KYBER *d2i_KYBERPublicKey(KYBER **a, const unsigned char **pp, long length);
+int i2d_KYBERPublicKey(const KYBER *a, unsigned char **pp);
+
+/* ASN.1 for public kem info
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(KYBER, KYBERKemInfo)
+ */
+KYBER *d2i_KYBERKemInfo(KYBER **a, const unsigned char **pp, long length);
+int i2d_KYBERKemInfo(const KYBER *a, unsigned char **pp);
+
+/* ASN.1 for private key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(KYBER, KYBERPrivateKey)
+ */
+KYBER *d2i_KYBERPrivateKey(KYBER **a, const unsigned char **pp, long length);
+int i2d_KYBERPrivateKey(const KYBER *a, unsigned char **pp);
+
+/* not sure if we need this, keep for now. */
+int KYBER_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
+int KYBER_set_ex_data(KYBER *r, int idx, void *arg);
+void *KYBER_get_ex_data(KYBER *r, int idx);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_KYBER_strings(void);
+
+/* Error codes for the KYBER functions. */
+
+/* Function codes. */
+# define KYBER_F_KYBER_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define KYBER_R_ENGINE_INIT_FAILURE                        100
+# define KYBER_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/kyber/kyber_asn1.c b/openssl-1.0.2r/crypto/kyber/kyber_asn1.c
new file mode 100644
index 00000000..b6e6a822
--- /dev/null
+++ b/openssl-1.0.2r/crypto/kyber/kyber_asn1.c
@@ -0,0 +1,125 @@
+/* kyber_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/kyber.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int kyber_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)KYBER_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        KYBER_free((KYBER *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(KYBERPrivateKey, kyber_cb) = {
+        ASN1_SIMPLE(KYBER, version, LONG),
+        ASN1_SIMPLE(KYBER, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(KYBER, pub_key, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END_cb(KYBER, KYBERPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(KYBER, KYBERPrivateKey, KYBERPrivateKey)
+
+KYBER *d2i_KYBERPublicKey(KYBER **a, const unsigned char **pp, long length) {
+    KYBER *kyber = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    kyber = KYBER_new();
+    if (kyber == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        KYBER_free(kyber);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            KYBER_free(*a);
+        *a = kyber;
+    }
+
+    kyber->pub_key = pub_key;
+    return kyber;
+}
+
+int i2d_KYBERPublicKey(const KYBER *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
+
+ASN1_SEQUENCE_cb(KYBERKemInfo, kyber_cb) = {
+        ASN1_SIMPLE(KYBER, kem_info, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(KYBER, KYBERKemInfo)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(KYBER, KYBERKemInfo, KYBERKemInfo)
+
diff --git a/openssl-1.0.2r/crypto/kyber/kyber_err.c b/openssl-1.0.2r/crypto/kyber/kyber_err.c
new file mode 100644
index 00000000..17b400ed
--- /dev/null
+++ b/openssl-1.0.2r/crypto/kyber/kyber_err.c
@@ -0,0 +1,94 @@
+/* crypto/kyber/kyber_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/kyber.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_KYBER,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_KYBER,0,reason)
+
+static ERR_STRING_DATA KYBER_str_functs[] = {
+    {ERR_FUNC(KYBER_F_KYBER_NEW_WITH_ENGINE), "KYBER_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA KYBER_str_reasons[] = {
+    {ERR_REASON(KYBER_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(KYBER_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_KYBER_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(KYBER_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, KYBER_str_functs);
+        ERR_load_strings(0, KYBER_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/kyber/kyber_lib.c b/openssl-1.0.2r/crypto/kyber/kyber_lib.c
new file mode 100644
index 00000000..79f311eb
--- /dev/null
+++ b/openssl-1.0.2r/crypto/kyber/kyber_lib.c
@@ -0,0 +1,194 @@
+/* crypto/kyber/kyber_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/kyber.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char KYBER_version[] = "KYBER" OPENSSL_VERSION_PTEXT;
+
+KYBER *KYBER_new(void)
+{
+    return KYBER_new_with_engine(NULL);
+}
+
+KYBER *KYBER_new_with_engine(ENGINE *engine)
+{
+    KYBER *ret;
+
+    ret = (KYBER *)OPENSSL_malloc(sizeof(KYBER));
+    if (ret == NULL) {
+        KYBERerr(KYBER_F_KYBER_NEW_WITH_ENGINE, KYBER_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            KYBERerr(KYBER_F_KYBER_NEW_WITH_ENGINE, KYBER_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->references = 1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->kem_shared_key = NULL;
+    ret->kem_info = NULL;
+    ret->parameter_set = -1;
+
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_KYBER, ret, &ret->ex_data);
+    return (ret);
+}
+
+void KYBER_free(KYBER *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_KYBER);
+#ifdef REF_PRINT
+    REF_PRINT("KYBER", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "KYBER_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_KYBER, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->kem_info != NULL)
+        ASN1_OCTET_STRING_free(r->kem_info);
+    if (r->kem_shared_key != NULL) {
+        OPENSSL_cleanse(r->kem_shared_key->data, (size_t)r->kem_shared_key->length);
+        ASN1_OCTET_STRING_free(r->kem_shared_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int KYBER_up_ref(KYBER *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_KYBER);
+#ifdef REF_PRINT
+    REF_PRINT("KYBER", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "KYBER_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int KYBER_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_KYBER, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int KYBER_set_ex_data(KYBER *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *KYBER_get_ex_data(KYBER *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/nhdh/Makefile b/openssl-1.0.2r/crypto/nhdh/Makefile
new file mode 100644
index 00000000..36ff6ed2
--- /dev/null
+++ b/openssl-1.0.2r/crypto/nhdh/Makefile
@@ -0,0 +1,93 @@
+#
+# OpenSSL/crypto/nhdh/Makefile
+#
+
+DIR=	nhdh
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= nhdh_lib.c nhdh_asn1.c nhdh_err.c
+LIBOBJ= nhdh_lib.o nhdh_asn1.o nhdh_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= nhdh.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+nhdh_lib.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
+nhdh_lib.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+nhdh_lib.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+nhdh_lib.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+nhdh_lib.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+nhdh_lib.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+nhdh_lib.o: ../../include/openssl/lhash.h ../../include/openssl/nhdh.h
+nhdh_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+nhdh_lib.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+nhdh_lib.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+nhdh_lib.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+nhdh_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+nhdh_lib.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+nhdh_lib.o: ../cryptlib.h nhdh_lib.c
diff --git a/openssl-1.0.2r/crypto/nhdh/nhdh.h b/openssl-1.0.2r/crypto/nhdh/nhdh.h
new file mode 100644
index 00000000..863988fe
--- /dev/null
+++ b/openssl-1.0.2r/crypto/nhdh/nhdh.h
@@ -0,0 +1,176 @@
+/* crypto/nhdh/nhdh.h loosly based crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_NHDH_H
+# define HEADER_NHDH_H
+
+# include <openssl/e_os2.h>
+
+# if defined(OPENSSL_NO_NHDH)
+#  error NewHope Family is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define set_parameter_set_ctrl_string "parameter_set"
+#define EVP_PKEY_CTRL_NHDH_ROLE_SET (EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_NHDH_PARAMETER_SET (EVP_PKEY_ALG_CTRL + 2)
+
+/*
+ * Although NHDH currently has only one parameter, the following macro is
+ * added to facilitate NHDH TLS parameter negotiation.
+ */
+#define NHDH_1024_V0 1
+
+struct nhdh_st {
+    /*
+     * This first variable is used to pick up errors where a NHDH is passed
+     * instead of a EVP_PKEY
+     */
+    int pad;
+    long version;
+    int write_params;
+    unsigned int flags;
+
+    int nid;
+    int initiator;
+
+    /* After information generation, if I'm the initiator, then my_public_key
+     * will point to the public key created by libcrypto.  If I'm the responder,
+     * it will remain untouched.
+     *
+     * After secret generation, if I'm the initiator, then my_public_key will
+     * be untouched.  If I'm the responder, it will point to the public key
+     * created by libcrypto.
+     *
+     * Note that since libcrypto is providing what my_public_key points to,
+     * libcrypto will own that memory.  To be as explicit as possible, you, the
+     * user, are expected to not manage the memory.
+     */
+    ASN1_OCTET_STRING *my_public_key;
+
+    /* NHDH parameter.  Please see the spec. */
+    long parameter_set;
+
+    int references;
+
+    /* not sure we even need this */
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+NHDH *NHDH_new(void);
+NHDH *NHDH_new_with_engine(ENGINE *engine);
+void NHDH_free(NHDH *r);
+int NHDH_up_ref(NHDH *r);
+
+/* I don't think i2d and d2i are required as NHDH enforces ephermeralness
+ * therefore nothing is to be saved. I don't think we need any of the
+ * ex_ stuff either.  No params, so no param printing either. 
+ * 
+ * On the other hand, public keys get passed around in TLS buffers and then
+ * then are supposed to be paired up with the peer key via
+ * EVP_PKEY_derive_set_peer().  This can only happen if the public key as a
+ * buffer can be transformed into a EVP_PKEY.  This would suggest that we
+ * require ameth methods for the public keys.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(NHDH, NHDHPublicKey)
+ */
+NHDH *d2i_NHDHPublicKey(NHDH **a, const unsigned char **pp, long length);
+int i2d_NHDHPublicKey(const NHDH *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_NHDH_strings(void);
+
+/* Error codes for the NHDH functions. */
+
+/* Function codes. */
+# define NHDH_F_NHDH_NEW_WITH_ENGINE                          100
+
+/* Reason codes. */
+# define NHDH_R_ENGINE_INIT_FAILURE                         100
+# define NHDH_R_MALLOC_FAILURE                              101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/nhdh/nhdh_asn1.c b/openssl-1.0.2r/crypto/nhdh/nhdh_asn1.c
new file mode 100644
index 00000000..5e72f843
--- /dev/null
+++ b/openssl-1.0.2r/crypto/nhdh/nhdh_asn1.c
@@ -0,0 +1,89 @@
+/* nhdh_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/nhdh.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int nhdh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)NHDH_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        NHDH_free((NHDH *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(NHDHPublicKey, nhdh_cb) = {
+        ASN1_SIMPLE(NHDH, my_public_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(NHDH, NHDHPublicKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(NHDH, NHDHPublicKey, NHDHPublicKey)
+
diff --git a/openssl-1.0.2r/crypto/nhdh/nhdh_err.c b/openssl-1.0.2r/crypto/nhdh/nhdh_err.c
new file mode 100644
index 00000000..d09560e2
--- /dev/null
+++ b/openssl-1.0.2r/crypto/nhdh/nhdh_err.c
@@ -0,0 +1,94 @@
+/* crypto/nhdh/nhdh_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/nhdh.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_NHDH,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_NHDH,0,reason)
+
+static ERR_STRING_DATA NHDH_str_functs[] = {
+    {ERR_FUNC(NHDH_F_NHDH_NEW_WITH_ENGINE), "NHDH_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA NHDH_str_reasons[] = {
+    {ERR_REASON(NHDH_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(NHDH_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_NHDH_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(NHDH_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, NHDH_str_functs);
+        ERR_load_strings(0, NHDH_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/nhdh/nhdh_lib.c b/openssl-1.0.2r/crypto/nhdh/nhdh_lib.c
new file mode 100644
index 00000000..d6cb8eb0
--- /dev/null
+++ b/openssl-1.0.2r/crypto/nhdh/nhdh_lib.c
@@ -0,0 +1,188 @@
+/* crypto/nhdh/nhdh_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/nhdh.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char NHDH_version[] = "NHDH" OPENSSL_VERSION_PTEXT;
+
+NHDH *NHDH_new(void)
+{
+    return NHDH_new_with_engine(NULL);
+}
+
+NHDH *NHDH_new_with_engine(ENGINE *engine)
+{
+    NHDH *ret;
+
+    ret = (NHDH *)OPENSSL_malloc(sizeof(NHDH));
+    if (ret == NULL) {
+        NHDHerr(NHDH_F_NHDH_NEW_WITH_ENGINE, NHDH_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            NHDHerr(NHDH_F_NHDH_NEW_WITH_ENGINE, NHDH_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+
+    ret->nid = NID_undef;
+    ret->initiator = 0;
+    ret->my_public_key = NULL;
+    ret->parameter_set = -1;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_NHDH, ret, &ret->ex_data);
+    return (ret);
+}
+
+void NHDH_free(NHDH *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_NHDH);
+#ifdef REF_PRINT
+    REF_PRINT("NHDH", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "NHDH_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_NHDH, r, &r->ex_data);
+
+    if (r->my_public_key != NULL)
+        ASN1_OCTET_STRING_free(r->my_public_key);
+
+    r->initiator = 0;
+    r->my_public_key = NULL;
+
+    OPENSSL_free(r);
+}
+
+int NHDH_up_ref(NHDH *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_NHDH);
+#ifdef REF_PRINT
+    REF_PRINT("NHDH", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "NHDH_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int NHDH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_NHDH, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int NHDH_set_ex_data(NHDH *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *NHDH_get_ex_data(NHDH *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/ntrup/Makefile b/openssl-1.0.2r/crypto/ntrup/Makefile
new file mode 100644
index 00000000..d53cdef6
--- /dev/null
+++ b/openssl-1.0.2r/crypto/ntrup/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/ntrup/Makefile
+#
+
+DIR=	ntrup
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= ntrup_lib.c ntrup_asn1.c ntrup_err.c
+LIBOBJ= ntrup_lib.o ntrup_asn1.o ntrup_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= ntrup.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+ntrup_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+ntrup_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+ntrup_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+ntrup_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+ntrup_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/ntrup.h
+ntrup_asn1.o: ../../include/openssl/opensslconf.h
+ntrup_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+ntrup_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+ntrup_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+ntrup_asn1.o: ../cryptlib.h ntrup_asn1.c
+ntrup_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+ntrup_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+ntrup_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+ntrup_err.o: ../../include/openssl/ntrup.h ../../include/openssl/opensslconf.h
+ntrup_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+ntrup_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+ntrup_err.o: ../../include/openssl/symhacks.h ntrup_err.c
+ntrup_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+ntrup_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+ntrup_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+ntrup_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+ntrup_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+ntrup_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+ntrup_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+ntrup_lib.o: ../../include/openssl/ntrup.h ../../include/openssl/obj_mac.h
+ntrup_lib.o: ../../include/openssl/objects.h
+ntrup_lib.o: ../../include/openssl/opensslconf.h
+ntrup_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+ntrup_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+ntrup_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+ntrup_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+ntrup_lib.o: ../../include/openssl/x509_vfy.h ../cryptlib.h ntrup_lib.c
diff --git a/openssl-1.0.2r/crypto/ntrup/ntrup.h b/openssl-1.0.2r/crypto/ntrup/ntrup.h
new file mode 100644
index 00000000..4e51fc25
--- /dev/null
+++ b/openssl-1.0.2r/crypto/ntrup/ntrup.h
@@ -0,0 +1,165 @@
+/* crypto/ntrup/ntrup.h loosly based off of crypto/rsa/rsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, NTRUP,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_NTRUP_H
+# define HEADER_NTRUP_H
+
+# include <openssl/asn1.h>
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+# ifdef OPENSSL_NO_NTRUP
+#  error NTRUP is disabled.
+# endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_NTRUP_PARAMETER_SET  (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string      "parameter_set"
+
+#define NTRUPRIME_SNTRUP761_R2 1
+
+/* Declared already in ossl_typ.h */
+/* typedef struct ntrup_st NTRUP; */
+
+struct ntrup_st {
+    /*
+     * The first parameter is used to pickup errors where this is passed
+     * instead of an EVP_PKEY, it is set to 0
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    ENGINE *engine;
+
+    ASN1_OCTET_STRING *pub_key;                 /* public key */
+    ASN1_OCTET_STRING *priv_key;                /* private key */
+    ASN1_OCTET_STRING *kem_info;                /* KEM public info */
+    ASN1_OCTET_STRING *kem_shared_key;          /* KEM shared secret key */
+
+    /* NTRUP parameter.  Please see the spec. */
+    long parameter_set;
+
+    /* not sure if we need this, keep it for now */
+    CRYPTO_EX_DATA ex_data;
+    int references;
+    int flags;
+};
+
+/* memory management methods for the NTRUP struct */
+NTRUP *NTRUP_new(void);
+NTRUP *NTRUP_new_with_engine(ENGINE *engine);
+void NTRUP_free(NTRUP *r);
+int NTRUP_up_ref(NTRUP *r);
+
+/* We will will need ASN1 because we will need the keys for encryption and
+ * decryption.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(NTRUP, NTRUPPublicKey)
+ */
+NTRUP *d2i_NTRUPPublicKey(NTRUP **a, const unsigned char **pp, long length);
+int i2d_NTRUPPublicKey(const NTRUP *a, unsigned char **pp);
+
+/* ASN.1 for public kem info
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(NTRUP, NTRUPKemInfo)
+ */
+NTRUP *d2i_NTRUPKemInfo(NTRUP **a, const unsigned char **pp, long length);
+int i2d_NTRUPKemInfo(const NTRUP *a, unsigned char **pp);
+
+
+/* ASN.1 for private key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(NTRUP, NTRUPPrivateKey)
+ */
+NTRUP *d2i_NTRUPPrivateKey(NTRUP **a, const unsigned char **pp, long length);
+int i2d_NTRUPPrivateKey(const NTRUP *a, unsigned char **pp);
+
+/* not sure if we need this, keep for now. */
+int NTRUP_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
+int NTRUP_set_ex_data(NTRUP *r, int idx, void *arg);
+void *NTRUP_get_ex_data(NTRUP *r, int idx);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_NTRUP_strings(void);
+
+/* Error codes for the NTRUP functions. */
+
+/* Function codes. */
+# define NTRUP_F_NTRUP_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define NTRUP_R_ENGINE_INIT_FAILURE                        100
+# define NTRUP_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/ntrup/ntrup_asn1.c b/openssl-1.0.2r/crypto/ntrup/ntrup_asn1.c
new file mode 100644
index 00000000..2950e3e6
--- /dev/null
+++ b/openssl-1.0.2r/crypto/ntrup/ntrup_asn1.c
@@ -0,0 +1,125 @@
+/* ntrup_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/ntrup.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int ntrup_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)NTRUP_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        NTRUP_free((NTRUP *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(NTRUPPrivateKey, ntrup_cb) = {
+        ASN1_SIMPLE(NTRUP, version, LONG),
+        ASN1_SIMPLE(NTRUP, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(NTRUP, pub_key, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END_cb(NTRUP, NTRUPPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(NTRUP, NTRUPPrivateKey, NTRUPPrivateKey)
+
+NTRUP *d2i_NTRUPPublicKey(NTRUP **a, const unsigned char **pp, long length) {
+    NTRUP *ntrup = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    ntrup = NTRUP_new();
+    if (ntrup == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        NTRUP_free(ntrup);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            NTRUP_free(*a);
+        *a = ntrup;
+    }
+
+    ntrup->pub_key = pub_key;
+    return ntrup;
+}
+
+int i2d_NTRUPPublicKey(const NTRUP *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
+
+ASN1_SEQUENCE_cb(NTRUPKemInfo, ntrup_cb) = {
+        ASN1_SIMPLE(NTRUP, kem_info, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(NTRUP, NTRUPKemInfo)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(NTRUP, NTRUPKemInfo, NTRUPKemInfo)
+
diff --git a/openssl-1.0.2r/crypto/ntrup/ntrup_err.c b/openssl-1.0.2r/crypto/ntrup/ntrup_err.c
new file mode 100644
index 00000000..d0006331
--- /dev/null
+++ b/openssl-1.0.2r/crypto/ntrup/ntrup_err.c
@@ -0,0 +1,94 @@
+/* crypto/ntrup/ntrup_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/ntrup.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_NTRUP,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_NTRUP,0,reason)
+
+static ERR_STRING_DATA NTRUP_str_functs[] = {
+    {ERR_FUNC(NTRUP_F_NTRUP_NEW_WITH_ENGINE), "NTRUP_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA NTRUP_str_reasons[] = {
+    {ERR_REASON(NTRUP_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(NTRUP_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_NTRUP_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(NTRUP_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, NTRUP_str_functs);
+        ERR_load_strings(0, NTRUP_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/ntrup/ntrup_lib.c b/openssl-1.0.2r/crypto/ntrup/ntrup_lib.c
new file mode 100644
index 00000000..3d390692
--- /dev/null
+++ b/openssl-1.0.2r/crypto/ntrup/ntrup_lib.c
@@ -0,0 +1,194 @@
+/* crypto/ntrup/ntrup_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/ntrup.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char NTRUP_version[] = "NTRUP" OPENSSL_VERSION_PTEXT;
+
+NTRUP *NTRUP_new(void)
+{
+    return NTRUP_new_with_engine(NULL);
+}
+
+NTRUP *NTRUP_new_with_engine(ENGINE *engine)
+{
+    NTRUP *ret;
+
+    ret = (NTRUP *)OPENSSL_malloc(sizeof(NTRUP));
+    if (ret == NULL) {
+        NTRUPerr(NTRUP_F_NTRUP_NEW_WITH_ENGINE, NTRUP_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            NTRUPerr(NTRUP_F_NTRUP_NEW_WITH_ENGINE, NTRUP_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->references = 1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->kem_shared_key = NULL;
+    ret->kem_info = NULL;
+    ret->parameter_set = -1;
+
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_NTRUP, ret, &ret->ex_data);
+    return (ret);
+}
+
+void NTRUP_free(NTRUP *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_NTRUP);
+#ifdef REF_PRINT
+    REF_PRINT("NTRUP", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "NTRUP_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_NTRUP, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->kem_info != NULL)
+        ASN1_OCTET_STRING_free(r->kem_info);
+    if (r->kem_shared_key != NULL) {
+        OPENSSL_cleanse(r->kem_shared_key->data, (size_t)r->kem_shared_key->length);
+        ASN1_OCTET_STRING_free(r->kem_shared_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int NTRUP_up_ref(NTRUP *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_NTRUP);
+#ifdef REF_PRINT
+    REF_PRINT("NTRUP", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "NTRUP_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int NTRUP_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_NTRUP, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int NTRUP_set_ex_data(NTRUP *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *NTRUP_get_ex_data(NTRUP *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/objects/obj_dat.h b/openssl-1.0.2r/crypto/objects/obj_dat.h
index b7e3cf28..6d23d475 100644
--- a/openssl-1.0.2r/crypto/objects/obj_dat.h
+++ b/openssl-1.0.2r/crypto/objects/obj_dat.h
@@ -62,12 +62,12 @@
  * [including the GNU Public Licence.]
  */
 
-#define NUM_NID 958
-#define NUM_SN 951
-#define NUM_LN 951
-#define NUM_OBJ 890
+#define NUM_NID 1047
+#define NUM_SN 1040
+#define NUM_LN 1040
+#define NUM_OBJ 979
 
-static const unsigned char lvalues[6255]={
+static const unsigned char lvalues[6922]={
 0x2A,0x86,0x48,0x86,0xF7,0x0D,               /* [  0] OBJ_rsadsi */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,          /* [  6] OBJ_pkcs */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x02,0x02,     /* [ 13] OBJ_md2 */
@@ -952,6 +952,95 @@ static const unsigned char lvalues[6255]={
 0x2B,0x06,0x01,0x04,0x01,0x82,0x37,0x3C,0x02,0x01,0x01,/* [6221] OBJ_jurisdictionLocalityName */
 0x2B,0x06,0x01,0x04,0x01,0x82,0x37,0x3C,0x02,0x01,0x02,/* [6232] OBJ_jurisdictionStateOrProvinceName */
 0x2B,0x06,0x01,0x04,0x01,0x82,0x37,0x3C,0x02,0x01,0x03,/* [6243] OBJ_jurisdictionCountryName */
+0x55,0x1D,0x48,                              /* [6254] OBJ_subjectAltPublicKeyInfo */
+0x55,0x1D,0x49,                              /* [6257] OBJ_altSignatureAlgorithm */
+0x55,0x1D,0x4A,                              /* [6260] OBJ_altSignatureValue */
+0x04,                                        /* [6263] OBJ_identified_org */
+0x04,0x00,                                   /* [6264] OBJ_etsi */
+0x04,0x00,0x7F,                              /* [6266] OBJ_reserved */
+0x04,0x00,0x7F,0x00,                         /* [6269] OBJ_etsi_identified_org */
+0x04,0x00,0x7F,0x00,0x0F,                    /* [6273] OBJ_ISARA */
+0x04,0x00,0x7F,0x00,0x0F,0x01,               /* [6278] OBJ_ISARA_Algorithms */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,          /* [6284] OBJ_ISARA_Asymmetric */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x02,     /* [6291] OBJ_RAINBOW */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x02,0x00,/* [6299] OBJ_rainbow */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x03,     /* [6308] OBJ_NHDH */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x03,0x00,/* [6316] OBJ_nhdh */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x05,     /* [6325] OBJ_SIDH */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x05,0x00,/* [6333] OBJ_sidh */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x06,     /* [6342] OBJ_NTRUP */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x06,0x00,/* [6350] OBJ_ntrup */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x08,     /* [6359] OBJ_KYBER */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x08,0x00,/* [6367] OBJ_kyber */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x09,     /* [6376] OBJ_DILITHIUM */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x09,0x00,/* [6384] OBJ_dilithium */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0A,     /* [6393] OBJ_FRODO */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0A,0x00,/* [6401] OBJ_frodokem */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0B,     /* [6410] OBJ_SIKE */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0B,0x00,/* [6418] OBJ_sike */
+0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x10,0x03,0x11,/* [6427] OBJ_hss */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0D,     /* [6438] OBJ_XMSS */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0D,0x00,/* [6446] OBJ_xmss */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0E,     /* [6455] OBJ_XMSSMT */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0E,0x00,/* [6463] OBJ_xmssmt */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0F,     /* [6472] OBJ_CMC */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x0F,0x00,/* [6480] OBJ_cmc */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x11,     /* [6489] OBJ_FRODODH */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x11,0x00,/* [6497] OBJ_frododh */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x10,     /* [6506] OBJ_SPHINCS_PLUS */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x10,0x00,/* [6514] OBJ_sphincs */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x12,     /* [6523] OBJ_SAMWISE */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x01,0x12,0x00,/* [6531] OBJ_samwise */
+0x04,0x00,0x7F,0x00,0x0F,0x01,0x02,          /* [6540] OBJ_ISARA_Symmetric */
+0x04,0x00,0x7F,0x00,0x0F,0x02,               /* [6547] OBJ_ISARA_Extensions */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x02,          /* [6553] OBJ_ISARA_Message_Extensions */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x02,0x01,     /* [6560] OBJ_ISARA_CMS_Extensions */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x02,0x01,0x01,/* [6568] OBJ_cmsAltSignatureAlgorithm */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x02,0x01,0x02,/* [6577] OBJ_cmsAltSignatureValue */
+0x04,0x00,0x7F,0x00,0x0F,0x04,               /* [6586] OBJ_ISARA_Protocols */
+0x04,0x00,0x7F,0x00,0x0F,0x04,0x01,          /* [6592] OBJ_kt_kem */
+0x04,0x00,0x7F,0x00,0x0F,0x04,0x01,0x01,     /* [6599] OBJ_isara_kem */
+0x04,0x00,0x7F,0x00,0x0F,0x06,               /* [6607] OBJ_ISARA_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x02,          /* [6613] OBJ_rainbow_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x02,0x01,     /* [6620] OBJ_Rainbow_IIIc_std_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x02,0x02,     /* [6628] OBJ_Rainbow_Vc_std_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x05,          /* [6636] OBJ_sidh_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x05,0x01,     /* [6643] OBJ_SIDH_p503_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x05,0x02,     /* [6651] OBJ_SIDH_p751_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x06,          /* [6659] OBJ_ntrup_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x06,0x01,     /* [6666] OBJ_NTRUPrime_sntrup761_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x08,          /* [6674] OBJ_kyber_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x08,0x01,     /* [6681] OBJ_Kyber_768_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x08,0x02,     /* [6689] OBJ_Kyber_1024_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x09,          /* [6697] OBJ_dilithium_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x09,0x01,     /* [6704] OBJ_Dilithium_III_SHAKE_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x09,0x02,     /* [6712] OBJ_Dilithium_IV_SHAKE_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0A,          /* [6720] OBJ_frodokem_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0A,0x01,     /* [6727] OBJ_FrodoKEM_976_AES_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0A,0x02,     /* [6735] OBJ_FrodoKEM_976_SHAKE_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0B,          /* [6743] OBJ_sike_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0B,0x01,     /* [6750] OBJ_SIKE_p503_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0B,0x02,     /* [6758] OBJ_SIKE_p751_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0F,          /* [6766] OBJ_cmc_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0F,0x01,     /* [6773] OBJ_CMC_6960119_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x0F,0x02,     /* [6781] OBJ_CMC_8192128_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,          /* [6789] OBJ_sphincs_plus_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x01,     /* [6796] OBJ_SPHINCS_SHAKE_256_192f_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x02,     /* [6804] OBJ_SPHINCS_SHAKE_256_192s_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x03,     /* [6812] OBJ_SPHINCS_SHAKE_256_256f_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x04,     /* [6820] OBJ_SPHINCS_SHAKE_256_256s_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x05,     /* [6828] OBJ_SPHINCS_SHA2_256_192f_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x06,     /* [6836] OBJ_SPHINCS_SHA2_256_192s_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x07,     /* [6844] OBJ_SPHINCS_SHA2_256_256f_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x10,0x08,     /* [6852] OBJ_SPHINCS_SHA2_256_256s_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x11,          /* [6860] OBJ_frododh_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x11,0x01,     /* [6867] OBJ_FrodoDH_976_AES_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x11,0x02,     /* [6875] OBJ_FrodoDH_976_SHAKE_r2 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x12,          /* [6883] OBJ_samwise_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x12,0x01,     /* [6890] OBJ_Samwise_976_AES_v1 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x12,0x02,     /* [6898] OBJ_Samwise_976_ChaCha20_v1 */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x13,          /* [6906] OBJ_nhdh_parameters */
+0x04,0x00,0x7F,0x00,0x0F,0x06,0x13,0x01,     /* [6913] OBJ_NewHope_1024_v0 */
 };
 
 static const ASN1_OBJECT nid_objs[NUM_NID]={
@@ -2514,6 +2603,154 @@ static const ASN1_OBJECT nid_objs[NUM_NID]={
 	NID_jurisdictionStateOrProvinceName,11,&(lvalues[6232]),0},
 {"jurisdictionC","jurisdictionCountryName",
 	NID_jurisdictionCountryName,11,&(lvalues[6243]),0},
+{"altSub","Subject Alternative Public Key",
+	NID_subjectAltPublicKeyInfo,3,&(lvalues[6254]),0},
+{"altSigalg","Alternative Signature Algorithm",
+	NID_altSignatureAlgorithm,3,&(lvalues[6257]),0},
+{"altSigVal","Alternative Signature Value",NID_altSignatureValue,3,
+	&(lvalues[6260]),0},
+{"identified-org","identified-org",NID_identified_org,1,
+	&(lvalues[6263]),0},
+{"etsi","etsi",NID_etsi,2,&(lvalues[6264]),0},
+{"reserved","reserved",NID_reserved,3,&(lvalues[6266]),0},
+{"etsi-identified-org","etsi-identified-org",NID_etsi_identified_org,
+	4,&(lvalues[6269]),0},
+{"ISARA","ISARA",NID_ISARA,5,&(lvalues[6273]),0},
+{"ISARA-Algorithms","ISARA-Algorithms",NID_ISARA_Algorithms,6,
+	&(lvalues[6278]),0},
+{"ISARA-Asymmetric","ISARA-Asymmetric",NID_ISARA_Asymmetric,7,
+	&(lvalues[6284]),0},
+{"RAINBOW","RAINBOW",NID_RAINBOW,8,&(lvalues[6291]),0},
+{"id-rainbow","Rainbow-Signature-Scheme",NID_rainbow,9,
+	&(lvalues[6299]),0},
+{"NHDH","NHDH",NID_NHDH,8,&(lvalues[6308]),0},
+{"id-nhdh","NewHope-Diffie-Hellman-Key-Exchange",NID_nhdh,9,
+	&(lvalues[6316]),0},
+{"SIDH","SIDH",NID_SIDH,8,&(lvalues[6325]),0},
+{"id-sidh","Supersingular-Isogeny-Diffie-Hellman-Key-Exchange",
+	NID_sidh,9,&(lvalues[6333]),0},
+{"NTRUP","NTRUP",NID_NTRUP,8,&(lvalues[6342]),0},
+{"id-ntrup","NTRUPrime-Key-Encapsulation",NID_ntrup,9,&(lvalues[6350]),0},
+{"KYBER","KYBER",NID_KYBER,8,&(lvalues[6359]),0},
+{"id-kyber","Kyber-Key-Encapsulation",NID_kyber,9,&(lvalues[6367]),0},
+{"DILITHIUM","DILITHIUM",NID_DILITHIUM,8,&(lvalues[6376]),0},
+{"id-dilithium","Dilithium-Signature-Scheme",NID_dilithium,9,
+	&(lvalues[6384]),0},
+{"FRODO","FRODO",NID_FRODO,8,&(lvalues[6393]),0},
+{"id-frodo","Frodo-Key-Encapsulation",NID_frodokem,9,&(lvalues[6401]),0},
+{"SIKE","SIKE",NID_SIKE,8,&(lvalues[6410]),0},
+{"id-sike","Sike-Key-Encapsulation",NID_sike,9,&(lvalues[6418]),0},
+{"id-alg-hss-lms-hashsig","Hierarchical-Signature-Scheme",NID_hss,11,
+	&(lvalues[6427]),0},
+{"XMSS","XMSS",NID_XMSS,8,&(lvalues[6438]),0},
+{"id-xmss","eXtended-Merkle-Signature-Scheme",NID_xmss,9,
+	&(lvalues[6446]),0},
+{"XMSSMT","XMSSMT",NID_XMSSMT,8,&(lvalues[6455]),0},
+{"id-xmssmt","eXtended-Merkle-Signature-Scheme-Multi-Tree",NID_xmssmt,
+	9,&(lvalues[6463]),0},
+{"CMC","CMC",NID_CMC,8,&(lvalues[6472]),0},
+{"id-classic-mceliece","Classic-McEliece-Key-Encapsulation",NID_cmc,9,
+	&(lvalues[6480]),0},
+{"FRODODH","FRODODH",NID_FRODODH,8,&(lvalues[6489]),0},
+{"id-frododh","FrodoDH-Key-Exchange",NID_frododh,9,&(lvalues[6497]),0},
+{"SPHINCS-PLUS","SPHINCS-PLUS",NID_SPHINCS_PLUS,8,&(lvalues[6506]),0},
+{"id-sphincs-plus","Sphincs-Plus-Signature-Scheme",NID_sphincs,9,
+	&(lvalues[6514]),0},
+{"SAMWISE","SAMWISE",NID_SAMWISE,8,&(lvalues[6523]),0},
+{"id-samwise","Samwise-Key-Exchange",NID_samwise,9,&(lvalues[6531]),0},
+{"ISARA-Symmetric","ISARA-Symmetric",NID_ISARA_Symmetric,7,
+	&(lvalues[6540]),0},
+{"ISARA-Extensions","ISARA-Extensions",NID_ISARA_Extensions,6,
+	&(lvalues[6547]),0},
+{"ISARA-Message-Extensions","ISARA-Message-Extensions",
+	NID_ISARA_Message_Extensions,7,&(lvalues[6553]),0},
+{"ISARA-CMS-Extensions","ISARA-CMS-Extensions",
+	NID_ISARA_CMS_Extensions,8,&(lvalues[6560]),0},
+{"cmsAltSigAlg","CMS-Alternative-Signature-Algorithm",
+	NID_cmsAltSignatureAlgorithm,9,&(lvalues[6568]),0},
+{"cmsAltSigVal","CMS-Alternative-Signature-Value",
+	NID_cmsAltSignatureValue,9,&(lvalues[6577]),0},
+{"ISARA-Protocols","ISARA-Protocols",NID_ISARA_Protocols,6,
+	&(lvalues[6586]),0},
+{"kt-kem","kt-kem",NID_kt_kem,7,&(lvalues[6592]),0},
+{"id-isara-kem","KEM-in-Key-Transport",NID_isara_kem,8,
+	&(lvalues[6599]),0},
+{"ISARA-parameters","ISARA-parameters",NID_ISARA_parameters,6,
+	&(lvalues[6607]),0},
+{"rainbow-parameters","rainbow-parameters",NID_rainbow_parameters,7,
+	&(lvalues[6613]),0},
+{"Rainbow_IIIc_std_r2","Rainbow_IIIc_std_r2",NID_Rainbow_IIIc_std_r2,
+	8,&(lvalues[6620]),0},
+{"Rainbow_Vc_std_r2","Rainbow_Vc_std_r2",NID_Rainbow_Vc_std_r2,8,
+	&(lvalues[6628]),0},
+{"sidh-parameters","sidh-parameters",NID_sidh_parameters,7,
+	&(lvalues[6636]),0},
+{"SIDH_p503_r2","SIDH_p503_r2",NID_SIDH_p503_r2,8,&(lvalues[6643]),0},
+{"SIDH_p751_r2","SIDH_p751_r2",NID_SIDH_p751_r2,8,&(lvalues[6651]),0},
+{"ntrup-parameters","ntrup-parameters",NID_ntrup_parameters,7,
+	&(lvalues[6659]),0},
+{"NTRUPrime_sntrup761_r2","NTRUPrime_sntrup761_r2",
+	NID_NTRUPrime_sntrup761_r2,8,&(lvalues[6666]),0},
+{"kyber-parameters","kyber-parameters",NID_kyber_parameters,7,
+	&(lvalues[6674]),0},
+{"Kyber_768_r2","Kyber_768_r2",NID_Kyber_768_r2,8,&(lvalues[6681]),0},
+{"Kyber_1024_r2","Kyber_1024_r2",NID_Kyber_1024_r2,8,&(lvalues[6689]),0},
+{"dilithium-parameters","dilithium-parameters",
+	NID_dilithium_parameters,7,&(lvalues[6697]),0},
+{"Dilithium_III_SHAKE_r2","Dilithium_III_SHAKE_r2",
+	NID_Dilithium_III_SHAKE_r2,8,&(lvalues[6704]),0},
+{"Dilithium_IV_SHAKE_r2","Dilithium_IV_SHAKE_r2",
+	NID_Dilithium_IV_SHAKE_r2,8,&(lvalues[6712]),0},
+{"frodokem-parameters","frodokem-parameters",NID_frodokem_parameters,
+	7,&(lvalues[6720]),0},
+{"FrodoKEM_976_AES_r2","FrodoKEM_976_AES_r2",NID_FrodoKEM_976_AES_r2,
+	8,&(lvalues[6727]),0},
+{"FrodoKEM_976_SHAKE_r2","FrodoKEM_976_SHAKE_r2",
+	NID_FrodoKEM_976_SHAKE_r2,8,&(lvalues[6735]),0},
+{"sike-parameters","sike-parameters",NID_sike_parameters,7,
+	&(lvalues[6743]),0},
+{"SIKE_p503_r2","SIKE_p503_r2",NID_SIKE_p503_r2,8,&(lvalues[6750]),0},
+{"SIKE_p751_r2","SIKE_p751_r2",NID_SIKE_p751_r2,8,&(lvalues[6758]),0},
+{"cmc-parameters","cmc-parameters",NID_cmc_parameters,7,
+	&(lvalues[6766]),0},
+{"CMC_6960119_r2","CMC_6960119_r2",NID_CMC_6960119_r2,8,
+	&(lvalues[6773]),0},
+{"CMC_8192128_r2","CMC_8192128_r2",NID_CMC_8192128_r2,8,
+	&(lvalues[6781]),0},
+{"sphincs-plus-parameters","sphincs-plus-parameters",
+	NID_sphincs_plus_parameters,7,&(lvalues[6789]),0},
+{"SPHINCS_SHAKE_256_192f_r2","SPHINCS_SHAKE_256_192f_r2",
+	NID_SPHINCS_SHAKE_256_192f_r2,8,&(lvalues[6796]),0},
+{"SPHINCS_SHAKE_256_192s_r2","SPHINCS_SHAKE_256_192s_r2",
+	NID_SPHINCS_SHAKE_256_192s_r2,8,&(lvalues[6804]),0},
+{"SPHINCS_SHAKE_256_256f_r2","SPHINCS_SHAKE_256_256f_r2",
+	NID_SPHINCS_SHAKE_256_256f_r2,8,&(lvalues[6812]),0},
+{"SPHINCS_SHAKE_256_256s_r2","SPHINCS_SHAKE_256_256s_r2",
+	NID_SPHINCS_SHAKE_256_256s_r2,8,&(lvalues[6820]),0},
+{"SPHINCS_SHA2_256_192f_r2","SPHINCS_SHA2_256_192f_r2",
+	NID_SPHINCS_SHA2_256_192f_r2,8,&(lvalues[6828]),0},
+{"SPHINCS_SHA2_256_192s_r2","SPHINCS_SHA2_256_192s_r2",
+	NID_SPHINCS_SHA2_256_192s_r2,8,&(lvalues[6836]),0},
+{"SPHINCS_SHA2_256_256f_r2","SPHINCS_SHA2_256_256f_r2",
+	NID_SPHINCS_SHA2_256_256f_r2,8,&(lvalues[6844]),0},
+{"SPHINCS_SHA2_256_256s_r2","SPHINCS_SHA2_256_256s_r2",
+	NID_SPHINCS_SHA2_256_256s_r2,8,&(lvalues[6852]),0},
+{"frododh-parameters","frododh-parameters",NID_frododh_parameters,7,
+	&(lvalues[6860]),0},
+{"FrodoDH_976_AES_r2","FrodoDH_976_AES_r2",NID_FrodoDH_976_AES_r2,8,
+	&(lvalues[6867]),0},
+{"FrodoDH_976_SHAKE_r2","FrodoDH_976_SHAKE_r2",
+	NID_FrodoDH_976_SHAKE_r2,8,&(lvalues[6875]),0},
+{"samwise-parameters","samwise-parameters",NID_samwise_parameters,7,
+	&(lvalues[6883]),0},
+{"Samwise_976_AES_v1","Samwise_976_AES_v1",NID_Samwise_976_AES_v1,8,
+	&(lvalues[6890]),0},
+{"Samwise_976_ChaCha20_v1","Samwise_976_ChaCha20_v1",
+	NID_Samwise_976_ChaCha20_v1,8,&(lvalues[6898]),0},
+{"nhdh-parameters","nhdh-parameters",NID_nhdh_parameters,7,
+	&(lvalues[6906]),0},
+{"NewHope_1024_v0","NewHope_1024_v0",NID_NewHope_1024_v0,8,
+	&(lvalues[6913]),0},
 };
 
 static const unsigned int sn_objs[NUM_SN]={
@@ -2575,6 +2812,9 @@ static const unsigned int sn_objs[NUM_SN]={
 109,	/* "CAST5-ECB" */
 111,	/* "CAST5-OFB" */
 894,	/* "CMAC" */
+989,	/* "CMC" */
+1028,	/* "CMC_6960119_r2" */
+1029,	/* "CMC_8192128_r2" */
 13,	/* "CN" */
 141,	/* "CRLReason" */
 417,	/* "CSPName" */
@@ -2598,6 +2838,7 @@ static const unsigned int sn_objs[NUM_SN]={
 63,	/* "DES-EDE3-OFB" */
 45,	/* "DES-OFB" */
 80,	/* "DESX-CBC" */
+978,	/* "DILITHIUM" */
 380,	/* "DOD" */
 116,	/* "DSA" */
 66,	/* "DSA-SHA" */
@@ -2605,6 +2846,14 @@ static const unsigned int sn_objs[NUM_SN]={
 70,	/* "DSA-SHA1-old" */
 67,	/* "DSA-old" */
 297,	/* "DVCS" */
+1019,	/* "Dilithium_III_SHAKE_r2" */
+1020,	/* "Dilithium_IV_SHAKE_r2" */
+980,	/* "FRODO" */
+991,	/* "FRODODH" */
+1040,	/* "FrodoDH_976_AES_r2" */
+1041,	/* "FrodoDH_976_SHAKE_r2" */
+1022,	/* "FrodoKEM_976_AES_r2" */
+1023,	/* "FrodoKEM_976_SHAKE_r2" */
 99,	/* "GN" */
 855,	/* "HMAC" */
 780,	/* "HMAC-MD5" */
@@ -2614,11 +2863,23 @@ static const unsigned int sn_objs[NUM_SN]={
 35,	/* "IDEA-CFB" */
 36,	/* "IDEA-ECB" */
 46,	/* "IDEA-OFB" */
+965,	/* "ISARA" */
+966,	/* "ISARA-Algorithms" */
+967,	/* "ISARA-Asymmetric" */
+1000,	/* "ISARA-CMS-Extensions" */
+998,	/* "ISARA-Extensions" */
+999,	/* "ISARA-Message-Extensions" */
+1003,	/* "ISARA-Protocols" */
+997,	/* "ISARA-Symmetric" */
+1006,	/* "ISARA-parameters" */
 181,	/* "ISO" */
 183,	/* "ISO-US" */
 645,	/* "ITU-T" */
 646,	/* "JOINT-ISO-ITU-T" */
 773,	/* "KISA" */
+976,	/* "KYBER" */
+1017,	/* "Kyber_1024_r2" */
+1016,	/* "Kyber_768_r2" */
 15,	/* "L" */
 856,	/* "LocalKeySet" */
  3,	/* "MD2" */
@@ -2628,9 +2889,13 @@ static const unsigned int sn_objs[NUM_SN]={
 95,	/* "MDC2" */
 911,	/* "MGF1" */
 388,	/* "Mail" */
+970,	/* "NHDH" */
+974,	/* "NTRUP" */
+1014,	/* "NTRUPrime_sntrup761_r2" */
 393,	/* "NULL" */
 404,	/* "NULL" */
 57,	/* "Netscape" */
+1046,	/* "NewHope_1024_v0" */
 366,	/* "Nonce" */
 17,	/* "O" */
 178,	/* "OCSP" */
@@ -2656,6 +2921,7 @@ static const unsigned int sn_objs[NUM_SN]={
 162,	/* "PBMAC1" */
 127,	/* "PKIX" */
 935,	/* "PSPECIFIED" */
+968,	/* "RAINBOW" */
 98,	/* "RC2-40-CBC" */
 166,	/* "RC2-64-CBC" */
 37,	/* "RC2-CBC" */
@@ -2687,6 +2953,9 @@ static const unsigned int sn_objs[NUM_SN]={
 670,	/* "RSA-SHA512" */
 919,	/* "RSAES-OAEP" */
 912,	/* "RSASSA-PSS" */
+1008,	/* "Rainbow_IIIc_std_r2" */
+1009,	/* "Rainbow_Vc_std_r2" */
+995,	/* "SAMWISE" */
 777,	/* "SEED-CBC" */
 779,	/* "SEED-CFB" */
 776,	/* "SEED-ECB" */
@@ -2697,11 +2966,28 @@ static const unsigned int sn_objs[NUM_SN]={
 672,	/* "SHA256" */
 673,	/* "SHA384" */
 674,	/* "SHA512" */
+972,	/* "SIDH" */
+1011,	/* "SIDH_p503_r2" */
+1012,	/* "SIDH_p751_r2" */
+982,	/* "SIKE" */
+1025,	/* "SIKE_p503_r2" */
+1026,	/* "SIKE_p751_r2" */
 188,	/* "SMIME" */
 167,	/* "SMIME-CAPS" */
 100,	/* "SN" */
+993,	/* "SPHINCS-PLUS" */
+1035,	/* "SPHINCS_SHA2_256_192f_r2" */
+1036,	/* "SPHINCS_SHA2_256_192s_r2" */
+1037,	/* "SPHINCS_SHA2_256_256f_r2" */
+1038,	/* "SPHINCS_SHA2_256_256s_r2" */
+1031,	/* "SPHINCS_SHAKE_256_192f_r2" */
+1032,	/* "SPHINCS_SHAKE_256_192s_r2" */
+1033,	/* "SPHINCS_SHAKE_256_256f_r2" */
+1034,	/* "SPHINCS_SHAKE_256_256s_r2" */
 16,	/* "ST" */
 143,	/* "SXNetID" */
+1043,	/* "Samwise_976_AES_v1" */
+1044,	/* "Samwise_976_ChaCha20_v1" */
 458,	/* "UID" */
  0,	/* "UNDEF" */
 11,	/* "X500" */
@@ -2709,6 +2995,8 @@ static const unsigned int sn_objs[NUM_SN]={
 12,	/* "X509" */
 184,	/* "X9-57" */
 185,	/* "X9cm" */
+985,	/* "XMSS" */
+987,	/* "XMSSMT" */
 125,	/* "ZLIB" */
 478,	/* "aRecord" */
 289,	/* "aaControls" */
@@ -2719,6 +3007,9 @@ static const unsigned int sn_objs[NUM_SN]={
 446,	/* "account" */
 363,	/* "ad_timestamping" */
 376,	/* "algorithm" */
+960,	/* "altSigVal" */
+959,	/* "altSigalg" */
+958,	/* "altSub" */
 405,	/* "ansi-X9-62" */
 910,	/* "anyExtendedKeyUsage" */
 746,	/* "anyPolicy" */
@@ -2782,6 +3073,9 @@ static const unsigned int sn_objs[NUM_SN]={
 407,	/* "characteristic-two-field" */
 395,	/* "clearance" */
 130,	/* "clientAuth" */
+1027,	/* "cmc-parameters" */
+1001,	/* "cmsAltSigAlg" */
+1002,	/* "cmsAltSigVal" */
 131,	/* "codeSigning" */
 50,	/* "contentType" */
 53,	/* "countersignature" */
@@ -2818,6 +3112,7 @@ static const unsigned int sn_objs[NUM_SN]={
 939,	/* "dhSinglePass-stdDH-sha384kdf-scheme" */
 940,	/* "dhSinglePass-stdDH-sha512kdf-scheme" */
 920,	/* "dhpublicnumber" */
+1018,	/* "dilithium-parameters" */
 382,	/* "directory" */
 887,	/* "distinguishedName" */
 892,	/* "dmdName" */
@@ -2845,6 +3140,8 @@ static const unsigned int sn_objs[NUM_SN]={
 132,	/* "emailProtection" */
 885,	/* "enhancedSearchGuide" */
 389,	/* "enterprises" */
+962,	/* "etsi" */
+964,	/* "etsi-identified-org" */
 384,	/* "experimental" */
 172,	/* "extReq" */
 56,	/* "extendedCertificateAttributes" */
@@ -2856,6 +3153,8 @@ static const unsigned int sn_objs[NUM_SN]={
 453,	/* "friendlyCountry" */
 490,	/* "friendlyCountryName" */
 156,	/* "friendlyName" */
+1039,	/* "frododh-parameters" */
+1021,	/* "frodokem-parameters" */
 509,	/* "generationQualifier" */
 815,	/* "gost-mac" */
 811,	/* "gost2001" */
@@ -2945,6 +3244,7 @@ static const unsigned int sn_objs[NUM_SN]={
 323,	/* "id-alg-des40" */
 326,	/* "id-alg-dh-pop" */
 325,	/* "id-alg-dh-sig-hmac-sha1" */
+984,	/* "id-alg-hss-lms-hashsig" */
 324,	/* "id-alg-noSignature" */
 907,	/* "id-camellia128-wrap" */
 908,	/* "id-camellia192-wrap" */
@@ -2955,6 +3255,7 @@ static const unsigned int sn_objs[NUM_SN]={
 360,	/* "id-cct-crs" */
 81,	/* "id-ce" */
 680,	/* "id-characteristic-two-basis" */
+990,	/* "id-classic-mceliece" */
 263,	/* "id-cmc" */
 334,	/* "id-cmc-addExtensions" */
 346,	/* "id-cmc-confirmCertAcceptance" */
@@ -2977,9 +3278,13 @@ static const unsigned int sn_objs[NUM_SN]={
 327,	/* "id-cmc-statusInfo" */
 331,	/* "id-cmc-transactionId" */
 787,	/* "id-ct-asciiTextWithCRLF" */
+979,	/* "id-dilithium" */
 408,	/* "id-ecPublicKey" */
+981,	/* "id-frodo" */
+992,	/* "id-frododh" */
 508,	/* "id-hex-multipart-message" */
 507,	/* "id-hex-partial-message" */
+1005,	/* "id-isara-kem" */
 260,	/* "id-it" */
 302,	/* "id-it-caKeyUpdateInfo" */
 298,	/* "id-it-caProtEncCert" */
@@ -2998,6 +3303,7 @@ static const unsigned int sn_objs[NUM_SN]={
 784,	/* "id-it-suppLangTags" */
 304,	/* "id-it-unsupportedOIDs" */
 128,	/* "id-kp" */
+977,	/* "id-kyber" */
 280,	/* "id-mod-attribute-cert" */
 274,	/* "id-mod-cmc" */
 277,	/* "id-mod-cmp" */
@@ -3010,6 +3316,8 @@ static const unsigned int sn_objs[NUM_SN]={
 278,	/* "id-mod-qualified-cert-88" */
 279,	/* "id-mod-qualified-cert-93" */
 281,	/* "id-mod-timestamp-protocol" */
+971,	/* "id-nhdh" */
+975,	/* "id-ntrup" */
 264,	/* "id-on" */
 858,	/* "id-on-permanentIdentifier" */
 347,	/* "id-on-personalData" */
@@ -3035,6 +3343,7 @@ static const unsigned int sn_objs[NUM_SN]={
 259,	/* "id-qt" */
 164,	/* "id-qt-cps" */
 165,	/* "id-qt-unotice" */
+969,	/* "id-rainbow" */
 313,	/* "id-regCtrl" */
 316,	/* "id-regCtrl-authenticator" */
 319,	/* "id-regCtrl-oldCertID" */
@@ -3045,7 +3354,10 @@ static const unsigned int sn_objs[NUM_SN]={
 314,	/* "id-regInfo" */
 322,	/* "id-regInfo-certReq" */
 321,	/* "id-regInfo-utf8Pairs" */
+996,	/* "id-samwise" */
 512,	/* "id-set" */
+973,	/* "id-sidh" */
+983,	/* "id-sike" */
 191,	/* "id-smime-aa" */
 215,	/* "id-smime-aa-contentHint" */
 218,	/* "id-smime-aa-contentIdentifier" */
@@ -3115,6 +3427,10 @@ static const unsigned int sn_objs[NUM_SN]={
 194,	/* "id-smime-spq" */
 250,	/* "id-smime-spq-ets-sqt-unotice" */
 249,	/* "id-smime-spq-ets-sqt-uri" */
+994,	/* "id-sphincs-plus" */
+986,	/* "id-xmss" */
+988,	/* "id-xmssmt" */
+961,	/* "identified-org" */
 676,	/* "identified-organization" */
 461,	/* "info" */
 748,	/* "inhibitAnyPolicy" */
@@ -3133,6 +3449,8 @@ static const unsigned int sn_objs[NUM_SN]={
 956,	/* "jurisdictionST" */
 150,	/* "keyBag" */
 83,	/* "keyUsage" */
+1004,	/* "kt-kem" */
+1015,	/* "kyber-parameters" */
 477,	/* "lastModifiedBy" */
 476,	/* "lastModifiedTime" */
 157,	/* "localKeyID" */
@@ -3160,6 +3478,7 @@ static const unsigned int sn_objs[NUM_SN]={
 481,	/* "nSRecord" */
 173,	/* "name" */
 666,	/* "nameConstraints" */
+1045,	/* "nhdh-parameters" */
 369,	/* "noCheck" */
 403,	/* "noRevAvail" */
 72,	/* "nsBaseUrl" */
@@ -3174,6 +3493,7 @@ static const unsigned int sn_objs[NUM_SN]={
 73,	/* "nsRevocationUrl" */
 139,	/* "nsSGC" */
 77,	/* "nsSslServerName" */
+1013,	/* "ntrup-parameters" */
 681,	/* "onBasis" */
 491,	/* "organizationalStatus" */
 475,	/* "otherMailbox" */
@@ -3234,7 +3554,9 @@ static const unsigned int sn_objs[NUM_SN]={
 286,	/* "qcStatements" */
 457,	/* "qualityLabelledData" */
 450,	/* "rFC822localPart" */
+1007,	/* "rainbow-parameters" */
 870,	/* "registeredAddress" */
+963,	/* "reserved" */
 400,	/* "role" */
 877,	/* "roleOccupant" */
 448,	/* "room" */
@@ -3245,6 +3567,7 @@ static const unsigned int sn_objs[NUM_SN]={
  1,	/* "rsadsi" */
 482,	/* "sOARecord" */
 155,	/* "safeContentsBag" */
+1042,	/* "samwise-parameters" */
 291,	/* "sbgp-autonomousSysNum" */
 290,	/* "sbgp-ipAddrBlock" */
 292,	/* "sbgp-routerIdentifier" */
@@ -3419,10 +3742,13 @@ static const unsigned int sn_objs[NUM_SN]={
 604,	/* "setext-pinAny" */
 603,	/* "setext-pinSecure" */
 605,	/* "setext-track2" */
+1010,	/* "sidh-parameters" */
 52,	/* "signingTime" */
+1024,	/* "sike-parameters" */
 454,	/* "simpleSecurityObject" */
 496,	/* "singleLevelQuality" */
 387,	/* "snmpv2" */
+1030,	/* "sphincs-plus-parameters" */
 660,	/* "street" */
 85,	/* "subjectAltName" */
 769,	/* "subjectDirectoryAttributes" */
@@ -3474,6 +3800,8 @@ static const unsigned int ln_objs[NUM_LN]={
 363,	/* "AD Time Stamping" */
 405,	/* "ANSI X9.62" */
 368,	/* "Acceptable OCSP Responses" */
+959,	/* "Alternative Signature Algorithm" */
+960,	/* "Alternative Signature Value" */
 910,	/* "Any Extended Key Usage" */
 664,	/* "Any language" */
 177,	/* "Authority Information Access" */
@@ -3481,12 +3809,22 @@ static const unsigned int ln_objs[NUM_LN]={
 285,	/* "Biometric Info" */
 179,	/* "CA Issuers" */
 785,	/* "CA Repository" */
+989,	/* "CMC" */
+1028,	/* "CMC_6960119_r2" */
+1029,	/* "CMC_8192128_r2" */
+1001,	/* "CMS-Alternative-Signature-Algorithm" */
+1002,	/* "CMS-Alternative-Signature-Value" */
 954,	/* "CT Certificate SCTs" */
 952,	/* "CT Precertificate Poison" */
 951,	/* "CT Precertificate SCTs" */
 953,	/* "CT Precertificate Signer" */
+990,	/* "Classic-McEliece-Key-Encapsulation" */
 131,	/* "Code Signing" */
+978,	/* "DILITHIUM" */
 783,	/* "Diffie-Hellman based MAC" */
+979,	/* "Dilithium-Signature-Scheme" */
+1019,	/* "Dilithium_III_SHAKE_r2" */
+1020,	/* "Dilithium_IV_SHAKE_r2" */
 382,	/* "Directory" */
 392,	/* "Domain" */
 132,	/* "E-mail Protection" */
@@ -3494,6 +3832,14 @@ static const unsigned int ln_objs[NUM_LN]={
 384,	/* "Experimental" */
 372,	/* "Extended OCSP Status" */
 172,	/* "Extension Request" */
+980,	/* "FRODO" */
+991,	/* "FRODODH" */
+981,	/* "Frodo-Key-Encapsulation" */
+992,	/* "FrodoDH-Key-Exchange" */
+1040,	/* "FrodoDH_976_AES_r2" */
+1041,	/* "FrodoDH_976_SHAKE_r2" */
+1022,	/* "FrodoKEM_976_AES_r2" */
+1023,	/* "FrodoKEM_976_SHAKE_r2" */
 813,	/* "GOST 28147-89" */
 849,	/* "GOST 28147-89 Cryptocom ParamSet" */
 815,	/* "GOST 28147-89 MAC" */
@@ -3511,6 +3857,7 @@ static const unsigned int ln_objs[NUM_LN]={
 852,	/* "GOST R 34.11-94 with GOST R 34.10-94 Cryptocom" */
 854,	/* "GOST R 3410-2001 Parameter Set Cryptocom" */
 810,	/* "HMAC GOST 34.11-94" */
+984,	/* "Hierarchical-Signature-Scheme" */
 432,	/* "Hold Instruction Call Issuer" */
 430,	/* "Hold Instruction Code" */
 431,	/* "Hold Instruction None" */
@@ -3519,12 +3866,26 @@ static const unsigned int ln_objs[NUM_LN]={
 294,	/* "IPSec End System" */
 295,	/* "IPSec Tunnel" */
 296,	/* "IPSec User" */
+965,	/* "ISARA" */
+966,	/* "ISARA-Algorithms" */
+967,	/* "ISARA-Asymmetric" */
+1000,	/* "ISARA-CMS-Extensions" */
+998,	/* "ISARA-Extensions" */
+999,	/* "ISARA-Message-Extensions" */
+1003,	/* "ISARA-Protocols" */
+997,	/* "ISARA-Symmetric" */
+1006,	/* "ISARA-parameters" */
 182,	/* "ISO Member Body" */
 183,	/* "ISO US Member Body" */
 667,	/* "Independent" */
 665,	/* "Inherit all" */
 647,	/* "International Organizations" */
 142,	/* "Invalidity Date" */
+1005,	/* "KEM-in-Key-Transport" */
+976,	/* "KYBER" */
+977,	/* "Kyber-Key-Encapsulation" */
+1017,	/* "Kyber_1024_r2" */
+1016,	/* "Kyber_768_r2" */
 504,	/* "MIME MHS" */
 388,	/* "Mail" */
 383,	/* "Management" */
@@ -3538,6 +3899,10 @@ static const unsigned int ln_objs[NUM_LN]={
 648,	/* "Microsoft Smartcardlogin" */
 136,	/* "Microsoft Trust List Signing" */
 649,	/* "Microsoft Universal Principal Name" */
+970,	/* "NHDH" */
+974,	/* "NTRUP" */
+975,	/* "NTRUPrime-Key-Encapsulation" */
+1014,	/* "NTRUPrime_sntrup761_r2" */
 393,	/* "NULL" */
 404,	/* "NULL" */
 72,	/* "Netscape Base Url" */
@@ -3553,6 +3918,8 @@ static const unsigned int ln_objs[NUM_LN]={
 73,	/* "Netscape Revocation Url" */
 77,	/* "Netscape SSL Server Name" */
 139,	/* "Netscape Server Gated Crypto" */
+971,	/* "NewHope-Diffie-Hellman-Key-Exchange" */
+1046,	/* "NewHope_1024_v0" */
 178,	/* "OCSP" */
 370,	/* "OCSP Archive Cutoff" */
 367,	/* "OCSP CRL ID" */
@@ -3569,16 +3936,43 @@ static const unsigned int ln_objs[NUM_LN]={
 165,	/* "Policy Qualifier User Notice" */
 385,	/* "Private" */
 663,	/* "Proxy Certificate Information" */
+968,	/* "RAINBOW" */
  1,	/* "RSA Data Security, Inc." */
  2,	/* "RSA Data Security, Inc. PKCS" */
+969,	/* "Rainbow-Signature-Scheme" */
+1008,	/* "Rainbow_IIIc_std_r2" */
+1009,	/* "Rainbow_Vc_std_r2" */
 188,	/* "S/MIME" */
 167,	/* "S/MIME Capabilities" */
+995,	/* "SAMWISE" */
+972,	/* "SIDH" */
+1011,	/* "SIDH_p503_r2" */
+1012,	/* "SIDH_p751_r2" */
+982,	/* "SIKE" */
+1025,	/* "SIKE_p503_r2" */
+1026,	/* "SIKE_p751_r2" */
 387,	/* "SNMPv2" */
+993,	/* "SPHINCS-PLUS" */
+1035,	/* "SPHINCS_SHA2_256_192f_r2" */
+1036,	/* "SPHINCS_SHA2_256_192s_r2" */
+1037,	/* "SPHINCS_SHA2_256_256f_r2" */
+1038,	/* "SPHINCS_SHA2_256_256s_r2" */
+1031,	/* "SPHINCS_SHAKE_256_192f_r2" */
+1032,	/* "SPHINCS_SHAKE_256_192s_r2" */
+1033,	/* "SPHINCS_SHAKE_256_256f_r2" */
+1034,	/* "SPHINCS_SHAKE_256_256s_r2" */
+996,	/* "Samwise-Key-Exchange" */
+1043,	/* "Samwise_976_AES_v1" */
+1044,	/* "Samwise_976_ChaCha20_v1" */
 512,	/* "Secure Electronic Transactions" */
 386,	/* "Security" */
 394,	/* "Selected Attribute Types" */
+983,	/* "Sike-Key-Encapsulation" */
+994,	/* "Sphincs-Plus-Signature-Scheme" */
 143,	/* "Strong Extranet ID" */
+958,	/* "Subject Alternative Public Key" */
 398,	/* "Subject Information Access" */
+973,	/* "Supersingular-Isogeny-Diffie-Hellman-Key-Exchange" */
 130,	/* "TLS Web Client Authentication" */
 129,	/* "TLS Web Server Authentication" */
 133,	/* "Time Stamping" */
@@ -3611,6 +4005,8 @@ static const unsigned int ln_objs[NUM_LN]={
 920,	/* "X9.42 DH" */
 184,	/* "X9.57" */
 185,	/* "X9.57 CM ?" */
+985,	/* "XMSS" */
+987,	/* "XMSSMT" */
 478,	/* "aRecord" */
 289,	/* "aaControls" */
 287,	/* "ac-auditEntity" */
@@ -3733,6 +4129,7 @@ static const unsigned int ln_objs[NUM_LN]={
 395,	/* "clearance" */
 633,	/* "cleartext track 2" */
 894,	/* "cmac" */
+1027,	/* "cmc-parameters" */
 13,	/* "commonName" */
 513,	/* "content types" */
 50,	/* "contentType" */
@@ -3781,6 +4178,7 @@ static const unsigned int ln_objs[NUM_LN]={
 938,	/* "dhSinglePass-stdDH-sha256kdf-scheme" */
 939,	/* "dhSinglePass-stdDH-sha384kdf-scheme" */
 940,	/* "dhSinglePass-stdDH-sha512kdf-scheme" */
+1018,	/* "dilithium-parameters" */
 11,	/* "directory services (X.500)" */
 378,	/* "directory services - algorithms" */
 887,	/* "distinguishedName" */
@@ -3805,6 +4203,8 @@ static const unsigned int ln_objs[NUM_LN]={
 802,	/* "dsa_with_SHA224" */
 803,	/* "dsa_with_SHA256" */
 297,	/* "dvcs" */
+986,	/* "eXtended-Merkle-Signature-Scheme" */
+988,	/* "eXtended-Merkle-Signature-Scheme-Multi-Tree" */
 791,	/* "ecdsa-with-Recommended" */
 416,	/* "ecdsa-with-SHA1" */
 793,	/* "ecdsa-with-SHA224" */
@@ -3815,12 +4215,16 @@ static const unsigned int ln_objs[NUM_LN]={
 48,	/* "emailAddress" */
 632,	/* "encrypted track 2" */
 885,	/* "enhancedSearchGuide" */
+962,	/* "etsi" */
+964,	/* "etsi-identified-org" */
 56,	/* "extendedCertificateAttributes" */
 867,	/* "facsimileTelephoneNumber" */
 462,	/* "favouriteDrink" */
 453,	/* "friendlyCountry" */
 490,	/* "friendlyCountryName" */
 156,	/* "friendlyName" */
+1039,	/* "frododh-parameters" */
+1021,	/* "frodokem-parameters" */
 631,	/* "generate cryptogram" */
 509,	/* "generationQualifier" */
 601,	/* "generic cryptogram" */
@@ -4057,6 +4461,7 @@ static const unsigned int ln_objs[NUM_LN]={
 35,	/* "idea-cfb" */
 36,	/* "idea-ecb" */
 46,	/* "idea-ofb" */
+961,	/* "identified-org" */
 676,	/* "identified-organization" */
 461,	/* "info" */
 101,	/* "initials" */
@@ -4073,6 +4478,8 @@ static const unsigned int ln_objs[NUM_LN]={
 956,	/* "jurisdictionStateOrProvinceName" */
 150,	/* "keyBag" */
 773,	/* "kisa" */
+1004,	/* "kt-kem" */
+1015,	/* "kyber-parameters" */
 477,	/* "lastModifiedBy" */
 476,	/* "lastModifiedTime" */
 157,	/* "localKeyID" */
@@ -4100,6 +4507,8 @@ static const unsigned int ln_objs[NUM_LN]={
 488,	/* "mobileTelephoneNumber" */
 481,	/* "nSRecord" */
 173,	/* "name" */
+1045,	/* "nhdh-parameters" */
+1013,	/* "ntrup-parameters" */
 681,	/* "onBasis" */
 379,	/* "org" */
 17,	/* "organizationName" */
@@ -4171,6 +4580,7 @@ static const unsigned int ln_objs[NUM_LN]={
 286,	/* "qcStatements" */
 457,	/* "qualityLabelledData" */
 450,	/* "rFC822localPart" */
+1007,	/* "rainbow-parameters" */
 98,	/* "rc2-40-cbc" */
 166,	/* "rc2-64-cbc" */
 37,	/* "rc2-cbc" */
@@ -4185,6 +4595,7 @@ static const unsigned int ln_objs[NUM_LN]={
 121,	/* "rc5-ecb" */
 123,	/* "rc5-ofb" */
 870,	/* "registeredAddress" */
+963,	/* "reserved" */
 460,	/* "rfc822Mailbox" */
 117,	/* "ripemd160" */
 119,	/* "ripemd160WithRSA" */
@@ -4201,6 +4612,7 @@ static const unsigned int ln_objs[NUM_LN]={
 124,	/* "run length compression" */
 482,	/* "sOARecord" */
 155,	/* "safeContentsBag" */
+1042,	/* "samwise-parameters" */
 291,	/* "sbgp-autonomousSysNum" */
 290,	/* "sbgp-ipAddrBlock" */
 292,	/* "sbgp-routerIdentifier" */
@@ -4376,9 +4788,12 @@ static const unsigned int ln_objs[NUM_LN]={
 674,	/* "sha512" */
 670,	/* "sha512WithRSAEncryption" */
 42,	/* "shaWithRSAEncryption" */
+1010,	/* "sidh-parameters" */
 52,	/* "signingTime" */
+1024,	/* "sike-parameters" */
 454,	/* "simpleSecurityObject" */
 496,	/* "singleLevelQuality" */
+1030,	/* "sphincs-plus-parameters" */
 16,	/* "stateOrProvinceName" */
 660,	/* "streetAddress" */
 498,	/* "subtreeMaximumQuality" */
@@ -4431,18 +4846,21 @@ static const unsigned int obj_objs[NUM_OBJ]={
 404,	/* OBJ_ccitt                        OBJ_itu_t */
 645,	/* OBJ_itu_t                        0 */
 646,	/* OBJ_joint_iso_itu_t              2 */
+961,	/* OBJ_identified_org               0 4 */
 434,	/* OBJ_data                         0 9 */
 182,	/* OBJ_member_body                  1 2 */
 379,	/* OBJ_org                          1 3 */
 676,	/* OBJ_identified_organization      1 3 */
 11,	/* OBJ_X500                         2 5 */
 647,	/* OBJ_international_organizations  2 23 */
+962,	/* OBJ_etsi                         0 4 0 */
 380,	/* OBJ_dod                          1 3 6 */
 12,	/* OBJ_X509                         2 5 4 */
 378,	/* OBJ_X500algorithms               2 5 8 */
 81,	/* OBJ_id_ce                        2 5 29 */
 512,	/* OBJ_id_set                       2 23 42 */
 678,	/* OBJ_wap                          2 23 43 */
+963,	/* OBJ_reserved                     0 4 0 127 */
 435,	/* OBJ_pss                          0 9 2342 */
 183,	/* OBJ_ISO_US                       1 2 840 */
 381,	/* OBJ_iana                         1 3 6 1 */
@@ -4527,6 +4945,9 @@ static const unsigned int obj_objs[NUM_OBJ]={
 748,	/* OBJ_inhibit_any_policy           2 5 29 54 */
 402,	/* OBJ_target_information           2 5 29 55 */
 403,	/* OBJ_no_rev_avail                 2 5 29 56 */
+958,	/* OBJ_subjectAltPublicKeyInfo      2 5 29 72 */
+959,	/* OBJ_altSignatureAlgorithm        2 5 29 73 */
+960,	/* OBJ_altSignatureValue            2 5 29 74 */
 513,	/* OBJ_set_ctype                    2 23 42 0 */
 514,	/* OBJ_set_msgExt                   2 23 42 1 */
 515,	/* OBJ_set_attr                     2 23 42 3 */
@@ -4534,6 +4955,7 @@ static const unsigned int obj_objs[NUM_OBJ]={
 517,	/* OBJ_set_certExt                  2 23 42 7 */
 518,	/* OBJ_set_brand                    2 23 42 8 */
 679,	/* OBJ_wap_wsg                      2 23 43 1 */
+964,	/* OBJ_etsi_identified_org          0 4 0 127 0 */
 382,	/* OBJ_Directory                    1 3 6 1 1 */
 383,	/* OBJ_Management                   1 3 6 1 2 */
 384,	/* OBJ_Experimental                 1 3 6 1 3 */
@@ -4659,6 +5081,7 @@ static const unsigned int obj_objs[NUM_OBJ]={
 637,	/* OBJ_set_brand_Diners             2 23 42 8 30 */
 638,	/* OBJ_set_brand_AmericanExpress    2 23 42 8 34 */
 639,	/* OBJ_set_brand_JCB                2 23 42 8 35 */
+965,	/* OBJ_ISARA                        0 4 0 127 0 15 */
 805,	/* OBJ_cryptopro                    1 2 643 2 2 */
 806,	/* OBJ_cryptocom                    1 2 643 2 9 */
 184,	/* OBJ_X9_57                        1 2 840 10040 */
@@ -4731,6 +5154,10 @@ static const unsigned int obj_objs[NUM_OBJ]={
 743,	/* OBJ_wap_wsg_idm_ecid_wtls10      2 23 43 1 4 10 */
 744,	/* OBJ_wap_wsg_idm_ecid_wtls11      2 23 43 1 4 11 */
 745,	/* OBJ_wap_wsg_idm_ecid_wtls12      2 23 43 1 4 12 */
+966,	/* OBJ_ISARA_Algorithms             0 4 0 127 0 15 1 */
+998,	/* OBJ_ISARA_Extensions             0 4 0 127 0 15 2 */
+1003,	/* OBJ_ISARA_Protocols              0 4 0 127 0 15 4 */
+1006,	/* OBJ_ISARA_parameters             0 4 0 127 0 15 6 */
 804,	/* OBJ_whirlpool                    1 0 10118 3 0 55 */
 124,	/* OBJ_rle_compression              1 1 1 1 666 1 */
 773,	/* OBJ_kisa                         1 2 410 200004 */
@@ -4764,6 +5191,22 @@ static const unsigned int obj_objs[NUM_OBJ]={
 633,	/* OBJ_setAttr_T2cleartxt           2 23 42 3 3 4 2 */
 634,	/* OBJ_setAttr_TokICCsig            2 23 42 3 3 5 1 */
 635,	/* OBJ_setAttr_SecDevSig            2 23 42 3 3 5 2 */
+967,	/* OBJ_ISARA_Asymmetric             0 4 0 127 0 15 1 1 */
+997,	/* OBJ_ISARA_Symmetric              0 4 0 127 0 15 1 2 */
+999,	/* OBJ_ISARA_Message_Extensions     0 4 0 127 0 15 2 2 */
+1004,	/* OBJ_kt_kem                       0 4 0 127 0 15 4 1 */
+1007,	/* OBJ_rainbow_parameters           0 4 0 127 0 15 6 2 */
+1010,	/* OBJ_sidh_parameters              0 4 0 127 0 15 6 5 */
+1013,	/* OBJ_ntrup_parameters             0 4 0 127 0 15 6 6 */
+1015,	/* OBJ_kyber_parameters             0 4 0 127 0 15 6 8 */
+1018,	/* OBJ_dilithium_parameters         0 4 0 127 0 15 6 9 */
+1021,	/* OBJ_frodokem_parameters          0 4 0 127 0 15 6 10 */
+1024,	/* OBJ_sike_parameters              0 4 0 127 0 15 6 11 */
+1027,	/* OBJ_cmc_parameters               0 4 0 127 0 15 6 15 */
+1030,	/* OBJ_sphincs_plus_parameters      0 4 0 127 0 15 6 16 */
+1039,	/* OBJ_frododh_parameters           0 4 0 127 0 15 6 17 */
+1042,	/* OBJ_samwise_parameters           0 4 0 127 0 15 6 18 */
+1045,	/* OBJ_nhdh_parameters              0 4 0 127 0 15 6 19 */
 436,	/* OBJ_ucl                          0 9 2342 19200300 */
 820,	/* OBJ_id_Gost28147_89_None_KeyMeshing 1 2 643 2 2 14 0 */
 819,	/* OBJ_id_Gost28147_89_CryptoPro_KeyMeshing 1 2 643 2 2 14 1 */
@@ -4835,6 +5278,50 @@ static const unsigned int obj_objs[NUM_OBJ]={
 756,	/* OBJ_camellia_256_ecb             0 3 4401 5 3 1 9 41 */
 768,	/* OBJ_camellia_256_ofb128          0 3 4401 5 3 1 9 43 */
 759,	/* OBJ_camellia_256_cfb128          0 3 4401 5 3 1 9 44 */
+968,	/* OBJ_RAINBOW                      0 4 0 127 0 15 1 1 2 */
+970,	/* OBJ_NHDH                         0 4 0 127 0 15 1 1 3 */
+972,	/* OBJ_SIDH                         0 4 0 127 0 15 1 1 5 */
+974,	/* OBJ_NTRUP                        0 4 0 127 0 15 1 1 6 */
+976,	/* OBJ_KYBER                        0 4 0 127 0 15 1 1 8 */
+978,	/* OBJ_DILITHIUM                    0 4 0 127 0 15 1 1 9 */
+980,	/* OBJ_FRODO                        0 4 0 127 0 15 1 1 10 */
+982,	/* OBJ_SIKE                         0 4 0 127 0 15 1 1 11 */
+985,	/* OBJ_XMSS                         0 4 0 127 0 15 1 1 13 */
+987,	/* OBJ_XMSSMT                       0 4 0 127 0 15 1 1 14 */
+989,	/* OBJ_CMC                          0 4 0 127 0 15 1 1 15 */
+993,	/* OBJ_SPHINCS_PLUS                 0 4 0 127 0 15 1 1 16 */
+991,	/* OBJ_FRODODH                      0 4 0 127 0 15 1 1 17 */
+995,	/* OBJ_SAMWISE                      0 4 0 127 0 15 1 1 18 */
+1000,	/* OBJ_ISARA_CMS_Extensions         0 4 0 127 0 15 2 2 1 */
+1005,	/* OBJ_isara_kem                    0 4 0 127 0 15 4 1 1 */
+1008,	/* OBJ_Rainbow_IIIc_std_r2          0 4 0 127 0 15 6 2 1 */
+1009,	/* OBJ_Rainbow_Vc_std_r2            0 4 0 127 0 15 6 2 2 */
+1011,	/* OBJ_SIDH_p503_r2                 0 4 0 127 0 15 6 5 1 */
+1012,	/* OBJ_SIDH_p751_r2                 0 4 0 127 0 15 6 5 2 */
+1014,	/* OBJ_NTRUPrime_sntrup761_r2       0 4 0 127 0 15 6 6 1 */
+1016,	/* OBJ_Kyber_768_r2                 0 4 0 127 0 15 6 8 1 */
+1017,	/* OBJ_Kyber_1024_r2                0 4 0 127 0 15 6 8 2 */
+1019,	/* OBJ_Dilithium_III_SHAKE_r2       0 4 0 127 0 15 6 9 1 */
+1020,	/* OBJ_Dilithium_IV_SHAKE_r2        0 4 0 127 0 15 6 9 2 */
+1022,	/* OBJ_FrodoKEM_976_AES_r2          0 4 0 127 0 15 6 10 1 */
+1023,	/* OBJ_FrodoKEM_976_SHAKE_r2        0 4 0 127 0 15 6 10 2 */
+1025,	/* OBJ_SIKE_p503_r2                 0 4 0 127 0 15 6 11 1 */
+1026,	/* OBJ_SIKE_p751_r2                 0 4 0 127 0 15 6 11 2 */
+1028,	/* OBJ_CMC_6960119_r2               0 4 0 127 0 15 6 15 1 */
+1029,	/* OBJ_CMC_8192128_r2               0 4 0 127 0 15 6 15 2 */
+1031,	/* OBJ_SPHINCS_SHAKE_256_192f_r2    0 4 0 127 0 15 6 16 1 */
+1032,	/* OBJ_SPHINCS_SHAKE_256_192s_r2    0 4 0 127 0 15 6 16 2 */
+1033,	/* OBJ_SPHINCS_SHAKE_256_256f_r2    0 4 0 127 0 15 6 16 3 */
+1034,	/* OBJ_SPHINCS_SHAKE_256_256s_r2    0 4 0 127 0 15 6 16 4 */
+1035,	/* OBJ_SPHINCS_SHA2_256_192f_r2     0 4 0 127 0 15 6 16 5 */
+1036,	/* OBJ_SPHINCS_SHA2_256_192s_r2     0 4 0 127 0 15 6 16 6 */
+1037,	/* OBJ_SPHINCS_SHA2_256_256f_r2     0 4 0 127 0 15 6 16 7 */
+1038,	/* OBJ_SPHINCS_SHA2_256_256s_r2     0 4 0 127 0 15 6 16 8 */
+1040,	/* OBJ_FrodoDH_976_AES_r2           0 4 0 127 0 15 6 17 1 */
+1041,	/* OBJ_FrodoDH_976_SHAKE_r2         0 4 0 127 0 15 6 17 2 */
+1043,	/* OBJ_Samwise_976_AES_v1           0 4 0 127 0 15 6 18 1 */
+1044,	/* OBJ_Samwise_976_ChaCha20_v1      0 4 0 127 0 15 6 18 2 */
+1046,	/* OBJ_NewHope_1024_v0              0 4 0 127 0 15 6 19 1 */
 437,	/* OBJ_pilot                        0 9 2342 19200300 100 */
 776,	/* OBJ_seed_ecb                     1 2 410 200004 1 3 */
 777,	/* OBJ_seed_cbc                     1 2 410 200004 1 4 */
@@ -5009,6 +5496,22 @@ static const unsigned int obj_objs[NUM_OBJ]={
 781,	/* OBJ_hmac_sha1                    1 3 6 1 5 5 8 1 2 */
 58,	/* OBJ_netscape_cert_extension      2 16 840 1 113730 1 */
 59,	/* OBJ_netscape_data_type           2 16 840 1 113730 2 */
+969,	/* OBJ_rainbow                      0 4 0 127 0 15 1 1 2 0 */
+971,	/* OBJ_nhdh                         0 4 0 127 0 15 1 1 3 0 */
+973,	/* OBJ_sidh                         0 4 0 127 0 15 1 1 5 0 */
+975,	/* OBJ_ntrup                        0 4 0 127 0 15 1 1 6 0 */
+977,	/* OBJ_kyber                        0 4 0 127 0 15 1 1 8 0 */
+979,	/* OBJ_dilithium                    0 4 0 127 0 15 1 1 9 0 */
+981,	/* OBJ_frodokem                     0 4 0 127 0 15 1 1 10 0 */
+983,	/* OBJ_sike                         0 4 0 127 0 15 1 1 11 0 */
+986,	/* OBJ_xmss                         0 4 0 127 0 15 1 1 13 0 */
+988,	/* OBJ_xmssmt                       0 4 0 127 0 15 1 1 14 0 */
+990,	/* OBJ_cmc                          0 4 0 127 0 15 1 1 15 0 */
+994,	/* OBJ_sphincs                      0 4 0 127 0 15 1 1 16 0 */
+992,	/* OBJ_frododh                      0 4 0 127 0 15 1 1 17 0 */
+996,	/* OBJ_samwise                      0 4 0 127 0 15 1 1 18 0 */
+1001,	/* OBJ_cmsAltSignatureAlgorithm     0 4 0 127 0 15 2 2 1 1 */
+1002,	/* OBJ_cmsAltSignatureValue         0 4 0 127 0 15 2 2 1 2 */
 438,	/* OBJ_pilotAttributeType           0 9 2342 19200300 100 1 */
 439,	/* OBJ_pilotAttributeSyntax         0 9 2342 19200300 100 3 */
 440,	/* OBJ_pilotObjectClass             0 9 2342 19200300 100 4 */
@@ -5296,6 +5799,7 @@ static const unsigned int obj_objs[NUM_OBJ]={
 247,	/* OBJ_id_smime_alg_CMSRC2wrap      1 2 840 113549 1 9 16 3 7 */
 125,	/* OBJ_zlib_compression             1 2 840 113549 1 9 16 3 8 */
 893,	/* OBJ_id_alg_PWRI_KEK              1 2 840 113549 1 9 16 3 9 */
+984,	/* OBJ_hss                          1 2 840 113549 1 9 16 3 17 */
 248,	/* OBJ_id_smime_cd_ldap             1 2 840 113549 1 9 16 4 1 */
 249,	/* OBJ_id_smime_spq_ets_sqt_uri     1 2 840 113549 1 9 16 5 1 */
 250,	/* OBJ_id_smime_spq_ets_sqt_unotice 1 2 840 113549 1 9 16 5 2 */
diff --git a/openssl-1.0.2r/crypto/objects/obj_mac.h b/openssl-1.0.2r/crypto/objects/obj_mac.h
index 779c309b..8d45d912 100644
--- a/openssl-1.0.2r/crypto/objects/obj_mac.h
+++ b/openssl-1.0.2r/crypto/objects/obj_mac.h
@@ -2423,6 +2423,21 @@
 #define NID_no_rev_avail                403
 #define OBJ_no_rev_avail                OBJ_id_ce,56L
 
+#define SN_subjectAltPublicKeyInfo              "altSub"
+#define LN_subjectAltPublicKeyInfo              "Subject Alternative Public Key"
+#define NID_subjectAltPublicKeyInfo             958
+#define OBJ_subjectAltPublicKeyInfo             OBJ_id_ce,72L
+
+#define SN_altSignatureAlgorithm                "altSigalg"
+#define LN_altSignatureAlgorithm                "Alternative Signature Algorithm"
+#define NID_altSignatureAlgorithm               959
+#define OBJ_altSignatureAlgorithm               OBJ_id_ce,73L
+
+#define SN_altSignatureValue            "altSigVal"
+#define LN_altSignatureValue            "Alternative Signature Value"
+#define NID_altSignatureValue           960
+#define OBJ_altSignatureValue           OBJ_id_ce,74L
+
 #define SN_anyExtendedKeyUsage          "anyExtendedKeyUsage"
 #define LN_anyExtendedKeyUsage          "Any Extended Key Usage"
 #define NID_anyExtendedKeyUsage         910
@@ -2823,6 +2838,368 @@
 #define NID_hold_instruction_reject             433
 #define OBJ_hold_instruction_reject             OBJ_holdInstruction,3L
 
+#define SN_identified_org               "identified-org"
+#define NID_identified_org              961
+#define OBJ_identified_org              OBJ_itu_t,4L
+
+#define SN_etsi         "etsi"
+#define NID_etsi                962
+#define OBJ_etsi                OBJ_identified_org,0L
+
+#define SN_reserved             "reserved"
+#define NID_reserved            963
+#define OBJ_reserved            OBJ_etsi,127L
+
+#define SN_etsi_identified_org          "etsi-identified-org"
+#define NID_etsi_identified_org         964
+#define OBJ_etsi_identified_org         OBJ_reserved,0L
+
+#define SN_ISARA                "ISARA"
+#define NID_ISARA               965
+#define OBJ_ISARA               OBJ_etsi_identified_org,15L
+
+#define SN_ISARA_Algorithms             "ISARA-Algorithms"
+#define NID_ISARA_Algorithms            966
+#define OBJ_ISARA_Algorithms            OBJ_ISARA,1L
+
+#define SN_ISARA_Asymmetric             "ISARA-Asymmetric"
+#define NID_ISARA_Asymmetric            967
+#define OBJ_ISARA_Asymmetric            OBJ_ISARA_Algorithms,1L
+
+#define SN_RAINBOW              "RAINBOW"
+#define NID_RAINBOW             968
+#define OBJ_RAINBOW             OBJ_ISARA_Asymmetric,2L
+
+#define SN_rainbow              "id-rainbow"
+#define LN_rainbow              "Rainbow-Signature-Scheme"
+#define NID_rainbow             969
+#define OBJ_rainbow             OBJ_RAINBOW,0L
+
+#define SN_NHDH         "NHDH"
+#define NID_NHDH                970
+#define OBJ_NHDH                OBJ_ISARA_Asymmetric,3L
+
+#define SN_nhdh         "id-nhdh"
+#define LN_nhdh         "NewHope-Diffie-Hellman-Key-Exchange"
+#define NID_nhdh                971
+#define OBJ_nhdh                OBJ_NHDH,0L
+
+#define SN_SIDH         "SIDH"
+#define NID_SIDH                972
+#define OBJ_SIDH                OBJ_ISARA_Asymmetric,5L
+
+#define SN_sidh         "id-sidh"
+#define LN_sidh         "Supersingular-Isogeny-Diffie-Hellman-Key-Exchange"
+#define NID_sidh                973
+#define OBJ_sidh                OBJ_SIDH,0L
+
+#define SN_NTRUP                "NTRUP"
+#define NID_NTRUP               974
+#define OBJ_NTRUP               OBJ_ISARA_Asymmetric,6L
+
+#define SN_ntrup                "id-ntrup"
+#define LN_ntrup                "NTRUPrime-Key-Encapsulation"
+#define NID_ntrup               975
+#define OBJ_ntrup               OBJ_NTRUP,0L
+
+#define SN_KYBER                "KYBER"
+#define NID_KYBER               976
+#define OBJ_KYBER               OBJ_ISARA_Asymmetric,8L
+
+#define SN_kyber                "id-kyber"
+#define LN_kyber                "Kyber-Key-Encapsulation"
+#define NID_kyber               977
+#define OBJ_kyber               OBJ_KYBER,0L
+
+#define SN_DILITHIUM            "DILITHIUM"
+#define NID_DILITHIUM           978
+#define OBJ_DILITHIUM           OBJ_ISARA_Asymmetric,9L
+
+#define SN_dilithium            "id-dilithium"
+#define LN_dilithium            "Dilithium-Signature-Scheme"
+#define NID_dilithium           979
+#define OBJ_dilithium           OBJ_DILITHIUM,0L
+
+#define SN_FRODO                "FRODO"
+#define NID_FRODO               980
+#define OBJ_FRODO               OBJ_ISARA_Asymmetric,10L
+
+#define SN_frodokem             "id-frodo"
+#define LN_frodokem             "Frodo-Key-Encapsulation"
+#define NID_frodokem            981
+#define OBJ_frodokem            OBJ_FRODO,0L
+
+#define SN_SIKE         "SIKE"
+#define NID_SIKE                982
+#define OBJ_SIKE                OBJ_ISARA_Asymmetric,11L
+
+#define SN_sike         "id-sike"
+#define LN_sike         "Sike-Key-Encapsulation"
+#define NID_sike                983
+#define OBJ_sike                OBJ_SIKE,0L
+
+#define SN_hss          "id-alg-hss-lms-hashsig"
+#define LN_hss          "Hierarchical-Signature-Scheme"
+#define NID_hss         984
+#define OBJ_hss         OBJ_id_smime_alg,17L
+
+#define SN_XMSS         "XMSS"
+#define NID_XMSS                985
+#define OBJ_XMSS                OBJ_ISARA_Asymmetric,13L
+
+#define SN_xmss         "id-xmss"
+#define LN_xmss         "eXtended-Merkle-Signature-Scheme"
+#define NID_xmss                986
+#define OBJ_xmss                OBJ_XMSS,0L
+
+#define SN_XMSSMT               "XMSSMT"
+#define NID_XMSSMT              987
+#define OBJ_XMSSMT              OBJ_ISARA_Asymmetric,14L
+
+#define SN_xmssmt               "id-xmssmt"
+#define LN_xmssmt               "eXtended-Merkle-Signature-Scheme-Multi-Tree"
+#define NID_xmssmt              988
+#define OBJ_xmssmt              OBJ_XMSSMT,0L
+
+#define SN_CMC          "CMC"
+#define NID_CMC         989
+#define OBJ_CMC         OBJ_ISARA_Asymmetric,15L
+
+#define SN_cmc          "id-classic-mceliece"
+#define LN_cmc          "Classic-McEliece-Key-Encapsulation"
+#define NID_cmc         990
+#define OBJ_cmc         OBJ_CMC,0L
+
+#define SN_FRODODH              "FRODODH"
+#define NID_FRODODH             991
+#define OBJ_FRODODH             OBJ_ISARA_Asymmetric,17L
+
+#define SN_frododh              "id-frododh"
+#define LN_frododh              "FrodoDH-Key-Exchange"
+#define NID_frododh             992
+#define OBJ_frododh             OBJ_FRODODH,0L
+
+#define SN_SPHINCS_PLUS         "SPHINCS-PLUS"
+#define NID_SPHINCS_PLUS                993
+#define OBJ_SPHINCS_PLUS                OBJ_ISARA_Asymmetric,16L
+
+#define SN_sphincs              "id-sphincs-plus"
+#define LN_sphincs              "Sphincs-Plus-Signature-Scheme"
+#define NID_sphincs             994
+#define OBJ_sphincs             OBJ_SPHINCS_PLUS,0L
+
+#define SN_SAMWISE              "SAMWISE"
+#define NID_SAMWISE             995
+#define OBJ_SAMWISE             OBJ_ISARA_Asymmetric,18L
+
+#define SN_samwise              "id-samwise"
+#define LN_samwise              "Samwise-Key-Exchange"
+#define NID_samwise             996
+#define OBJ_samwise             OBJ_SAMWISE,0L
+
+#define SN_ISARA_Symmetric              "ISARA-Symmetric"
+#define NID_ISARA_Symmetric             997
+#define OBJ_ISARA_Symmetric             OBJ_ISARA_Algorithms,2L
+
+#define SN_ISARA_Extensions             "ISARA-Extensions"
+#define NID_ISARA_Extensions            998
+#define OBJ_ISARA_Extensions            OBJ_ISARA,2L
+
+#define SN_ISARA_Message_Extensions             "ISARA-Message-Extensions"
+#define NID_ISARA_Message_Extensions            999
+#define OBJ_ISARA_Message_Extensions            OBJ_ISARA_Extensions,2L
+
+#define SN_ISARA_CMS_Extensions         "ISARA-CMS-Extensions"
+#define NID_ISARA_CMS_Extensions                1000
+#define OBJ_ISARA_CMS_Extensions                OBJ_ISARA_Message_Extensions,1L
+
+#define SN_cmsAltSignatureAlgorithm             "cmsAltSigAlg"
+#define LN_cmsAltSignatureAlgorithm             "CMS-Alternative-Signature-Algorithm"
+#define NID_cmsAltSignatureAlgorithm            1001
+#define OBJ_cmsAltSignatureAlgorithm            OBJ_ISARA_CMS_Extensions,1L
+
+#define SN_cmsAltSignatureValue         "cmsAltSigVal"
+#define LN_cmsAltSignatureValue         "CMS-Alternative-Signature-Value"
+#define NID_cmsAltSignatureValue                1002
+#define OBJ_cmsAltSignatureValue                OBJ_ISARA_CMS_Extensions,2L
+
+#define SN_ISARA_Protocols              "ISARA-Protocols"
+#define NID_ISARA_Protocols             1003
+#define OBJ_ISARA_Protocols             OBJ_ISARA,4L
+
+#define SN_kt_kem               "kt-kem"
+#define NID_kt_kem              1004
+#define OBJ_kt_kem              OBJ_ISARA_Protocols,1L
+
+#define SN_isara_kem            "id-isara-kem"
+#define LN_isara_kem            "KEM-in-Key-Transport"
+#define NID_isara_kem           1005
+#define OBJ_isara_kem           OBJ_kt_kem,1L
+
+#define SN_ISARA_parameters             "ISARA-parameters"
+#define NID_ISARA_parameters            1006
+#define OBJ_ISARA_parameters            OBJ_ISARA,6L
+
+#define SN_rainbow_parameters           "rainbow-parameters"
+#define NID_rainbow_parameters          1007
+#define OBJ_rainbow_parameters          OBJ_ISARA_parameters,2L
+
+#define SN_Rainbow_IIIc_std_r2          "Rainbow_IIIc_std_r2"
+#define NID_Rainbow_IIIc_std_r2         1008
+#define OBJ_Rainbow_IIIc_std_r2         OBJ_rainbow_parameters,1L
+
+#define SN_Rainbow_Vc_std_r2            "Rainbow_Vc_std_r2"
+#define NID_Rainbow_Vc_std_r2           1009
+#define OBJ_Rainbow_Vc_std_r2           OBJ_rainbow_parameters,2L
+
+#define SN_sidh_parameters              "sidh-parameters"
+#define NID_sidh_parameters             1010
+#define OBJ_sidh_parameters             OBJ_ISARA_parameters,5L
+
+#define SN_SIDH_p503_r2         "SIDH_p503_r2"
+#define NID_SIDH_p503_r2                1011
+#define OBJ_SIDH_p503_r2                OBJ_sidh_parameters,1L
+
+#define SN_SIDH_p751_r2         "SIDH_p751_r2"
+#define NID_SIDH_p751_r2                1012
+#define OBJ_SIDH_p751_r2                OBJ_sidh_parameters,2L
+
+#define SN_ntrup_parameters             "ntrup-parameters"
+#define NID_ntrup_parameters            1013
+#define OBJ_ntrup_parameters            OBJ_ISARA_parameters,6L
+
+#define SN_NTRUPrime_sntrup761_r2               "NTRUPrime_sntrup761_r2"
+#define NID_NTRUPrime_sntrup761_r2              1014
+#define OBJ_NTRUPrime_sntrup761_r2              OBJ_ntrup_parameters,1L
+
+#define SN_kyber_parameters             "kyber-parameters"
+#define NID_kyber_parameters            1015
+#define OBJ_kyber_parameters            OBJ_ISARA_parameters,8L
+
+#define SN_Kyber_768_r2         "Kyber_768_r2"
+#define NID_Kyber_768_r2                1016
+#define OBJ_Kyber_768_r2                OBJ_kyber_parameters,1L
+
+#define SN_Kyber_1024_r2                "Kyber_1024_r2"
+#define NID_Kyber_1024_r2               1017
+#define OBJ_Kyber_1024_r2               OBJ_kyber_parameters,2L
+
+#define SN_dilithium_parameters         "dilithium-parameters"
+#define NID_dilithium_parameters                1018
+#define OBJ_dilithium_parameters                OBJ_ISARA_parameters,9L
+
+#define SN_Dilithium_III_SHAKE_r2               "Dilithium_III_SHAKE_r2"
+#define NID_Dilithium_III_SHAKE_r2              1019
+#define OBJ_Dilithium_III_SHAKE_r2              OBJ_dilithium_parameters,1L
+
+#define SN_Dilithium_IV_SHAKE_r2                "Dilithium_IV_SHAKE_r2"
+#define NID_Dilithium_IV_SHAKE_r2               1020
+#define OBJ_Dilithium_IV_SHAKE_r2               OBJ_dilithium_parameters,2L
+
+#define SN_frodokem_parameters          "frodokem-parameters"
+#define NID_frodokem_parameters         1021
+#define OBJ_frodokem_parameters         OBJ_ISARA_parameters,10L
+
+#define SN_FrodoKEM_976_AES_r2          "FrodoKEM_976_AES_r2"
+#define NID_FrodoKEM_976_AES_r2         1022
+#define OBJ_FrodoKEM_976_AES_r2         OBJ_frodokem_parameters,1L
+
+#define SN_FrodoKEM_976_SHAKE_r2                "FrodoKEM_976_SHAKE_r2"
+#define NID_FrodoKEM_976_SHAKE_r2               1023
+#define OBJ_FrodoKEM_976_SHAKE_r2               OBJ_frodokem_parameters,2L
+
+#define SN_sike_parameters              "sike-parameters"
+#define NID_sike_parameters             1024
+#define OBJ_sike_parameters             OBJ_ISARA_parameters,11L
+
+#define SN_SIKE_p503_r2         "SIKE_p503_r2"
+#define NID_SIKE_p503_r2                1025
+#define OBJ_SIKE_p503_r2                OBJ_sike_parameters,1L
+
+#define SN_SIKE_p751_r2         "SIKE_p751_r2"
+#define NID_SIKE_p751_r2                1026
+#define OBJ_SIKE_p751_r2                OBJ_sike_parameters,2L
+
+#define SN_cmc_parameters               "cmc-parameters"
+#define NID_cmc_parameters              1027
+#define OBJ_cmc_parameters              OBJ_ISARA_parameters,15L
+
+#define SN_CMC_6960119_r2               "CMC_6960119_r2"
+#define NID_CMC_6960119_r2              1028
+#define OBJ_CMC_6960119_r2              OBJ_cmc_parameters,1L
+
+#define SN_CMC_8192128_r2               "CMC_8192128_r2"
+#define NID_CMC_8192128_r2              1029
+#define OBJ_CMC_8192128_r2              OBJ_cmc_parameters,2L
+
+#define SN_sphincs_plus_parameters              "sphincs-plus-parameters"
+#define NID_sphincs_plus_parameters             1030
+#define OBJ_sphincs_plus_parameters             OBJ_ISARA_parameters,16L
+
+#define SN_SPHINCS_SHAKE_256_192f_r2            "SPHINCS_SHAKE_256_192f_r2"
+#define NID_SPHINCS_SHAKE_256_192f_r2           1031
+#define OBJ_SPHINCS_SHAKE_256_192f_r2           OBJ_sphincs_plus_parameters,1L
+
+#define SN_SPHINCS_SHAKE_256_192s_r2            "SPHINCS_SHAKE_256_192s_r2"
+#define NID_SPHINCS_SHAKE_256_192s_r2           1032
+#define OBJ_SPHINCS_SHAKE_256_192s_r2           OBJ_sphincs_plus_parameters,2L
+
+#define SN_SPHINCS_SHAKE_256_256f_r2            "SPHINCS_SHAKE_256_256f_r2"
+#define NID_SPHINCS_SHAKE_256_256f_r2           1033
+#define OBJ_SPHINCS_SHAKE_256_256f_r2           OBJ_sphincs_plus_parameters,3L
+
+#define SN_SPHINCS_SHAKE_256_256s_r2            "SPHINCS_SHAKE_256_256s_r2"
+#define NID_SPHINCS_SHAKE_256_256s_r2           1034
+#define OBJ_SPHINCS_SHAKE_256_256s_r2           OBJ_sphincs_plus_parameters,4L
+
+#define SN_SPHINCS_SHA2_256_192f_r2             "SPHINCS_SHA2_256_192f_r2"
+#define NID_SPHINCS_SHA2_256_192f_r2            1035
+#define OBJ_SPHINCS_SHA2_256_192f_r2            OBJ_sphincs_plus_parameters,5L
+
+#define SN_SPHINCS_SHA2_256_192s_r2             "SPHINCS_SHA2_256_192s_r2"
+#define NID_SPHINCS_SHA2_256_192s_r2            1036
+#define OBJ_SPHINCS_SHA2_256_192s_r2            OBJ_sphincs_plus_parameters,6L
+
+#define SN_SPHINCS_SHA2_256_256f_r2             "SPHINCS_SHA2_256_256f_r2"
+#define NID_SPHINCS_SHA2_256_256f_r2            1037
+#define OBJ_SPHINCS_SHA2_256_256f_r2            OBJ_sphincs_plus_parameters,7L
+
+#define SN_SPHINCS_SHA2_256_256s_r2             "SPHINCS_SHA2_256_256s_r2"
+#define NID_SPHINCS_SHA2_256_256s_r2            1038
+#define OBJ_SPHINCS_SHA2_256_256s_r2            OBJ_sphincs_plus_parameters,8L
+
+#define SN_frododh_parameters           "frododh-parameters"
+#define NID_frododh_parameters          1039
+#define OBJ_frododh_parameters          OBJ_ISARA_parameters,17L
+
+#define SN_FrodoDH_976_AES_r2           "FrodoDH_976_AES_r2"
+#define NID_FrodoDH_976_AES_r2          1040
+#define OBJ_FrodoDH_976_AES_r2          OBJ_frododh_parameters,1L
+
+#define SN_FrodoDH_976_SHAKE_r2         "FrodoDH_976_SHAKE_r2"
+#define NID_FrodoDH_976_SHAKE_r2                1041
+#define OBJ_FrodoDH_976_SHAKE_r2                OBJ_frododh_parameters,2L
+
+#define SN_samwise_parameters           "samwise-parameters"
+#define NID_samwise_parameters          1042
+#define OBJ_samwise_parameters          OBJ_ISARA_parameters,18L
+
+#define SN_Samwise_976_AES_v1           "Samwise_976_AES_v1"
+#define NID_Samwise_976_AES_v1          1043
+#define OBJ_Samwise_976_AES_v1          OBJ_samwise_parameters,1L
+
+#define SN_Samwise_976_ChaCha20_v1              "Samwise_976_ChaCha20_v1"
+#define NID_Samwise_976_ChaCha20_v1             1044
+#define OBJ_Samwise_976_ChaCha20_v1             OBJ_samwise_parameters,2L
+
+#define SN_nhdh_parameters              "nhdh-parameters"
+#define NID_nhdh_parameters             1045
+#define OBJ_nhdh_parameters             OBJ_ISARA_parameters,19L
+
+#define SN_NewHope_1024_v0              "NewHope_1024_v0"
+#define NID_NewHope_1024_v0             1046
+#define OBJ_NewHope_1024_v0             OBJ_nhdh_parameters,1L
+
 #define SN_data         "data"
 #define NID_data                434
 #define OBJ_data                OBJ_itu_t,9L
diff --git a/openssl-1.0.2r/crypto/objects/obj_mac.num b/openssl-1.0.2r/crypto/objects/obj_mac.num
index 8e5ea833..3910f1a7 100644
--- a/openssl-1.0.2r/crypto/objects/obj_mac.num
+++ b/openssl-1.0.2r/crypto/objects/obj_mac.num
@@ -955,3 +955,92 @@ ct_cert_scts		954
 jurisdictionLocalityName		955
 jurisdictionStateOrProvinceName		956
 jurisdictionCountryName		957
+subjectAltPublicKeyInfo		958
+altSignatureAlgorithm		959
+altSignatureValue		960
+identified_org		961
+etsi		962
+reserved		963
+etsi_identified_org		964
+ISARA		965
+ISARA_Algorithms		966
+ISARA_Asymmetric		967
+RAINBOW		968
+rainbow		969
+NHDH		970
+nhdh		971
+SIDH		972
+sidh		973
+NTRUP		974
+ntrup		975
+KYBER		976
+kyber		977
+DILITHIUM		978
+dilithium		979
+FRODO		980
+frodokem		981
+SIKE		982
+sike		983
+hss		984
+XMSS		985
+xmss		986
+XMSSMT		987
+xmssmt		988
+CMC		989
+cmc		990
+FRODODH		991
+frododh		992
+SPHINCS_PLUS		993
+sphincs		994
+SAMWISE		995
+samwise		996
+ISARA_Symmetric		997
+ISARA_Extensions		998
+ISARA_Message_Extensions		999
+ISARA_CMS_Extensions		1000
+cmsAltSignatureAlgorithm		1001
+cmsAltSignatureValue		1002
+ISARA_Protocols		1003
+kt_kem		1004
+isara_kem		1005
+ISARA_parameters		1006
+rainbow_parameters		1007
+Rainbow_IIIc_std_r2		1008
+Rainbow_Vc_std_r2		1009
+sidh_parameters		1010
+SIDH_p503_r2		1011
+SIDH_p751_r2		1012
+ntrup_parameters		1013
+NTRUPrime_sntrup761_r2		1014
+kyber_parameters		1015
+Kyber_768_r2		1016
+Kyber_1024_r2		1017
+dilithium_parameters		1018
+Dilithium_III_SHAKE_r2		1019
+Dilithium_IV_SHAKE_r2		1020
+frodokem_parameters		1021
+FrodoKEM_976_AES_r2		1022
+FrodoKEM_976_SHAKE_r2		1023
+sike_parameters		1024
+SIKE_p503_r2		1025
+SIKE_p751_r2		1026
+cmc_parameters		1027
+CMC_6960119_r2		1028
+CMC_8192128_r2		1029
+sphincs_plus_parameters		1030
+SPHINCS_SHAKE_256_192f_r2		1031
+SPHINCS_SHAKE_256_192s_r2		1032
+SPHINCS_SHAKE_256_256f_r2		1033
+SPHINCS_SHAKE_256_256s_r2		1034
+SPHINCS_SHA2_256_192f_r2		1035
+SPHINCS_SHA2_256_192s_r2		1036
+SPHINCS_SHA2_256_256f_r2		1037
+SPHINCS_SHA2_256_256s_r2		1038
+frododh_parameters		1039
+FrodoDH_976_AES_r2		1040
+FrodoDH_976_SHAKE_r2		1041
+samwise_parameters		1042
+Samwise_976_AES_v1		1043
+Samwise_976_ChaCha20_v1		1044
+nhdh_parameters		1045
+NewHope_1024_v0		1046
diff --git a/openssl-1.0.2r/crypto/objects/obj_xref.c b/openssl-1.0.2r/crypto/objects/obj_xref.c
index 97b305d2..6a677f04 100644
--- a/openssl-1.0.2r/crypto/objects/obj_xref.c
+++ b/openssl-1.0.2r/crypto/objects/obj_xref.c
@@ -121,6 +121,30 @@ int OBJ_find_sigid_by_algs(int *psignid, int dig_nid, int pkey_nid)
     const nid_triple *t = &tmp;
     const nid_triple **rv = NULL;
 
+    /* From the objxref.pl script:
+     *
+     * > If digest or signature algorithm is "undef" then the algorithm
+     * > needs special handling and is excluded from the cross reference
+     * > table...
+     *
+     * This is "special". We don't want to have an effect on other algorithms
+     * that were not added by ISARA. They will have their own "special"
+     * handling. So, we create some ISARA-specific "special" logic here.
+     */
+    if ((dig_nid == NID_undef)
+        && ((pkey_nid == NID_dilithium)
+            || (pkey_nid == NID_rainbow)
+            || (pkey_nid == NID_sphincs)
+            || (pkey_nid == NID_hss)
+            || (pkey_nid == NID_xmss)
+            || (pkey_nid == NID_xmssmt))
+       ) {
+        if (psignid) {
+            *psignid = pkey_nid;
+        }
+        return 1;
+    }
+
     tmp.hash_id = dig_nid;
     tmp.pkey_id = pkey_nid;
 
diff --git a/openssl-1.0.2r/crypto/objects/obj_xref.h b/openssl-1.0.2r/crypto/objects/obj_xref.h
index e453e99f..10c2d0d1 100644
--- a/openssl-1.0.2r/crypto/objects/obj_xref.h
+++ b/openssl-1.0.2r/crypto/objects/obj_xref.h
@@ -56,6 +56,12 @@ static const nid_triple sigoid_srt[] = {
      NID_dh_cofactor_kdf},
     {NID_dhSinglePass_cofactorDH_sha512kdf_scheme, NID_sha512,
      NID_dh_cofactor_kdf},
+    {NID_rainbow, NID_undef, NID_rainbow},
+    {NID_dilithium, NID_undef, NID_dilithium},
+    {NID_hss, NID_undef, NID_hss},
+    {NID_xmss, NID_undef, NID_xmss},
+    {NID_xmssmt, NID_undef, NID_xmssmt},
+    {NID_sphincs, NID_undef, NID_sphincs},
 };
 
 static const nid_triple *const sigoid_srt_xref[] = {
diff --git a/openssl-1.0.2r/crypto/objects/obj_xref.txt b/openssl-1.0.2r/crypto/objects/obj_xref.txt
index 19c94226..3a98ab85 100644
--- a/openssl-1.0.2r/crypto/objects/obj_xref.txt
+++ b/openssl-1.0.2r/crypto/objects/obj_xref.txt
@@ -56,3 +56,10 @@ dhSinglePass_cofactorDH_sha224kdf_scheme	sha224	dh_cofactor_kdf
 dhSinglePass_cofactorDH_sha256kdf_scheme	sha256	dh_cofactor_kdf
 dhSinglePass_cofactorDH_sha384kdf_scheme	sha384	dh_cofactor_kdf
 dhSinglePass_cofactorDH_sha512kdf_scheme	sha512	dh_cofactor_kdf
+
+dilithium			undef	dilithium
+sphincs				undef	sphincs
+rainbow				undef	rainbow
+hss				undef   hss
+xmss  				undef   xmss
+xmssmt				undef   xmssmt
diff --git a/openssl-1.0.2r/crypto/objects/objects.txt b/openssl-1.0.2r/crypto/objects/objects.txt
index b57aabb2..5d8cc2cd 100644
--- a/openssl-1.0.2r/crypto/objects/objects.txt
+++ b/openssl-1.0.2r/crypto/objects/objects.txt
@@ -34,7 +34,6 @@ X9-57 4			: X9cm			: X9.57 CM ?
 X9cm 1			: DSA			: dsaEncryption
 X9cm 3			: DSA-SHA1		: dsaWithSHA1
 
-
 ISO-US 10045		: ansi-X9-62		: ANSI X9.62
 !module X9-62
 !Alias id-fieldType ansi-X9-62 1
@@ -775,6 +774,12 @@ id-ce 54		: inhibitAnyPolicy	: X509v3 Inhibit Any Policy
 id-ce 55		: targetInformation	: X509v3 AC Targeting
 !Cname no-rev-avail
 id-ce 56		: noRevAvail		: X509v3 No Revocation Available
+!Cname subjectAltPublicKeyInfo
+id-ce 72        : altSub            : Subject Alternative Public Key
+!Cname altSignatureAlgorithm
+id-ce 73        : altSigalg         : Alternative Signature Algorithm
+!Cname altSignatureValue
+id-ce 74        : altSigVal         : Alternative Signature Value
 
 # From RFC5280
 ext-key-usage 0		: anyExtendedKeyUsage	: Any Extended Key Usage
@@ -924,8 +929,201 @@ holdInstruction 2	: holdInstructionCallIssuer : Hold Instruction Call Issuer
 !Cname hold-instruction-reject
 holdInstruction 3	: holdInstructionReject	: Hold Instruction Reject
 
+# ====== ISARA Addition Begin ======
+
+itu-t 4                             : identified-org
+
+identified-org 0                    : etsi
+
+etsi 127                            : reserved
+
+reserved 0                          : etsi-identified-org
+
+etsi-identified-org 15              : ISARA
+
+ISARA 1                             : ISARA-Algorithms
+
+ISARA-Algorithms 1                  : ISARA-Asymmetric
+
+ISARA-Asymmetric 2                  : RAINBOW
+!Cname rainbow
+RAINBOW 0                           : id-rainbow   : Rainbow-Signature-Scheme
+
+ISARA-Asymmetric 3                  : NHDH
+!Cname nhdh
+NHDH 0                              : id-nhdh      : NewHope-Diffie-Hellman-Key-Exchange
+
+ISARA-Asymmetric 5                  : SIDH
+!Cname sidh
+SIDH 0                              : id-sidh      : Supersingular-Isogeny-Diffie-Hellman-Key-Exchange
+
+ISARA-Asymmetric 6                  : NTRUP
+!Cname ntrup
+NTRUP 0                             : id-ntrup     : NTRUPrime-Key-Encapsulation
+
+ISARA-Asymmetric 8                  : KYBER
+!Cname kyber
+KYBER 0                             : id-kyber     : Kyber-Key-Encapsulation
+
+ISARA-Asymmetric 9                  : DILITHIUM
+!Cname dilithium
+DILITHIUM 0                         : id-dilithium : Dilithium-Signature-Scheme
+
+ISARA-Asymmetric 10                 : FRODO
+!Cname frodokem
+FRODO 0                             : id-frodo     : Frodo-Key-Encapsulation
+
+ISARA-Asymmetric 11                 : SIKE
+!Cname sike
+SIKE 0                              : id-sike      : Sike-Key-Encapsulation
+
+#Note that this is under the SMIME arc!
+!Cname hss
+id-smime-alg 17                     : id-alg-hss-lms-hashsig       : Hierarchical-Signature-Scheme
+
+ISARA-Asymmetric 13                 : XMSS
+!Cname xmss
+XMSS 0                              : id-xmss      : eXtended-Merkle-Signature-Scheme 
+
+ISARA-Asymmetric 14                 : XMSSMT
+!Cname xmssmt
+XMSSMT 0                            : id-xmssmt      : eXtended-Merkle-Signature-Scheme-Multi-Tree
+
+ISARA-Asymmetric 15                 : CMC
+!Cname cmc
+CMC 0                               : id-classic-mceliece      : Classic-McEliece-Key-Encapsulation
+
+ISARA-Asymmetric 17                 : FRODODH
+!Cname frododh
+FRODODH 0                           : id-frododh     : FrodoDH-Key-Exchange
+
+ISARA-Asymmetric 16                 : SPHINCS-PLUS
+!Cname sphincs
+SPHINCS-PLUS 0                      : id-sphincs-plus : Sphincs-Plus-Signature-Scheme
+
+ISARA-Asymmetric 18                 : SAMWISE
+!Cname samwise
+SAMWISE 0                           : id-samwise     : Samwise-Key-Exchange
+
+ISARA-Algorithms 2                  : ISARA-Symmetric
+
+ISARA 2                             : ISARA-Extensions
+
+ISARA-Extensions 2                  : ISARA-Message-Extensions
+
+ISARA-Message-Extensions 1          : ISARA-CMS-Extensions
+
+!Cname cmsAltSignatureAlgorithm
+ISARA-CMS-Extensions 1              : cmsAltSigAlg : CMS-Alternative-Signature-Algorithm
+!Cname cmsAltSignatureValue
+ISARA-CMS-Extensions 2              : cmsAltSigVal : CMS-Alternative-Signature-Value
+
+ISARA 4                             : ISARA-Protocols
+
+ISARA-Protocols 1                   : kt-kem
+
+!Cname isara-kem
+kt-kem 1                            : id-isara-kem : KEM-in-Key-Transport
+
+ISARA 6                             : ISARA-parameters
+
+ISARA-parameters 2                  : rainbow-parameters
+
+!Cname Rainbow_IIIc_std_r2
+rainbow-parameters 1                : Rainbow_IIIc_std_r2
+!Cname Rainbow_Vc_std_r2
+rainbow-parameters 2                : Rainbow_Vc_std_r2
+
+ISARA-parameters 5                  : sidh-parameters
+
+!Cname SIDH_p503_r2
+sidh-parameters 1                   : SIDH_p503_r2
+!Cname SIDH_p751_r2
+sidh-parameters 2                   : SIDH_p751_r2
+
+ISARA-parameters 6                  : ntrup-parameters
+
+!Cname NTRUPrime_sntrup761_r2
+ntrup-parameters 1                  : NTRUPrime_sntrup761_r2
+
+ISARA-parameters 8                  : kyber-parameters
+
+!Cname Kyber_768_r2
+kyber-parameters 1                  : Kyber_768_r2
+!Cname Kyber_1024_r2
+kyber-parameters 2                  : Kyber_1024_r2
+
+ISARA-parameters 9                  : dilithium-parameters
+
+!Cname Dilithium_III_SHAKE_r2
+dilithium-parameters 1              : Dilithium_III_SHAKE_r2
+!Cname Dilithium_IV_SHAKE_r2
+dilithium-parameters 2              : Dilithium_IV_SHAKE_r2
+
+ISARA-parameters 10                 : frodokem-parameters
+
+!Cname FrodoKEM_976_AES_r2
+frodokem-parameters 1               : FrodoKEM_976_AES_r2
+!Cname FrodoKEM_976_SHAKE_r2
+frodokem-parameters 2               : FrodoKEM_976_SHAKE_r2
+
+ISARA-parameters 11                 : sike-parameters
+
+!Cname SIKE_p503_r2
+sike-parameters 1                   : SIKE_p503_r2
+!Cname SIKE_p751_r2
+sike-parameters 2                   : SIKE_p751_r2
+
+ISARA-parameters 15                 : cmc-parameters
+
+!Cname CMC_6960119_r2
+cmc-parameters 1                    : CMC_6960119_r2
+!Cname CMC_8192128_r2
+cmc-parameters 2                    : CMC_8192128_r2
+
+ISARA-parameters 16                 : sphincs-plus-parameters
+
+!Cname SPHINCS_SHAKE_256_192f_r2
+sphincs-plus-parameters 1           : SPHINCS_SHAKE_256_192f_r2
+!Cname SPHINCS_SHAKE_256_192s_r2
+sphincs-plus-parameters 2           : SPHINCS_SHAKE_256_192s_r2
+!Cname SPHINCS_SHAKE_256_256f_r2
+sphincs-plus-parameters 3           : SPHINCS_SHAKE_256_256f_r2
+!Cname SPHINCS_SHAKE_256_256s_r2
+sphincs-plus-parameters 4           : SPHINCS_SHAKE_256_256s_r2
+!Cname SPHINCS_SHA2_256_192f_r2
+sphincs-plus-parameters 5           : SPHINCS_SHA2_256_192f_r2
+!Cname SPHINCS_SHA2_256_192s_r2
+sphincs-plus-parameters 6           : SPHINCS_SHA2_256_192s_r2
+!Cname SPHINCS_SHA2_256_256f_r2
+sphincs-plus-parameters 7           : SPHINCS_SHA2_256_256f_r2
+!Cname SPHINCS_SHA2_256_256s_r2
+sphincs-plus-parameters 8           : SPHINCS_SHA2_256_256s_r2
+
+ISARA-parameters 17                 : frododh-parameters
+
+!Cname FrodoDH_976_AES_r2
+frododh-parameters 1                : FrodoDH_976_AES_r2
+!Cname FrodoDH_976_SHAKE_r2
+frododh-parameters 2                : FrodoDH_976_SHAKE_r2
+
+ISARA-parameters 18                 : samwise-parameters
+
+!Cname Samwise_976_AES_v1
+samwise-parameters 1                : Samwise_976_AES_v1
+!Cname Samwise_976_ChaCha20_v1
+samwise-parameters 2                : Samwise_976_ChaCha20_v1
+
+ISARA-parameters 19                 : nhdh-parameters
+
+!Cname NewHope_1024_v0
+nhdh-parameters 1                   : NewHope_1024_v0
+
+# ======= ISARA Addition End =======
+
 # OID's from ITU-T.  Most of this is defined in RFC 1274.  A couple of
 # them are also mentioned in RFC 2247
+
 itu-t 9			: data
 data 2342		: pss
 pss 19200300		: ucl
diff --git a/openssl-1.0.2r/crypto/ossl_typ.h b/openssl-1.0.2r/crypto/ossl_typ.h
index 364d2623..04b6ee26 100644
--- a/openssl-1.0.2r/crypto/ossl_typ.h
+++ b/openssl-1.0.2r/crypto/ossl_typ.h
@@ -143,6 +143,22 @@ typedef struct dh_method DH_METHOD;
 typedef struct dsa_st DSA;
 typedef struct dsa_method DSA_METHOD;
 
+typedef struct hss_st HSS;
+typedef struct xmss_st XMSS;
+typedef struct xmssmt_st XMSSMT;
+typedef struct dilithium_st DILITHIUM;
+typedef struct sphincs_st SPHINCS;
+typedef struct frododh_st FRODODH;
+typedef struct samwise_st SAMWISE;
+typedef struct rainbow_st RAINBOW;
+typedef struct nhdh_st NHDH;
+typedef struct sidh_st SIDH;
+typedef struct cmc_st CMC;
+typedef struct ntrup_st NTRUP;
+typedef struct kyber_st KYBER;
+typedef struct sike_st SIKE;
+typedef struct frodokem_st FRODOKEM;
+
 typedef struct rsa_st RSA;
 typedef struct rsa_meth_st RSA_METHOD;
 
diff --git a/openssl-1.0.2r/crypto/pem/pem.h b/openssl-1.0.2r/crypto/pem/pem.h
index 9c1d939a..1f9fc21d 100644
--- a/openssl-1.0.2r/crypto/pem/pem.h
+++ b/openssl-1.0.2r/crypto/pem/pem.h
@@ -119,19 +119,37 @@ extern "C" {
 # define PEM_STRING_X509_REQ     "CERTIFICATE REQUEST"
 # define PEM_STRING_X509_CRL     "X509 CRL"
 # define PEM_STRING_EVP_PKEY     "ANY PRIVATE KEY"
+# define PEM_STRING_EVP_ALT_PKEY "ANY ALT PRIVATE KEY"
 # define PEM_STRING_PUBLIC       "PUBLIC KEY"
 # define PEM_STRING_RSA          "RSA PRIVATE KEY"
 # define PEM_STRING_RSA_PUBLIC   "RSA PUBLIC KEY"
 # define PEM_STRING_DSA          "DSA PRIVATE KEY"
 # define PEM_STRING_DSA_PUBLIC   "DSA PUBLIC KEY"
+# define PEM_STRING_HSS          "HSS PRIVATE KEY"
+# define PEM_STRING_HSS_PUBLIC   "HSS PUBLIC KEY"
+# define PEM_STRING_XMSS          "XMSS PRIVATE KEY"
+# define PEM_STRING_XMSS_PUBLIC   "XMSS PUBLIC KEY"
+# define PEM_STRING_XMSSMT          "XMSSMT PRIVATE KEY"
+# define PEM_STRING_XMSSMT_PUBLIC   "XMSSMT PUBLIC KEY"
+# define PEM_STRING_DILITHIUM        "DILITHIUM PRIVATE KEY"
+# define PEM_STRING_DILITHIUM_PUBLIC "DILITHIUM PUBLIC KEY"
+# define PEM_STRING_SPHINCS        "SPHINCS PRIVATE KEY"
+# define PEM_STRING_SPHINCS_PUBLIC "SPHINCS PUBLIC KEY"
+# define PEM_STRING_RAINBOW        "RAINBOW PRIVATE KEY"
+# define PEM_STRING_RAINBOW_PUBLIC "RAINBOW PUBLIC KEY"
 # define PEM_STRING_PKCS7        "PKCS7"
 # define PEM_STRING_PKCS7_SIGNED "PKCS #7 SIGNED DATA"
 # define PEM_STRING_PKCS8        "ENCRYPTED PRIVATE KEY"
 # define PEM_STRING_PKCS8INF     "PRIVATE KEY"
+# define PEM_STRING_ALT_PKCS8        "ENCRYPTED ALT PRIVATE KEY"
+# define PEM_STRING_ALT_PKCS8INF     "ALT PRIVATE KEY"
 # define PEM_STRING_DHPARAMS     "DH PARAMETERS"
 # define PEM_STRING_DHXPARAMS    "X9.42 DH PARAMETERS"
 # define PEM_STRING_SSL_SESSION  "SSL SESSION PARAMETERS"
 # define PEM_STRING_DSAPARAMS    "DSA PARAMETERS"
+# define PEM_STRING_DILITHIUMPARAMS "DILITHIUM PARAMETERS"
+# define PEM_STRING_SPHINCSPARAMS "SPHINCS PARAMETERS"
+# define PEM_STRING_RAINBOWPARAMS "RAINBOW PARAMETERS"
 # define PEM_STRING_ECDSA_PUBLIC "ECDSA PUBLIC KEY"
 # define PEM_STRING_ECPARAMETERS "EC PARAMETERS"
 # define PEM_STRING_ECPRIVATEKEY "EC PRIVATE KEY"
@@ -469,6 +487,30 @@ DECLARE_PEM_rw_cb(DSAPrivateKey, DSA)
 DECLARE_PEM_rw(DSA_PUBKEY, DSA)
 DECLARE_PEM_rw_const(DSAparams, DSA)
 # endif
+# ifndef OPENSSL_NO_HSS
+DECLARE_PEM_rw_cb(HSSPrivateKey, HSS)
+DECLARE_PEM_rw(HSS_PUBKEY, HSS)
+# endif
+# ifndef OPENSSL_NO_XMSS
+DECLARE_PEM_rw_cb(XMSSPrivateKey, XMSS)
+DECLARE_PEM_rw(XMSS_PUBKEY, XMSS)
+# endif
+# ifndef OPENSSL_NO_XMSSMT
+DECLARE_PEM_rw_cb(XMSSMTPrivateKey, XMSSMT)
+DECLARE_PEM_rw(XMSSMT_PUBKEY, XMSSMT)
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+DECLARE_PEM_rw_cb(DILITHIUMPrivateKey, DILITHIUM)
+DECLARE_PEM_rw(DILITHIUM_PUBKEY, DILITHIUM)
+# endif
+# ifndef OPENSSL_NO_SPHINCS
+DECLARE_PEM_rw_cb(SPHINCSPrivateKey, SPHINCS)
+DECLARE_PEM_rw(SPHINCS_PUBKEY, SPHINCS)
+# endif
+# ifndef OPENSSL_NO_RAINBOW
+DECLARE_PEM_rw_cb(RAINBOWPrivateKey, RAINBOW)
+DECLARE_PEM_rw(RAINBOW_PUBKEY, RAINBOW)
+# endif
 # ifndef OPENSSL_NO_EC
 DECLARE_PEM_rw_const(ECPKParameters, EC_GROUP)
 DECLARE_PEM_rw_cb(ECPrivateKey, EC_KEY)
@@ -481,11 +523,15 @@ DECLARE_PEM_write_const(DHxparams, DH)
 DECLARE_PEM_rw_cb(PrivateKey, EVP_PKEY)
 DECLARE_PEM_rw(PUBKEY, EVP_PKEY)
 
+EVP_PKEY *PEM_read_bio_ALTPrivateKey(BIO *bp, EVP_PKEY **x,
+                                     pem_password_cb *cb, void *u);
 int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                       char *kstr, int klen,
                                       pem_password_cb *cb, void *u);
 int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
                                   char *, int, pem_password_cb *, void *);
+int PEM_write_bio_ALT_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
+                                  char *, int, pem_password_cb *, void *);
 int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                             char *kstr, int klen,
                             pem_password_cb *cb, void *u);
@@ -569,6 +615,7 @@ void ERR_load_PEM_strings(void);
 # define PEM_F_PEM_READ_BIO_DHPARAMS                      141
 # define PEM_F_PEM_READ_BIO_PARAMETERS                    140
 # define PEM_F_PEM_READ_BIO_PRIVATEKEY                    123
+# define PEM_F_PEM_READ_BIO_PRIVATEKEY_LOCAL              143
 # define PEM_F_PEM_READ_DHPARAMS                          142
 # define PEM_F_PEM_READ_PRIVATEKEY                        124
 # define PEM_F_PEM_SEALFINAL                              110
diff --git a/openssl-1.0.2r/crypto/pem/pem_all.c b/openssl-1.0.2r/crypto/pem/pem_all.c
index 0e5be63e..f31d2a6c 100644
--- a/openssl-1.0.2r/crypto/pem/pem_all.c
+++ b/openssl-1.0.2r/crypto/pem/pem_all.c
@@ -125,6 +125,24 @@
 #ifndef OPENSSL_NO_DH
 # include <openssl/dh.h>
 #endif
+#ifndef OPENSSL_NO_HSS
+# include <openssl/hss.h>
+#endif
+#ifndef OPENSSL_NO_XMSS
+# include <openssl/xmss.h>
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+# include <openssl/xmssmt.h>
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+# include <openssl/sphincs.h>
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+# include <openssl/rainbow.h>
+#endif
 
 #ifndef OPENSSL_NO_RSA
 static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa);
@@ -330,6 +348,249 @@ DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb, void *u)
 
 IMPLEMENT_PEM_rw_const(DSAparams, DSA, PEM_STRING_DSAPARAMS, DSAparams)
 #endif
+
+#ifndef OPENSSL_NO_HSS
+static HSS *pkey_get_hss(EVP_PKEY *key, HSS **hss)
+{
+    HSS *ltmp;
+    if (!key)
+        return NULL;
+    ltmp = EVP_PKEY_get1_HSS(key);
+    EVP_PKEY_free(key);
+    if (!ltmp)
+        return NULL;
+    if (hss) {
+        HSS_free(*hss);
+        *hss = ltmp;
+    }
+    return ltmp;
+}
+
+HSS *PEM_read_bio_HSSPrivateKey(BIO *bp, HSS **hss, pem_password_cb *cb,
+                                void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
+    return pkey_get_hss(pktmp, hss); /* will free pktmp */
+}
+
+IMPLEMENT_PEM_write_cb_const(HSSPrivateKey, HSS, PEM_STRING_HSS,
+                             HSSPrivateKey)
+
+    IMPLEMENT_PEM_rw(HSS_PUBKEY, HSS, PEM_STRING_PUBLIC, HSS_PUBKEY)
+# ifndef OPENSSL_NO_FP_API
+HSS *PEM_read_HSSPrivateKey(FILE *fp, HSS **hss, pem_password_cb *cb, void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
+    return pkey_get_hss(pktmp, hss); /* will free pktmp */
+}
+
+# endif
+#endif
+
+#ifndef OPENSSL_NO_XMSS
+static XMSS *pkey_get_xmss(EVP_PKEY *key, XMSS **xmss)
+{
+    XMSS *ltmp;
+    if (!key)
+        return NULL;
+    ltmp = EVP_PKEY_get1_XMSS(key);
+    EVP_PKEY_free(key);
+    if (!ltmp)
+        return NULL;
+    if (xmss) {
+        XMSS_free(*xmss);
+        *xmss = ltmp;
+    }
+    return ltmp;
+}
+
+XMSS *PEM_read_bio_XMSSPrivateKey(BIO *bp, XMSS **xmss, pem_password_cb *cb,
+                                void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
+    return pkey_get_xmss(pktmp, xmss); /* will free pktmp */
+}
+
+IMPLEMENT_PEM_write_cb_const(XMSSPrivateKey, XMSS, PEM_STRING_XMSS,
+                             XMSSPrivateKey)
+
+    IMPLEMENT_PEM_rw(XMSS_PUBKEY, XMSS, PEM_STRING_PUBLIC, XMSS_PUBKEY)
+# ifndef OPENSSL_NO_FP_API
+XMSS *PEM_read_XMSSPrivateKey(FILE *fp, XMSS **xmss, pem_password_cb *cb, void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
+    return pkey_get_xmss(pktmp, xmss); /* will free pktmp */
+}
+
+# endif
+#endif
+
+#ifndef OPENSSL_NO_XMSSMT
+static XMSSMT *pkey_get_xmssmt(EVP_PKEY *key, XMSSMT **xmssmt)
+{
+    XMSSMT *ltmp;
+    if (!key)
+        return NULL;
+    ltmp = EVP_PKEY_get1_XMSSMT(key);
+    EVP_PKEY_free(key);
+    if (!ltmp)
+        return NULL;
+    if (xmssmt) {
+        XMSSMT_free(*xmssmt);
+        *xmssmt = ltmp;
+    }
+    return ltmp;
+}
+
+XMSSMT *PEM_read_bio_XMSSMTPrivateKey(BIO *bp, XMSSMT **xmssmt, pem_password_cb *cb,
+                                void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
+    return pkey_get_xmssmt(pktmp, xmssmt); /* will free pktmp */
+}
+
+IMPLEMENT_PEM_write_cb_const(XMSSMTPrivateKey, XMSSMT, PEM_STRING_XMSSMT,
+                             XMSSMTPrivateKey)
+
+    IMPLEMENT_PEM_rw(XMSSMT_PUBKEY, XMSSMT, PEM_STRING_PUBLIC, XMSSMT_PUBKEY)
+# ifndef OPENSSL_NO_FP_API
+XMSSMT *PEM_read_XMSSMTPrivateKey(FILE *fp, XMSSMT **xmssmt, pem_password_cb *cb, void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
+    return pkey_get_xmssmt(pktmp, xmssmt); /* will free pktmp */
+}
+
+# endif
+
+#endif
+
+#ifndef OPENSSL_NO_DILITHIUM
+static DILITHIUM *pkey_get_dilithium(EVP_PKEY *key, DILITHIUM **dilithium)
+{
+    DILITHIUM *ltmp;
+    if (!key)
+        return NULL;
+    ltmp = EVP_PKEY_get1_DILITHIUM(key);
+    EVP_PKEY_free(key);
+    if (!ltmp)
+        return NULL;
+    if (dilithium) {
+        DILITHIUM_free(*dilithium);
+        *dilithium = ltmp;
+    }
+    return ltmp;
+}
+
+DILITHIUM *PEM_read_bio_DILITHIUMPrivateKey(BIO *bp, DILITHIUM **dilithium, pem_password_cb *cb,
+                                void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
+    return pkey_get_dilithium(pktmp, dilithium); /* will free pktmp */
+}
+
+IMPLEMENT_PEM_write_cb_const(DILITHIUMPrivateKey, DILITHIUM, PEM_STRING_DILITHIUM,
+                             DILITHIUMPrivateKey)
+
+    IMPLEMENT_PEM_rw(DILITHIUM_PUBKEY, DILITHIUM, PEM_STRING_PUBLIC, DILITHIUM_PUBKEY)
+# ifndef OPENSSL_NO_FP_API
+DILITHIUM *PEM_read_DILITHIUMPrivateKey(FILE *fp, DILITHIUM **dilithium, pem_password_cb *cb, void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
+    return pkey_get_dilithium(pktmp, dilithium); /* will free pktmp */
+}
+
+# endif
+#endif
+
+#ifndef OPENSSL_NO_SPHINCS
+static SPHINCS *pkey_get_sphincs(EVP_PKEY *key, SPHINCS **sphincs)
+{
+    SPHINCS *ltmp;
+    if (!key)
+        return NULL;
+    ltmp = EVP_PKEY_get1_SPHINCS(key);
+    EVP_PKEY_free(key);
+    if (!ltmp)
+        return NULL;
+    if (sphincs) {
+        SPHINCS_free(*sphincs);
+        *sphincs = ltmp;
+    }
+    return ltmp;
+}
+
+SPHINCS *PEM_read_bio_SPHINCSPrivateKey(BIO *bp, SPHINCS **sphincs, pem_password_cb *cb,
+                                void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
+    return pkey_get_sphincs(pktmp, sphincs); /* will free pktmp */
+}
+
+IMPLEMENT_PEM_write_cb_const(SPHINCSPrivateKey, SPHINCS, PEM_STRING_SPHINCS,
+                             SPHINCSPrivateKey)
+
+    IMPLEMENT_PEM_rw(SPHINCS_PUBKEY, SPHINCS, PEM_STRING_PUBLIC, SPHINCS_PUBKEY)
+# ifndef OPENSSL_NO_FP_API
+SPHINCS *PEM_read_SPHINCSPrivateKey(FILE *fp, SPHINCS **sphincs, pem_password_cb *cb, void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
+    return pkey_get_sphincs(pktmp, sphincs); /* will free pktmp */
+}
+
+# endif
+#endif
+
+#ifndef OPENSSL_NO_RAINBOW
+static RAINBOW *pkey_get_rainbow(EVP_PKEY *key, RAINBOW **rainbow)
+{
+    RAINBOW *ltmp;
+    if (!key)
+        return NULL;
+    ltmp = EVP_PKEY_get1_RAINBOW(key);
+    EVP_PKEY_free(key);
+    if (!ltmp)
+        return NULL;
+    if (rainbow) {
+        RAINBOW_free(*rainbow);
+        *rainbow = ltmp;
+    }
+    return ltmp;
+}
+
+RAINBOW *PEM_read_bio_RAINBOWPrivateKey(BIO *bp, RAINBOW **rainbow, pem_password_cb *cb,
+                                void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
+    return pkey_get_rainbow(pktmp, rainbow); /* will free pktmp */
+}
+
+IMPLEMENT_PEM_write_cb_const(RAINBOWPrivateKey, RAINBOW, PEM_STRING_RAINBOW,
+                             RAINBOWPrivateKey)
+
+    IMPLEMENT_PEM_rw(RAINBOW_PUBKEY, RAINBOW, PEM_STRING_PUBLIC, RAINBOW_PUBKEY)
+# ifndef OPENSSL_NO_FP_API
+RAINBOW *PEM_read_RAINBOWPrivateKey(FILE *fp, RAINBOW **rainbow, pem_password_cb *cb, void *u)
+{
+    EVP_PKEY *pktmp;
+    pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
+    return pkey_get_rainbow(pktmp, rainbow); /* will free pktmp */
+}
+
+# endif
+
+#endif
+
 #ifndef OPENSSL_NO_EC
 static EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
 {
diff --git a/openssl-1.0.2r/crypto/pem/pem_err.c b/openssl-1.0.2r/crypto/pem/pem_err.c
index 4e5f8e93..8d5b39ba 100644
--- a/openssl-1.0.2r/crypto/pem/pem_err.c
+++ b/openssl-1.0.2r/crypto/pem/pem_err.c
@@ -1,6 +1,6 @@
 /* crypto/pem/pem_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2018 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -102,6 +102,8 @@ static ERR_STRING_DATA PEM_str_functs[] = {
     {ERR_FUNC(PEM_F_PEM_READ_BIO_DHPARAMS), "PEM_READ_BIO_DHPARAMS"},
     {ERR_FUNC(PEM_F_PEM_READ_BIO_PARAMETERS), "PEM_read_bio_Parameters"},
     {ERR_FUNC(PEM_F_PEM_READ_BIO_PRIVATEKEY), "PEM_READ_BIO_PRIVATEKEY"},
+    {ERR_FUNC(PEM_F_PEM_READ_BIO_PRIVATEKEY_LOCAL),
+     "PEM_READ_BIO_PRIVATEKEY_LOCAL"},
     {ERR_FUNC(PEM_F_PEM_READ_DHPARAMS), "PEM_READ_DHPARAMS"},
     {ERR_FUNC(PEM_F_PEM_READ_PRIVATEKEY), "PEM_READ_PRIVATEKEY"},
     {ERR_FUNC(PEM_F_PEM_SEALFINAL), "PEM_SealFinal"},
diff --git a/openssl-1.0.2r/crypto/pem/pem_info.c b/openssl-1.0.2r/crypto/pem/pem_info.c
index 0994020d..c2bc7df0 100644
--- a/openssl-1.0.2r/crypto/pem/pem_info.c
+++ b/openssl-1.0.2r/crypto/pem/pem_info.c
@@ -69,6 +69,24 @@
 #ifndef OPENSSL_NO_DSA
 # include <openssl/dsa.h>
 #endif
+#ifndef OPENSSL_NO_HSS
+# include <openssl/hss.h>
+#endif
+#ifndef OPENSSL_NO_XMSS
+# include <openssl/xmss.h>
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+# include <openssl/xmssmt.h>
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+# include <openssl/sphincs.h>
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+# include <openssl/rainbow.h>
+#endif
 
 #ifndef OPENSSL_NO_FP_API
 STACK_OF(X509_INFO) *PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk,
@@ -203,6 +221,144 @@ STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk,
                 raw = 1;
         } else
 #endif
+#ifndef OPENSSL_NO_HSS
+        if (strcmp(name, PEM_STRING_HSS) == 0) {
+            d2i = (D2I_OF(void)) d2i_HSSPrivateKey;
+            if (xi->x_pkey != NULL) {
+                if (!sk_X509_INFO_push(ret, xi))
+                    goto err;
+                if ((xi = X509_INFO_new()) == NULL)
+                    goto err;
+                goto start;
+            }
+
+            xi->enc_data = NULL;
+            xi->enc_len = 0;
+
+            xi->x_pkey = X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_HSS;
+            pp = &xi->x_pkey->dec_pkey;
+            if ((int)strlen(header) > 10) /* assume encrypted */
+                raw = 1;
+        } else
+#endif
+#ifndef OPENSSL_NO_XMSS
+        if (strcmp(name, PEM_STRING_XMSS) == 0) {
+            d2i = (D2I_OF(void)) d2i_XMSSPrivateKey;
+            if (xi->x_pkey != NULL) {
+                if (!sk_X509_INFO_push(ret, xi))
+                    goto err;
+                if ((xi = X509_INFO_new()) == NULL)
+                    goto err;
+                goto start;
+            }
+
+            xi->enc_data = NULL;
+            xi->enc_len = 0;
+
+            xi->x_pkey = X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_XMSS;
+            pp = &xi->x_pkey->dec_pkey;
+            if ((int)strlen(header) > 10) /* assume encrypted */
+                raw = 1;
+        } else
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+        if (strcmp(name, PEM_STRING_XMSSMT) == 0) {
+            d2i = (D2I_OF(void)) d2i_XMSSMTPrivateKey;
+            if (xi->x_pkey != NULL) {
+                if (!sk_X509_INFO_push(ret, xi))
+                    goto err;
+                if ((xi = X509_INFO_new()) == NULL)
+                    goto err;
+                goto start;
+            }
+
+            xi->enc_data = NULL;
+            xi->enc_len = 0;
+
+            xi->x_pkey = X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_XMSSMT;
+            pp = &xi->x_pkey->dec_pkey;
+            if ((int)strlen(header) > 10) /* assume encrypted */
+                raw = 1;
+        } else
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+        if (strcmp(name, PEM_STRING_DILITHIUM) == 0) {
+            d2i = (D2I_OF(void)) d2i_DILITHIUMPrivateKey;
+            if (xi->x_pkey != NULL) {
+                if (!sk_X509_INFO_push(ret, xi))
+                    goto err;
+                if ((xi = X509_INFO_new()) == NULL)
+                    goto err;
+                goto start;
+            }
+
+            xi->enc_data = NULL;
+            xi->enc_len = 0;
+
+            xi->x_pkey = X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_DILITHIUM;
+            pp = &xi->x_pkey->dec_pkey;
+            if ((int)strlen(header) > 10) /* assume encrypted */
+                raw = 1;
+        } else
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+        if (strcmp(name, PEM_STRING_SPHINCS) == 0) {
+            d2i = (D2I_OF(void)) d2i_SPHINCSPrivateKey;
+            if (xi->x_pkey != NULL) {
+                if (!sk_X509_INFO_push(ret, xi))
+                    goto err;
+                if ((xi = X509_INFO_new()) == NULL)
+                    goto err;
+                goto start;
+            }
+
+            xi->enc_data = NULL;
+            xi->enc_len = 0;
+
+            xi->x_pkey = X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_SPHINCS;
+            pp = &xi->x_pkey->dec_pkey;
+            if ((int)strlen(header) > 10) /* assume encrypted */
+                raw = 1;
+        } else
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+        if (strcmp(name, PEM_STRING_RAINBOW) == 0) {
+            d2i = (D2I_OF(void)) d2i_RAINBOWPrivateKey;
+            if (xi->x_pkey != NULL) {
+                if (!sk_X509_INFO_push(ret, xi))
+                    goto err;
+                if ((xi = X509_INFO_new()) == NULL)
+                    goto err;
+                goto start;
+            }
+
+            xi->enc_data = NULL;
+            xi->enc_len = 0;
+
+            xi->x_pkey = X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_RAINBOW;
+            pp = &xi->x_pkey->dec_pkey;
+            if ((int)strlen(header) > 10) /* assume encrypted */
+                raw = 1;
+        } else
+#endif
 #ifndef OPENSSL_NO_EC
         if (strcmp(name, PEM_STRING_ECPRIVATEKEY) == 0) {
             d2i = (D2I_OF(void)) d2i_ECPrivateKey;
diff --git a/openssl-1.0.2r/crypto/pem/pem_lib.c b/openssl-1.0.2r/crypto/pem/pem_lib.c
index 4ccc676e..3b9ec095 100644
--- a/openssl-1.0.2r/crypto/pem/pem_lib.c
+++ b/openssl-1.0.2r/crypto/pem/pem_lib.c
@@ -179,7 +179,7 @@ static int check_pem(const char *nm, const char *name)
     if (!strcmp(nm, name))
         return 1;
 
-    /* Make PEM_STRING_EVP_PKEY match any private key */
+    /* Make PEM_STRING_EVP_PKEY match any non-alt private key */
 
     if (!strcmp(name, PEM_STRING_EVP_PKEY)) {
         int slen;
@@ -188,6 +188,7 @@ static int check_pem(const char *nm, const char *name)
             return 1;
         if (!strcmp(nm, PEM_STRING_PKCS8INF))
             return 1;
+
         slen = pem_check_suffix(nm, "PRIVATE KEY");
         if (slen > 0) {
             /*
@@ -201,6 +202,29 @@ static int check_pem(const char *nm, const char *name)
         return 0;
     }
 
+    /* Make PEM_STRING_EVP_ALT_PKEY match ALT */
+
+    if (!strcmp(name, PEM_STRING_EVP_ALT_PKEY)) {
+        int slen;
+        const EVP_PKEY_ASN1_METHOD *ameth;
+        if (!strcmp(nm, PEM_STRING_ALT_PKCS8))
+            return 1;
+        if (!strcmp(nm, PEM_STRING_ALT_PKCS8INF))
+            return 1;
+
+        slen = pem_check_suffix(nm, "ALT PRIVATE KEY");
+        if (slen > 0) {
+            /*
+             * NB: ENGINE implementations wont contain a deprecated old
+             * private key decode function so don't look for them.
+             */
+            ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);
+            if (ameth && ameth->old_priv_decode)
+                return 1;
+        }
+        return 0;
+    }
+
     if (!strcmp(name, PEM_STRING_PARAMETERS)) {
         int slen;
         const EVP_PKEY_ASN1_METHOD *ameth;
diff --git a/openssl-1.0.2r/crypto/pem/pem_pk8.c b/openssl-1.0.2r/crypto/pem/pem_pk8.c
index ae18d260..0bc31bb4 100644
--- a/openssl-1.0.2r/crypto/pem/pem_pk8.c
+++ b/openssl-1.0.2r/crypto/pem/pem_pk8.c
@@ -68,11 +68,16 @@
 
 static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder,
                       int nid, const EVP_CIPHER *enc,
-                      char *kstr, int klen, pem_password_cb *cb, void *u);
+                      char *kstr, int klen, pem_password_cb *cb, void *u, int isalt);
 static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder,
                          int nid, const EVP_CIPHER *enc,
                          char *kstr, int klen, pem_password_cb *cb, void *u);
 
+
+IMPLEMENT_PEM_rw(ALT_PKCS8, X509_SIG, PEM_STRING_ALT_PKCS8, X509_SIG)
+IMPLEMENT_PEM_rw(ALT_PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO, PEM_STRING_ALT_PKCS8INF,
+             PKCS8_PRIV_KEY_INFO)
+
 /*
  * These functions write a private key in PKCS#8 format: it is a "drop in"
  * replacement for PEM_write_bio_PrivateKey() and friends. As usual if 'enc'
@@ -84,33 +89,41 @@ int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                       char *kstr, int klen,
                                       pem_password_cb *cb, void *u)
 {
-    return do_pk8pkey(bp, x, 0, nid, NULL, kstr, klen, cb, u);
+    return do_pk8pkey(bp, x, 0, nid, NULL, kstr, klen, cb, u, 0);
 }
 
 int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                   char *kstr, int klen,
                                   pem_password_cb *cb, void *u)
 {
-    return do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u);
+    return do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u, 0);
 }
 
+int PEM_write_bio_ALT_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+                                      char *kstr, int klen,
+                                      pem_password_cb *cb, void *u)
+{
+    return do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u, 1);
+}
+
+
 int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                             char *kstr, int klen,
                             pem_password_cb *cb, void *u)
 {
-    return do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, cb, u);
+    return do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, cb, u, 0);
 }
 
 int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
                                 char *kstr, int klen,
                                 pem_password_cb *cb, void *u)
 {
-    return do_pk8pkey(bp, x, 1, nid, NULL, kstr, klen, cb, u);
+    return do_pk8pkey(bp, x, 1, nid, NULL, kstr, klen, cb, u, 0);
 }
 
 static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid,
                       const EVP_CIPHER *enc, char *kstr, int klen,
-                      pem_password_cb *cb, void *u)
+                      pem_password_cb *cb, void *u, int isalt)
 {
     X509_SIG *p8;
     PKCS8_PRIV_KEY_INFO *p8inf;
@@ -140,17 +153,35 @@ static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid,
         PKCS8_PRIV_KEY_INFO_free(p8inf);
         if (p8 == NULL)
             return 0;
-        if (isder)
-            ret = i2d_PKCS8_bio(bp, p8);
-        else
-            ret = PEM_write_bio_PKCS8(bp, p8);
+        if (isder) {
+            if (isalt) {
+                return 0;
+            } else {
+                ret = i2d_PKCS8_bio(bp, p8);
+            }
+        } else {
+            if (isalt) {
+                ret = PEM_write_bio_ALT_PKCS8(bp, p8);
+            } else {
+                ret = PEM_write_bio_PKCS8(bp, p8);
+            }
+        }
         X509_SIG_free(p8);
         return ret;
     } else {
-        if (isder)
-            ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
-        else
-            ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
+        if (isder) {
+            if (isalt) {
+                return 0;
+            } else {
+                ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
+            }
+        } else {
+            if (isalt) {
+                ret = PEM_write_bio_ALT_PKCS8_PRIV_KEY_INFO(bp, p8inf);
+            } else {
+                ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
+            }
+        }
         PKCS8_PRIV_KEY_INFO_free(p8inf);
         return ret;
     }
@@ -232,7 +263,7 @@ static int do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid,
         PEMerr(PEM_F_DO_PK8PKEY_FP, ERR_R_BUF_LIB);
         return (0);
     }
-    ret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u);
+    ret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u, 0);
     BIO_free(bp);
     return ret;
 }
diff --git a/openssl-1.0.2r/crypto/pem/pem_pkey.c b/openssl-1.0.2r/crypto/pem/pem_pkey.c
index a189cd27..31e496fd 100644
--- a/openssl-1.0.2r/crypto/pem/pem_pkey.c
+++ b/openssl-1.0.2r/crypto/pem/pem_pkey.c
@@ -75,8 +75,8 @@
 
 int pem_check_suffix(const char *pem_str, const char *suffix);
 
-EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
-                                  void *u)
+static EVP_PKEY *PEM_read_bio_PrivateKey_local(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                               void *u, int isAlt)
 {
     char *nm = NULL;
     const unsigned char *p = NULL;
@@ -84,12 +84,25 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     long len;
     int slen;
     EVP_PKEY *ret = NULL;
+    char *pkcs8inf_str = NULL;
+    char *pkcs_str = NULL;
+    char *pem_str = NULL;
+
+    if (isAlt) {
+        pkcs8inf_str = PEM_STRING_ALT_PKCS8INF;
+        pkcs_str = PEM_STRING_ALT_PKCS8;
+        pem_str = PEM_STRING_EVP_ALT_PKEY;
+    } else {
+        pkcs8inf_str = PEM_STRING_PKCS8INF;
+        pkcs_str = PEM_STRING_PKCS8;
+        pem_str = PEM_STRING_EVP_PKEY;
+    }
 
-    if (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_EVP_PKEY, bp, cb, u))
+    if (!PEM_bytes_read_bio(&data, &len, &nm, pem_str, bp, cb, u))
         return NULL;
     p = data;
 
-    if (strcmp(nm, PEM_STRING_PKCS8INF) == 0) {
+    if (strcmp(nm, pkcs8inf_str) == 0) {
         PKCS8_PRIV_KEY_INFO *p8inf;
         p8inf = d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);
         if (!p8inf)
@@ -101,7 +114,7 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
             *x = ret;
         }
         PKCS8_PRIV_KEY_INFO_free(p8inf);
-    } else if (strcmp(nm, PEM_STRING_PKCS8) == 0) {
+    } else if (strcmp(nm, pkcs_str) == 0) {
         PKCS8_PRIV_KEY_INFO *p8inf;
         X509_SIG *p8;
         int klen;
@@ -114,7 +127,7 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
         else
             klen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
         if (klen < 0) {
-            PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY, PEM_R_BAD_PASSWORD_READ);
+            PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY_LOCAL, PEM_R_BAD_PASSWORD_READ);
             X509_SIG_free(p8);
             goto err;
         }
@@ -139,7 +152,7 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     }
  p8err:
     if (ret == NULL)
-        PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY, ERR_R_ASN1_LIB);
+        PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY_LOCAL, ERR_R_ASN1_LIB);
  err:
     OPENSSL_free(nm);
     OPENSSL_cleanse(data, len);
@@ -147,6 +160,16 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     return (ret);
 }
 
+EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                  void *u) {
+    return PEM_read_bio_PrivateKey_local(bp, x, cb, u, 0);
+}
+
+EVP_PKEY *PEM_read_bio_ALTPrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                     void *u) {
+    return PEM_read_bio_PrivateKey_local(bp, x, cb, u, 1);
+}
+
 int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                              unsigned char *kstr, int klen,
                              pem_password_cb *cb, void *u)
diff --git a/openssl-1.0.2r/crypto/rainbow/Makefile b/openssl-1.0.2r/crypto/rainbow/Makefile
new file mode 100644
index 00000000..4c509023
--- /dev/null
+++ b/openssl-1.0.2r/crypto/rainbow/Makefile
@@ -0,0 +1,114 @@
+#
+# OpenSSL/crypto/rainbow/Makefile
+#
+
+DIR=	rainbow
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= rainbow_lib.c rainbow_asn1.c rainbow_err.c
+LIBOBJ= rainbow_lib.o rainbow_asn1.o rainbow_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= rainbow.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+rainbow_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+rainbow_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+rainbow_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rainbow_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rainbow_asn1.o: ../../include/openssl/lhash.h
+rainbow_asn1.o: ../../include/openssl/opensslconf.h
+rainbow_asn1.o: ../../include/openssl/opensslv.h
+rainbow_asn1.o: ../../include/openssl/ossl_typ.h
+rainbow_asn1.o: ../../include/openssl/rainbow.h ../../include/openssl/rand.h
+rainbow_asn1.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rainbow_asn1.o: ../../include/openssl/symhacks.h ../cryptlib.h rainbow_asn1.c
+rainbow_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+rainbow_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+rainbow_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+rainbow_err.o: ../../include/openssl/opensslconf.h
+rainbow_err.o: ../../include/openssl/opensslv.h
+rainbow_err.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rainbow.h
+rainbow_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rainbow_err.o: ../../include/openssl/symhacks.h rainbow_err.c
+rainbow_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+rainbow_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rainbow_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rainbow_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+rainbow_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+rainbow_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+rainbow_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+rainbow_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+rainbow_lib.o: ../../include/openssl/opensslconf.h
+rainbow_lib.o: ../../include/openssl/opensslv.h
+rainbow_lib.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+rainbow_lib.o: ../../include/openssl/rainbow.h
+rainbow_lib.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+rainbow_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rainbow_lib.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+rainbow_lib.o: ../cryptlib.h rainbow_lib.c
diff --git a/openssl-1.0.2r/crypto/rainbow/rainbow.h b/openssl-1.0.2r/crypto/rainbow/rainbow.h
new file mode 100644
index 00000000..4aea7979
--- /dev/null
+++ b/openssl-1.0.2r/crypto/rainbow/rainbow.h
@@ -0,0 +1,150 @@
+/* crypto/rainbow/rainbow.h based off of crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_RAINBOW_H
+# define HEADER_RAINBOW_H
+
+# include <openssl/e_os2.h>
+
+# ifdef OPENSSL_NO_RAINBOW
+#  error RAINBOW is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_RAINBOW_PARAMETER_SET (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string       "parameter_set"
+
+#define RAINBOW_IIIC_STD_R2                 1
+#define RAINBOW_VC_STD_R2                   2
+
+struct rainbow_st {
+    /* This first variable is used to pick up errors where a RAINBOW is passed
+     * instead of a EVP_PKEY. These first 2 members are standard for all
+     *  the algorithms.
+     */
+    int pad;
+    long version;
+
+    /* The parameters of RAINBOW.  Please see the spec */
+    long parameter_set;
+
+    /* public key */
+    ASN1_OCTET_STRING *pub_key;
+    /* private key */
+    ASN1_OCTET_STRING *priv_key;
+
+    int flags;
+    int references;
+
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+/* memory management methods for the RAINBOW struct */
+RAINBOW *RAINBOW_new(void);
+RAINBOW *RAINBOW_new_with_engine(ENGINE *engine);
+void RAINBOW_free(RAINBOW *r);
+int RAINBOW_up_ref(RAINBOW *r);
+
+/* ASN.1 for public key */
+RAINBOW *d2i_RAINBOWPublicKey(RAINBOW **a, const unsigned char **pp, long length);
+int i2d_RAINBOWPublicKey(const RAINBOW *a, unsigned char **pp);
+
+/* ASN.1 for private key */
+RAINBOW *d2i_RAINBOWPrivateKey(RAINBOW **a, const unsigned char **pp, long length);
+int i2d_RAINBOWPrivateKey(const RAINBOW *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_RAINBOW_strings(void);
+
+/* Error codes for the RAINBOW functions. */
+
+/* Function codes. */
+# define RAINBOW_F_RAINBOW_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define RAINBOW_R_ENGINE_INIT_FAILURE                        100
+# define RAINBOW_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/rainbow/rainbow_asn1.c b/openssl-1.0.2r/crypto/rainbow/rainbow_asn1.c
new file mode 100644
index 00000000..aeb35ec4
--- /dev/null
+++ b/openssl-1.0.2r/crypto/rainbow/rainbow_asn1.c
@@ -0,0 +1,119 @@
+/* rainbow_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <openssl/asn1t.h>
+#include <openssl/asn1.h>
+#include <openssl/rainbow.h>
+#include <openssl/rand.h>
+#include <stdio.h>
+
+#include "cryptlib.h"
+
+/* Override the default free and new methods */
+static int rainbow_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)RAINBOW_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        RAINBOW_free((RAINBOW *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(RAINBOWPrivateKey, rainbow_cb) = {
+        ASN1_SIMPLE(RAINBOW, version, LONG),
+        ASN1_SIMPLE(RAINBOW, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(RAINBOW, pub_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(RAINBOW, RAINBOWPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(RAINBOW, RAINBOWPrivateKey, RAINBOWPrivateKey)
+
+RAINBOW *d2i_RAINBOWPublicKey(RAINBOW **a, const unsigned char **pp, long length) {
+    RAINBOW *rainbow = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    rainbow = RAINBOW_new();
+    if (rainbow == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        RAINBOW_free(rainbow);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            RAINBOW_free(*a);
+        *a = rainbow;
+    }
+
+    rainbow->pub_key = pub_key;
+    return rainbow;
+}
+
+int i2d_RAINBOWPublicKey(const RAINBOW *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
diff --git a/openssl-1.0.2r/crypto/rainbow/rainbow_err.c b/openssl-1.0.2r/crypto/rainbow/rainbow_err.c
new file mode 100644
index 00000000..7fbd8ea4
--- /dev/null
+++ b/openssl-1.0.2r/crypto/rainbow/rainbow_err.c
@@ -0,0 +1,94 @@
+/* crypto/rainbow/rainbow_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2017 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/rainbow.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_RAINBOW,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_RAINBOW,0,reason)
+
+static ERR_STRING_DATA RAINBOW_str_functs[] = {
+    {ERR_FUNC(RAINBOW_F_RAINBOW_NEW_WITH_ENGINE), "RAINBOW_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA RAINBOW_str_reasons[] = {
+    {ERR_REASON(RAINBOW_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(RAINBOW_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_RAINBOW_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(RAINBOW_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, RAINBOW_str_functs);
+        ERR_load_strings(0, RAINBOW_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/rainbow/rainbow_lib.c b/openssl-1.0.2r/crypto/rainbow/rainbow_lib.c
new file mode 100644
index 00000000..435ae3cf
--- /dev/null
+++ b/openssl-1.0.2r/crypto/rainbow/rainbow_lib.c
@@ -0,0 +1,170 @@
+/* crypto/rainbow/rainbow_lib.c based off of crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <openssl/asn1.h>
+#include <openssl/bn.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+#include <openssl/rainbow.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "cryptlib.h"
+
+const char RAINBOW_version[] = "RAINBOW" OPENSSL_VERSION_PTEXT;
+
+
+RAINBOW *RAINBOW_new(void) {
+    return RAINBOW_new_with_engine(NULL);
+}
+
+RAINBOW *RAINBOW_new_with_engine(ENGINE *engine)
+{
+    RAINBOW *ret;
+
+    ret = (RAINBOW *)OPENSSL_malloc(sizeof(RAINBOW));
+    if (ret == NULL) {
+        RAINBOWerr(RAINBOW_F_RAINBOW_NEW_WITH_ENGINE, RAINBOW_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            RAINBOWerr(RAINBOW_F_RAINBOW_NEW_WITH_ENGINE, RAINBOW_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->parameter_set = -1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RAINBOW, ret, &ret->ex_data);
+    return (ret);
+}
+
+void RAINBOW_free(RAINBOW *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_RAINBOW);
+#ifdef REF_PRINT
+    REF_PRINT("RAINBOW", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "RAINBOW_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+#ifndef OPENSSL_NO_ENGINE
+    if (r->engine)
+        ENGINE_finish(r->engine);
+#endif
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RAINBOW, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int RAINBOW_up_ref(RAINBOW *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_RAINBOW);
+#ifdef REF_PRINT
+    REF_PRINT("RAINBOW", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "RAINBOW_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
diff --git a/openssl-1.0.2r/crypto/samwise/Makefile b/openssl-1.0.2r/crypto/samwise/Makefile
new file mode 100644
index 00000000..8a6348c9
--- /dev/null
+++ b/openssl-1.0.2r/crypto/samwise/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/samwise/Makefile
+#
+
+DIR=	samwise
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= samwise_lib.c samwise_asn1.c samwise_err.c
+LIBOBJ= samwise_lib.o samwise_asn1.o samwise_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= samwise.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+samwise_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+samwise_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+samwise_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+samwise_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+samwise_asn1.o: ../../include/openssl/samwise.h ../../include/openssl/lhash.h
+samwise_asn1.o: ../../include/openssl/opensslconf.h
+samwise_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+samwise_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+samwise_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+samwise_asn1.o: ../cryptlib.h samwise_asn1.c
+samwise_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+samwise_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+samwise_err.o: ../../include/openssl/err.h ../../include/openssl/samwise.h
+samwise_err.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+samwise_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+samwise_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+samwise_err.o: ../../include/openssl/symhacks.h samwise_err.c
+samwise_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+samwise_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+samwise_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+samwise_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+samwise_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+samwise_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+samwise_lib.o: ../../include/openssl/evp.h ../../include/openssl/samwise.h
+samwise_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+samwise_lib.o: ../../include/openssl/objects.h
+samwise_lib.o: ../../include/openssl/opensslconf.h
+samwise_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+samwise_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+samwise_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+samwise_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+samwise_lib.o: ../../include/openssl/x509_vfy.h ../cryptlib.h samwise_lib.c
diff --git a/openssl-1.0.2r/crypto/samwise/samwise.h b/openssl-1.0.2r/crypto/samwise/samwise.h
new file mode 100644
index 00000000..021a97f1
--- /dev/null
+++ b/openssl-1.0.2r/crypto/samwise/samwise.h
@@ -0,0 +1,172 @@
+/* crypto/samwise/samwise.h loosly based crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_SAMWISE_H
+# define HEADER_SAMWISE_H
+
+# include <openssl/e_os2.h>
+
+# if defined(OPENSSL_NO_SAMWISE)
+#  error Samwise Family is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_SAMWISE_ROLE_SET      (EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_SAMWISE_PARAMETER_SET (EVP_PKEY_ALG_CTRL + 2)
+
+#define SAMWISE_976_AES_V1      1
+#define SAMWISE_976_CHACHA20_V1 2
+
+struct samwise_st {
+    /*
+     * This first variable is used to pick up errors where a SAMWISE is passed
+     * instead of a EVP_PKEY
+     */
+    int pad;
+    long version;
+    int write_params;
+    unsigned int flags;
+
+    int nid;
+    int initiator;
+
+    /* After information generation, if I'm the initiator, then my_public_key
+     * will point to the public key created by libcrypto.  If I'm the responder,
+     * it will remain untouched.
+     *
+     * After secret generation, if I'm the initiator, then my_public_key will
+     * be untouched.  If I'm the responder, it will point to the public key
+     * created by libcrypto.
+     *
+     * Note that since libcrypto is providing what my_public_key points to,
+     * libcrypto will own that memory.  To be as explicit as possible, you, the
+     * user, are expected to not manage the memory.
+     */
+    ASN1_OCTET_STRING *my_public_key;
+
+    /* SAMWISE parameter.  Please see the spec. */
+    long parameter_set;
+
+    int references;
+
+    /* not sure we even need this */
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+SAMWISE *SAMWISE_new(void);
+SAMWISE *SAMWISE_new_with_engine(ENGINE *engine);
+void SAMWISE_free(SAMWISE *r);
+int SAMWISE_up_ref(SAMWISE *r);
+
+/* I don't think i2d and d2i are required as SAMWISE enforces ephermeralness
+ * therefore nothing is to be saved. I don't think we need any of the
+ * ex_ stuff either.  No params, so no param printing either. 
+ * 
+ * On the other hand, public keys get passed around in TLS buffers and then
+ * then are supposed to be paired up with the peer key via
+ * EVP_PKEY_derive_set_peer().  This can only happen if the public key as a
+ * buffer can be transformed into a EVP_PKEY.  This would suggest that we
+ * require ameth methods for the public keys.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(SAMWISE, SAMWISEPublicKey)
+ */
+SAMWISE *d2i_SAMWISEPublicKey(SAMWISE **a, const unsigned char **pp, long length);
+int i2d_SAMWISEPublicKey(const SAMWISE *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_SAMWISE_strings(void);
+
+/* Error codes for the SAMWISE functions. */
+
+/* Function codes. */
+# define SAMWISE_F_SAMWISE_NEW_WITH_ENGINE                          100
+
+/* Reason codes. */
+# define SAMWISE_R_ENGINE_INIT_FAILURE                         100
+# define SAMWISE_R_MALLOC_FAILURE                              101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/samwise/samwise_asn1.c b/openssl-1.0.2r/crypto/samwise/samwise_asn1.c
new file mode 100644
index 00000000..b5fb07b4
--- /dev/null
+++ b/openssl-1.0.2r/crypto/samwise/samwise_asn1.c
@@ -0,0 +1,89 @@
+/* samwise_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/samwise.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int samwise_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)SAMWISE_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        SAMWISE_free((SAMWISE *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(SAMWISEPublicKey, samwise_cb) = {
+        ASN1_SIMPLE(SAMWISE, my_public_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(SAMWISE, SAMWISEPublicKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(SAMWISE, SAMWISEPublicKey, SAMWISEPublicKey)
+
diff --git a/openssl-1.0.2r/crypto/samwise/samwise_err.c b/openssl-1.0.2r/crypto/samwise/samwise_err.c
new file mode 100644
index 00000000..f6ed885a
--- /dev/null
+++ b/openssl-1.0.2r/crypto/samwise/samwise_err.c
@@ -0,0 +1,94 @@
+/* crypto/samwise/samwise_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/samwise.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_SAMWISE,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_SAMWISE,0,reason)
+
+static ERR_STRING_DATA SAMWISE_str_functs[] = {
+    {ERR_FUNC(SAMWISE_F_SAMWISE_NEW_WITH_ENGINE), "SAMWISE_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA SAMWISE_str_reasons[] = {
+    {ERR_REASON(SAMWISE_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(SAMWISE_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_SAMWISE_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(SAMWISE_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, SAMWISE_str_functs);
+        ERR_load_strings(0, SAMWISE_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/samwise/samwise_lib.c b/openssl-1.0.2r/crypto/samwise/samwise_lib.c
new file mode 100644
index 00000000..5e4b93bc
--- /dev/null
+++ b/openssl-1.0.2r/crypto/samwise/samwise_lib.c
@@ -0,0 +1,188 @@
+/* crypto/samwise/samwise_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/samwise.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char SAMWISE_version[] = "SAMWISE" OPENSSL_VERSION_PTEXT;
+
+SAMWISE *SAMWISE_new(void)
+{
+    return SAMWISE_new_with_engine(NULL);
+}
+
+SAMWISE *SAMWISE_new_with_engine(ENGINE *engine)
+{
+    SAMWISE *ret;
+
+    ret = (SAMWISE *)OPENSSL_malloc(sizeof(SAMWISE));
+    if (ret == NULL) {
+        SAMWISEerr(SAMWISE_F_SAMWISE_NEW_WITH_ENGINE, SAMWISE_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            SAMWISEerr(SAMWISE_F_SAMWISE_NEW_WITH_ENGINE, SAMWISE_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+
+    ret->nid = NID_undef;
+    ret->initiator = 0;
+    ret->my_public_key = NULL;
+    ret->parameter_set = -1;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SAMWISE, ret, &ret->ex_data);
+    return (ret);
+}
+
+void SAMWISE_free(SAMWISE *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_SAMWISE);
+#ifdef REF_PRINT
+    REF_PRINT("SAMWISE", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "SAMWISE_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SAMWISE, r, &r->ex_data);
+
+    if (r->my_public_key != NULL)
+        ASN1_OCTET_STRING_free(r->my_public_key);
+
+    r->initiator = 0;
+    r->my_public_key = NULL;
+
+    OPENSSL_free(r);
+}
+
+int SAMWISE_up_ref(SAMWISE *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_SAMWISE);
+#ifdef REF_PRINT
+    REF_PRINT("SAMWISE", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "SAMWISE_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int SAMWISE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SAMWISE, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int SAMWISE_set_ex_data(SAMWISE *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *SAMWISE_get_ex_data(SAMWISE *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/sidh/Makefile b/openssl-1.0.2r/crypto/sidh/Makefile
new file mode 100644
index 00000000..dfdb00a7
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sidh/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/sidh/Makefile
+#
+
+DIR=	sidh
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= sidh_lib.c sidh_asn1.c sidh_err.c
+LIBOBJ= sidh_lib.o sidh_asn1.o sidh_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= sidh.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+sidh_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+sidh_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+sidh_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+sidh_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+sidh_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+sidh_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sidh_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+sidh_asn1.o: ../../include/openssl/sidh.h ../../include/openssl/stack.h
+sidh_asn1.o: ../../include/openssl/symhacks.h ../cryptlib.h sidh_asn1.c
+sidh_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+sidh_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+sidh_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+sidh_err.o: ../../include/openssl/opensslconf.h
+sidh_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sidh_err.o: ../../include/openssl/safestack.h ../../include/openssl/sidh.h
+sidh_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sidh_err.o: sidh_err.c
+sidh_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+sidh_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+sidh_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+sidh_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+sidh_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+sidh_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+sidh_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+sidh_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+sidh_lib.o: ../../include/openssl/opensslconf.h
+sidh_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sidh_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+sidh_lib.o: ../../include/openssl/sha.h ../../include/openssl/sidh.h
+sidh_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sidh_lib.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+sidh_lib.o: ../cryptlib.h sidh_lib.c
diff --git a/openssl-1.0.2r/crypto/sidh/sidh.h b/openssl-1.0.2r/crypto/sidh/sidh.h
new file mode 100644
index 00000000..7e868173
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sidh/sidh.h
@@ -0,0 +1,172 @@
+/* crypto/sidh/sidh.h loosly based crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_SIDH_H
+# define HEADER_SIDH_H
+
+# include <openssl/e_os2.h>
+
+# ifdef OPENSSL_NO_SIDH
+#  error SIDH is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_SIDH_ROLE_SET          (EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_SIDH_PARAMETER_SET     (EVP_PKEY_ALG_CTRL + 2)
+
+#define SIDH_P503_R2 1
+#define SIDH_P751_R2 2
+
+struct sidh_st {
+    /*
+     * This first variable is used to pick up errors where a SIDH is passed
+     * instead of a EVP_PKEY
+     */
+    int pad;
+    long version;
+    int write_params;
+    unsigned int flags;
+
+    long variant;
+    int initiator;
+
+    /* After information generation, if I'm the initiator, then my_public_key
+     * will point to the public key created by libcrypto.  If I'm the responder,
+     * it will remain untouched.
+     *
+     * After secret generation, if I'm the initiator, then my_public_key will
+     * be untouched.  If I'm the responder, it will point to the public key
+     * created by libcrypto.
+     *
+     * Note that since libcrypto is providing what my_public_key points to,
+     * libcrypto will own that memory.  To be as explicit as possible, you, the
+     * user, are expected to not manage the memory.
+     */
+    ASN1_OCTET_STRING *my_public_key;
+
+    /* SIDH parameter.  Please see the spec. */
+    long parameter_set;
+
+    int references;
+
+    /* not sure we even need this */
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+SIDH *SIDH_new(void);
+SIDH *SIDH_new_with_engine(ENGINE *engine);
+void SIDH_free(SIDH *r);
+int SIDH_up_ref(SIDH *r);
+
+/* I don't think i2d and d2i are required as SIDH enforces ephermeralness
+ * therefore nothing is to be saved. I don't think we need any of the
+ * ex_ stuff either.  No params, so no param printing either. 
+ * 
+ * On the other hand, public keys get passed around in TLS buffers and then
+ * then are supposed to be paired up with the peer key via
+ * EVP_PKEY_derive_set_peer().  This can only happen if the public key as a
+ * buffer can be transformed into a EVP_PKEY.  This would suggest that we
+ * require ameth methods for the public keys.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(SIDH, SIDHPublicKey)
+ */
+SIDH *d2i_SIDHPublicKey(SIDH **a, const unsigned char **pp, long length);
+int i2d_SIDHPublicKey(const SIDH *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_SIDH_strings(void);
+
+/* Error codes for the SIDH functions. */
+
+/* Function codes. */
+# define SIDH_F_SIDH_NEW_WITH_ENGINE                          100
+
+/* Reason codes. */
+# define SIDH_R_ENGINE_INIT_FAILURE                         100
+# define SIDH_R_MALLOC_FAILURE                              101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/sidh/sidh_asn1.c b/openssl-1.0.2r/crypto/sidh/sidh_asn1.c
new file mode 100644
index 00000000..a1afd1e4
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sidh/sidh_asn1.c
@@ -0,0 +1,89 @@
+/* sidh_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/sidh.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int sidh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)SIDH_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        SIDH_free((SIDH *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(SIDHPublicKey, sidh_cb) = {
+        ASN1_SIMPLE(SIDH, my_public_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(SIDH, SIDHPublicKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(SIDH, SIDHPublicKey, SIDHPublicKey)
+
diff --git a/openssl-1.0.2r/crypto/sidh/sidh_err.c b/openssl-1.0.2r/crypto/sidh/sidh_err.c
new file mode 100644
index 00000000..30395b3c
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sidh/sidh_err.c
@@ -0,0 +1,94 @@
+/* crypto/sidh/sidh_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/sidh.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_SIDH,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_SIDH,0,reason)
+
+static ERR_STRING_DATA SIDH_str_functs[] = {
+    {ERR_FUNC(SIDH_F_SIDH_NEW_WITH_ENGINE), "SIDH_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA SIDH_str_reasons[] = {
+    {ERR_REASON(SIDH_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(SIDH_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_SIDH_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(SIDH_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, SIDH_str_functs);
+        ERR_load_strings(0, SIDH_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/sidh/sidh_lib.c b/openssl-1.0.2r/crypto/sidh/sidh_lib.c
new file mode 100644
index 00000000..9f457e02
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sidh/sidh_lib.c
@@ -0,0 +1,187 @@
+/* crypto/sidh/sidh_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/sidh.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char SIDH_version[] = "SIDH" OPENSSL_VERSION_PTEXT;
+
+SIDH *SIDH_new(void)
+{
+    return SIDH_new_with_engine(NULL);
+}
+
+SIDH *SIDH_new_with_engine(ENGINE *engine)
+{
+    SIDH *ret;
+
+    ret = (SIDH *)OPENSSL_malloc(sizeof(SIDH));
+    if (ret == NULL) {
+        SIDHerr(SIDH_F_SIDH_NEW_WITH_ENGINE, SIDH_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            SIDHerr(SIDH_F_SIDH_NEW_WITH_ENGINE, SIDH_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+
+    ret->initiator = 0;
+    ret->my_public_key = NULL;
+    ret->parameter_set = -1;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SIDH, ret, &ret->ex_data);
+    return (ret);
+}
+
+void SIDH_free(SIDH *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_SIDH);
+#ifdef REF_PRINT
+    REF_PRINT("SIDH", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "SIDH_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SIDH, r, &r->ex_data);
+
+    if (r->my_public_key != NULL)
+        ASN1_OCTET_STRING_free(r->my_public_key);
+
+    r->initiator = 0;
+    r->my_public_key = NULL;
+
+    OPENSSL_free(r);
+}
+
+int SIDH_up_ref(SIDH *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_SIDH);
+#ifdef REF_PRINT
+    REF_PRINT("SIDH", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "SIDH_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int SIDH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SIDH, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int SIDH_set_ex_data(SIDH *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *SIDH_get_ex_data(SIDH *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/sike/Makefile b/openssl-1.0.2r/crypto/sike/Makefile
new file mode 100644
index 00000000..76021742
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sike/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/sike/Makefile
+#
+
+DIR=	sike
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= sike_lib.c sike_asn1.c sike_err.c
+LIBOBJ= sike_lib.o sike_asn1.o sike_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= sike.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+sike_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+sike_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+sike_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+sike_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+sike_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+sike_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sike_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+sike_asn1.o: ../../include/openssl/sike.h ../../include/openssl/stack.h
+sike_asn1.o: ../../include/openssl/symhacks.h ../cryptlib.h sike_asn1.c
+sike_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+sike_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+sike_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+sike_err.o: ../../include/openssl/opensslconf.h
+sike_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sike_err.o: ../../include/openssl/safestack.h ../../include/openssl/sike.h
+sike_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sike_err.o: sike_err.c
+sike_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+sike_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+sike_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+sike_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+sike_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+sike_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+sike_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+sike_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+sike_lib.o: ../../include/openssl/opensslconf.h
+sike_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sike_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+sike_lib.o: ../../include/openssl/sha.h ../../include/openssl/sike.h
+sike_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sike_lib.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+sike_lib.o: ../cryptlib.h sike_lib.c
diff --git a/openssl-1.0.2r/crypto/sike/sike.h b/openssl-1.0.2r/crypto/sike/sike.h
new file mode 100644
index 00000000..22907925
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sike/sike.h
@@ -0,0 +1,166 @@
+/* crypto/sike/sike.h loosly based off of crypto/rsa/rsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, SIKE,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_SIKE_H
+# define HEADER_SIKE_H
+
+# include <openssl/asn1.h>
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+# ifdef OPENSSL_NO_SIKE
+#  error SIKE is disabled.
+# endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_SIKE_PARAMETER_SET  (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string     "parameter_set"
+
+#define SIKE_P503_R2 1
+#define SIKE_P751_R2 2
+
+/* Declared already in ossl_typ.h */
+/* typedef struct sike_st SIKE; */
+
+struct sike_st {
+    /*
+     * The first parameter is used to pickup errors where this is passed
+     * instead of an EVP_PKEY, it is set to 0
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    ENGINE *engine;
+
+    /* SIKE parameter.  Please see the spec. */
+    long parameter_set;
+
+    ASN1_OCTET_STRING *pub_key;                 /* public key */
+    ASN1_OCTET_STRING *priv_key;                /* private key */
+    ASN1_OCTET_STRING *kem_info;                /* KEM public info */
+    ASN1_OCTET_STRING *kem_shared_key;          /* KEM shared secret key */
+
+
+    /* not sure if we need this, keep it for now */
+    CRYPTO_EX_DATA ex_data;
+    int references;
+    int flags;
+};
+
+/* memory management methods for the SIKE struct */
+SIKE *SIKE_new(void);
+SIKE *SIKE_new_with_engine(ENGINE *engine);
+void SIKE_free(SIKE *r);
+int SIKE_up_ref(SIKE *r);
+
+/* We will will need ASN1 because we will need the keys for encryption and
+ * decryption.
+ */
+
+/* ASN.1 for public key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(SIKE, SIKEPublicKey)
+ */
+SIKE *d2i_SIKEPublicKey(SIKE **a, const unsigned char **pp, long length);
+int i2d_SIKEPublicKey(const SIKE *a, unsigned char **pp);
+
+/* ASN.1 for public kem info
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(SIKE, SIKEKemInfo)
+ */
+SIKE *d2i_SIKEKemInfo(SIKE **a, const unsigned char **pp, long length);
+int i2d_SIKEKemInfo(const SIKE *a, unsigned char **pp);
+
+/* ASN.1 for private key
+ * Expanded version of DECLARE_ASN1_ENCODE_FUNCTIONS_const(SIKE, SIKEPrivateKey)
+ */
+SIKE *d2i_SIKEPrivateKey(SIKE **a, const unsigned char **pp, long length);
+int i2d_SIKEPrivateKey(const SIKE *a, unsigned char **pp);
+
+/* not sure if we need this, keep for now. */
+int SIKE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
+int SIKE_set_ex_data(SIKE *r, int idx, void *arg);
+void *SIKE_get_ex_data(SIKE *r, int idx);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_SIKE_strings(void);
+
+/* Error codes for the SIKE functions. */
+
+/* Function codes. */
+# define SIKE_F_SIKE_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define SIKE_R_ENGINE_INIT_FAILURE                        100
+# define SIKE_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/sike/sike_asn1.c b/openssl-1.0.2r/crypto/sike/sike_asn1.c
new file mode 100644
index 00000000..92e8ec85
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sike/sike_asn1.c
@@ -0,0 +1,125 @@
+/* sike_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/sike.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int sike_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)SIKE_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        SIKE_free((SIKE *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(SIKEPrivateKey, sike_cb) = {
+        ASN1_SIMPLE(SIKE, version, LONG),
+        ASN1_SIMPLE(SIKE, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(SIKE, pub_key, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END_cb(SIKE, SIKEPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(SIKE, SIKEPrivateKey, SIKEPrivateKey)
+
+SIKE *d2i_SIKEPublicKey(SIKE **a, const unsigned char **pp, long length) {
+    SIKE *sike = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    sike = SIKE_new();
+    if (sike == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        SIKE_free(sike);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            SIKE_free(*a);
+        *a = sike;
+    }
+
+    sike->pub_key = pub_key;
+    return sike;
+}
+
+int i2d_SIKEPublicKey(const SIKE *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
+
+ASN1_SEQUENCE_cb(SIKEKemInfo, sike_cb) = {
+        ASN1_SIMPLE(SIKE, kem_info, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(SIKE, SIKEKemInfo)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(SIKE, SIKEKemInfo, SIKEKemInfo)
+
diff --git a/openssl-1.0.2r/crypto/sike/sike_err.c b/openssl-1.0.2r/crypto/sike/sike_err.c
new file mode 100644
index 00000000..c9e24481
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sike/sike_err.c
@@ -0,0 +1,94 @@
+/* crypto/sike/sike_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/sike.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_SIKE,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_SIKE,0,reason)
+
+static ERR_STRING_DATA SIKE_str_functs[] = {
+    {ERR_FUNC(SIKE_F_SIKE_NEW_WITH_ENGINE), "SIKE_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA SIKE_str_reasons[] = {
+    {ERR_REASON(SIKE_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(SIKE_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_SIKE_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(SIKE_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, SIKE_str_functs);
+        ERR_load_strings(0, SIKE_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/sike/sike_lib.c b/openssl-1.0.2r/crypto/sike/sike_lib.c
new file mode 100644
index 00000000..b29f2ea8
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sike/sike_lib.c
@@ -0,0 +1,194 @@
+/* crypto/sike/sike_lib.c based on crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/sike.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char SIKE_version[] = "SIKE" OPENSSL_VERSION_PTEXT;
+
+SIKE *SIKE_new(void)
+{
+    return SIKE_new_with_engine(NULL);
+}
+
+SIKE *SIKE_new_with_engine(ENGINE *engine)
+{
+    SIKE *ret;
+
+    ret = (SIKE *)OPENSSL_malloc(sizeof(SIKE));
+    if (ret == NULL) {
+        SIKEerr(SIKE_F_SIKE_NEW_WITH_ENGINE, SIKE_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            SIKEerr(SIKE_F_SIKE_NEW_WITH_ENGINE, SIKE_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->references = 1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->kem_shared_key = NULL;
+    ret->kem_info = NULL;
+    ret->parameter_set = -1;
+
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SIKE, ret, &ret->ex_data);
+    return (ret);
+}
+
+void SIKE_free(SIKE *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_SIKE);
+#ifdef REF_PRINT
+    REF_PRINT("SIKE", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "SIKE_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+    if (r->engine)
+        ENGINE_finish(r->engine);
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SIKE, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->kem_info != NULL)
+        ASN1_OCTET_STRING_free(r->kem_info);
+    if (r->kem_shared_key != NULL) {
+        OPENSSL_cleanse(r->kem_shared_key->data, (size_t)r->kem_shared_key->length);
+        ASN1_OCTET_STRING_free(r->kem_shared_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int SIKE_up_ref(SIKE *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_SIKE);
+#ifdef REF_PRINT
+    REF_PRINT("SIKE", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "SIKE_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
+int SIKE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+{
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SIKE, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int SIKE_set_ex_data(SIKE *d, int idx, void *arg)
+{
+    return (CRYPTO_set_ex_data(&d->ex_data, idx, arg));
+}
+
+void *SIKE_get_ex_data(SIKE *d, int idx)
+{
+    return (CRYPTO_get_ex_data(&d->ex_data, idx));
+}
diff --git a/openssl-1.0.2r/crypto/sphincs/Makefile b/openssl-1.0.2r/crypto/sphincs/Makefile
new file mode 100644
index 00000000..9074281f
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sphincs/Makefile
@@ -0,0 +1,103 @@
+#
+# OpenSSL/crypto/sphincs/Makefile
+#
+
+DIR=	sphincs
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= sphincs_lib.c sphincs_asn1.c sphincs_err.c
+LIBOBJ= sphincs_lib.o sphincs_asn1.o sphincs_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= sphincs.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+sphincs_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+sphincs_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+sphincs_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+sphincs_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+sphincs_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/sphincs.h
+sphincs_asn1.o: ../../include/openssl/opensslconf.h
+sphincs_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sphincs_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+sphincs_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sphincs_asn1.o: ../cryptlib.h sphincs_asn1.c
+sphincs_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+sphincs_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+sphincs_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+sphincs_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+sphincs_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+sphincs_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+sphincs_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+sphincs_lib.o: ../../include/openssl/sphincs.h ../../include/openssl/obj_mac.h
+sphincs_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+sphincs_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+sphincs_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+sphincs_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+sphincs_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+sphincs_lib.o: ../../include/openssl/x509_vfy.h ../cryptlib.h sphincs_lib.c
diff --git a/openssl-1.0.2r/crypto/sphincs/sphincs.h b/openssl-1.0.2r/crypto/sphincs/sphincs.h
new file mode 100644
index 00000000..026d955a
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sphincs/sphincs.h
@@ -0,0 +1,152 @@
+/* crypto/sphincs/sphincs.h based off of crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_SPHINCS_H
+# define HEADER_SPHINCS_H
+
+# include <openssl/e_os2.h>
+
+# ifdef OPENSSL_NO_SPHINCS
+#  error SPHINCS is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define EVP_PKEY_CTRL_SPHINCS_PARAMETER_SET (EVP_PKEY_ALG_CTRL + 2)
+#define set_parameter_set_ctrl_string       "parameter_set"
+
+#define SPHINCS_SHAKE_256_192F_R2           1
+#define SPHINCS_SHAKE_256_192S_R2           2
+#define SPHINCS_SHAKE_256_256F_R2           3
+#define SPHINCS_SHAKE_256_256S_R2           4
+#define SPHINCS_SHA2_256_192F_R2            5
+#define SPHINCS_SHA2_256_192S_R2            6
+#define SPHINCS_SHA2_256_256F_R2            7
+#define SPHINCS_SHA2_256_256S_R2            8
+
+
+struct sphincs_st {
+    /* This first variable is used to pick up errors where a SPHINCS is passed
+     * instead of a EVP_PKEY. These first 2 members are standard for all
+     *  the algorithms.
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    /* The parameters of SPHINCS.  Please see the spec */
+    long parameter_set;
+
+    /* public key */
+    ASN1_OCTET_STRING *pub_key;
+    /* private key */
+    ASN1_OCTET_STRING *priv_key;
+
+    int flags;
+    int references;
+
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+/* memory management methods for the SPHINCS struct */
+SPHINCS *SPHINCS_new(void);
+SPHINCS *SPHINCS_new_with_engine(ENGINE *engine);
+void SPHINCS_free(SPHINCS *r);
+int SPHINCS_up_ref(SPHINCS *r);
+
+/* ASN.1 for public key */
+SPHINCS *d2i_SPHINCSPublicKey(SPHINCS **a, const unsigned char **pp, long length);
+int i2d_SPHINCSPublicKey(const SPHINCS *a, unsigned char **pp);
+
+/* ASN.1 for private key */
+SPHINCS *d2i_SPHINCSPrivateKey(SPHINCS **a, const unsigned char **pp, long length);
+int i2d_SPHINCSPrivateKey(const SPHINCS *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_SPHINCS_strings(void);
+
+/* Error codes for the SPHINCS functions. */
+
+/* Function codes. */
+# define SPHINCS_F_SPHINCS_NEW_WITH_ENGINE                  100
+
+/* Reason codes. */
+# define SPHINCS_R_ENGINE_INIT_FAILURE                        100
+# define SPHINCS_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/sphincs/sphincs_asn1.c b/openssl-1.0.2r/crypto/sphincs/sphincs_asn1.c
new file mode 100644
index 00000000..f4ef428f
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sphincs/sphincs_asn1.c
@@ -0,0 +1,118 @@
+/* sphincs_asn1.c based off of dsa_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/sphincs.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int sphincs_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)SPHINCS_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        SPHINCS_free((SPHINCS *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(SPHINCSPrivateKey, sphincs_cb) = {
+        ASN1_SIMPLE(SPHINCS, version, LONG),
+        ASN1_SIMPLE(SPHINCS, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(SPHINCS, pub_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(SPHINCS, SPHINCSPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(SPHINCS, SPHINCSPrivateKey, SPHINCSPrivateKey)
+
+SPHINCS *d2i_SPHINCSPublicKey(SPHINCS **a, const unsigned char **pp, long length) {
+    SPHINCS *sphincs = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    sphincs = SPHINCS_new();
+    if (sphincs == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        SPHINCS_free(sphincs);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            SPHINCS_free(*a);
+        *a = sphincs;
+    }
+
+    sphincs->pub_key = pub_key;
+    return sphincs;
+}
+
+int i2d_SPHINCSPublicKey(const SPHINCS *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
diff --git a/openssl-1.0.2r/crypto/sphincs/sphincs_err.c b/openssl-1.0.2r/crypto/sphincs/sphincs_err.c
new file mode 100644
index 00000000..86ab4a41
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sphincs/sphincs_err.c
@@ -0,0 +1,94 @@
+/* crypto/sphincs/sphincs_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2017 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/sphincs.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_SPHINCS,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_SPHINCS,0,reason)
+
+static ERR_STRING_DATA SPHINCS_str_functs[] = {
+    {ERR_FUNC(SPHINCS_F_SPHINCS_NEW_WITH_ENGINE), "SPHINCS_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA SPHINCS_str_reasons[] = {
+    {ERR_REASON(SPHINCS_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(SPHINCS_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_SPHINCS_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(SPHINCS_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, SPHINCS_str_functs);
+        ERR_load_strings(0, SPHINCS_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/sphincs/sphincs_lib.c b/openssl-1.0.2r/crypto/sphincs/sphincs_lib.c
new file mode 100644
index 00000000..3cafdf41
--- /dev/null
+++ b/openssl-1.0.2r/crypto/sphincs/sphincs_lib.c
@@ -0,0 +1,171 @@
+/* crypto/sphincs/sphincs_lib.c based off of crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/sphincs.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char SPHINCS_version[] = "SPHINCS" OPENSSL_VERSION_PTEXT;
+
+
+SPHINCS *SPHINCS_new(void) {
+    return SPHINCS_new_with_engine(NULL);
+}
+
+SPHINCS *SPHINCS_new_with_engine(ENGINE *engine)
+{
+    SPHINCS *ret;
+
+    ret = (SPHINCS *)OPENSSL_malloc(sizeof(SPHINCS));
+    if (ret == NULL) {
+        SPHINCSerr(SPHINCS_F_SPHINCS_NEW_WITH_ENGINE, SPHINCS_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            SPHINCSerr(SPHINCS_F_SPHINCS_NEW_WITH_ENGINE, SPHINCS_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+    ret->parameter_set = -1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SPHINCS, ret, &ret->ex_data);
+    return (ret);
+}
+
+void SPHINCS_free(SPHINCS *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_SPHINCS);
+#ifdef REF_PRINT
+    REF_PRINT("SPHINCS", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "SPHINCS_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+#ifndef OPENSSL_NO_ENGINE
+    if (r->engine)
+        ENGINE_finish(r->engine);
+#endif
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SPHINCS, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+
+    OPENSSL_free(r);
+}
+
+int SPHINCS_up_ref(SPHINCS *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_SPHINCS);
+#ifdef REF_PRINT
+    REF_PRINT("SPHINCS", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "SPHINCS_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
diff --git a/openssl-1.0.2r/crypto/x509/x509.h b/openssl-1.0.2r/crypto/x509/x509.h
index 6fa28eba..f88f93bb 100644
--- a/openssl-1.0.2r/crypto/x509/x509.h
+++ b/openssl-1.0.2r/crypto/x509/x509.h
@@ -101,6 +101,24 @@
 #  ifndef OPENSSL_NO_DH
 #   include <openssl/dh.h>
 #  endif
+#  ifndef OPENSSL_NO_HSS
+#   include <openssl/hss.h>
+#  endif
+#  ifndef OPENSSL_NO_XMSS
+#   include <openssl/xmss.h>
+#  endif
+#  ifndef OPENSSL_NO_XMSSMT
+#   include <openssl/xmssmt.h>
+#  endif
+#  ifndef OPENSSL_NO_DILITHIUM
+#   include <openssl/dilithium.h>
+#  endif
+#  ifndef OPENSSL_NO_SPHINCS
+#   include <openssl/sphincs.h>
+#  endif
+#  ifndef OPENSSL_NO_RAINBOW
+#   include <openssl/rainbow.h>
+#  endif
 # endif
 
 # ifndef OPENSSL_NO_SHA
@@ -253,6 +271,8 @@ typedef struct x509_cinf_st {
     ASN1_ENCODING enc;
 } X509_CINF;
 
+typedef X509_CINF X509_PCINF;
+
 /*
  * This stuff is certificate "auxiliary info" it contains details which are
  * useful in certificate stores and databases. When used this is tagged onto
@@ -687,6 +707,42 @@ int i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa);
 DSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa);
 int i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa);
 #  endif
+#  ifndef OPENSSL_NO_HSS
+HSS *d2i_HSS_PUBKEY_fp(FILE *fp, HSS **hss);
+int i2d_HSS_PUBKEY_fp(FILE *fp, HSS *hss);
+HSS *d2i_HSSPrivateKey_fp(FILE *fp, HSS **hss);
+int i2d_HSSPrivateKey_fp(FILE *fp, HSS *hss);
+#  endif
+#  ifndef OPENSSL_NO_XMSS
+XMSS *d2i_XMSS_PUBKEY_fp(FILE *fp, XMSS **xmss);
+int i2d_XMSS_PUBKEY_fp(FILE *fp, XMSS *xmss);
+XMSS *d2i_XMSSPrivateKey_fp(FILE *fp, XMSS **xmss);
+int i2d_XMSSPrivateKey_fp(FILE *fp, XMSS *xmss);
+#  endif
+#  ifndef OPENSSL_NO_XMSSMT
+XMSSMT *d2i_XMSSMT_PUBKEY_fp(FILE *fp, XMSSMT **xmssmt);
+int i2d_XMSSMT_PUBKEY_fp(FILE *fp, XMSSMT *xmssmt);
+XMSSMT *d2i_XMSSMTPrivateKey_fp(FILE *fp, XMSSMT **xmssmt);
+int i2d_XMSSMTPrivateKey_fp(FILE *fp, XMSSMT *xmssmt);
+#  endif
+#  ifndef OPENSSL_NO_DILITHIUM
+DILITHIUM *d2i_DILITHIUM_PUBKEY_fp(FILE *fp, DILITHIUM **dilithium);
+int i2d_DILITHIUM_PUBKEY_fp(FILE *fp, DILITHIUM *dilithium);
+DILITHIUM *d2i_DILITHIUMPrivateKey_fp(FILE *fp, DILITHIUM **dilithium);
+int i2d_DILITHIUMPrivateKey_fp(FILE *fp, DILITHIUM *dilithium);
+#  endif
+#  ifndef OPENSSL_NO_SPHINCS
+SPHINCS *d2i_SPHINCS_PUBKEY_fp(FILE *fp, SPHINCS **sphincs);
+int i2d_SPHINCS_PUBKEY_fp(FILE *fp, SPHINCS *sphincs);
+SPHINCS *d2i_SPHINCSPrivateKey_fp(FILE *fp, SPHINCS **sphincs);
+int i2d_SPHINCSPrivateKey_fp(FILE *fp, SPHINCS *sphincs);
+#  endif
+#  ifndef OPENSSL_NO_RAINBOW
+RAINBOW *d2i_RAINBOW_PUBKEY_fp(FILE *fp, RAINBOW **rainbow);
+int i2d_RAINBOW_PUBKEY_fp(FILE *fp, RAINBOW *rainbow);
+RAINBOW *d2i_RAINBOWPrivateKey_fp(FILE *fp, RAINBOW **rainbow);
+int i2d_RAINBOWPrivateKey_fp(FILE *fp, RAINBOW *rainbow);
+#  endif
 #  ifndef OPENSSL_NO_EC
 EC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey);
 int i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey);
@@ -726,6 +782,42 @@ int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa);
 DSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa);
 int i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa);
 #  endif
+#  ifndef OPENSSL_NO_HSS
+HSS *d2i_HSS_PUBKEY_bio(BIO *bp, HSS **hss);
+int i2d_HSS_PUBKEY_bio(BIO *bp, HSS *hss);
+HSS *d2i_HSSPrivateKey_bio(BIO *bp, HSS **hss);
+int i2d_HSSPrivateKey_bio(BIO *bp, HSS *hss);
+#  endif
+#  ifndef OPENSSL_NO_XMSS
+XMSS *d2i_XMSS_PUBKEY_bio(BIO *bp, XMSS **xmss);
+int i2d_XMSS_PUBKEY_bio(BIO *bp, XMSS *xmss);
+XMSS *d2i_XMSSPrivateKey_bio(BIO *bp, XMSS **xmss);
+int i2d_XMSSPrivateKey_bio(BIO *bp, XMSS *xmss);
+#  endif
+#  ifndef OPENSSL_NO_XMSSMT
+XMSSMT *d2i_XMSSMT_PUBKEY_bio(BIO *bp, XMSSMT **xmssmt);
+int i2d_XMSSMT_PUBKEY_bio(BIO *bp, XMSSMT *xmssmt);
+XMSSMT *d2i_XMSSMTPrivateKey_bio(BIO *bp, XMSSMT **xmssmt);
+int i2d_XMSSMTPrivateKey_bio(BIO *bp, XMSSMT *xmssmt);
+#  endif
+#  ifndef OPENSSL_NO_DILITHIUM
+DILITHIUM *d2i_DILITHIUM_PUBKEY_bio(BIO *bp, DILITHIUM **dilithium);
+int i2d_DILITHIUM_PUBKEY_bio(BIO *bp, DILITHIUM *dilithium);
+DILITHIUM *d2i_DILITHIUMPrivateKey_bio(BIO *bp, DILITHIUM **dilithium);
+int i2d_DILITHIUMPrivateKey_bio(BIO *bp, DILITHIUM *dilithium);
+#  endif
+#  ifndef OPENSSL_NO_SPHINCS
+SPHINCS *d2i_SPHINCS_PUBKEY_bio(BIO *bp, SPHINCS **sphincs);
+int i2d_SPHINCS_PUBKEY_bio(BIO *bp, SPHINCS *sphincs);
+SPHINCS *d2i_SPHINCSPrivateKey_bio(BIO *bp, SPHINCS **sphincs);
+int i2d_SPHINCSPrivateKey_bio(BIO *bp, SPHINCS *sphincs);
+#  endif
+#  ifndef OPENSSL_NO_RAINBOW
+RAINBOW *d2i_RAINBOW_PUBKEY_bio(BIO *bp, RAINBOW **rainbow);
+int i2d_RAINBOW_PUBKEY_bio(BIO *bp, RAINBOW *rainbow);
+RAINBOW *d2i_RAINBOWPrivateKey_bio(BIO *bp, RAINBOW **rainbow);
+int i2d_RAINBOWPrivateKey_bio(BIO *bp, RAINBOW *rainbow);
+#  endif
 #  ifndef OPENSSL_NO_EC
 EC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey);
 int i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey);
@@ -797,6 +889,30 @@ RSA *d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);
 int i2d_DSA_PUBKEY(DSA *a, unsigned char **pp);
 DSA *d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length);
 # endif
+# ifndef OPENSSL_NO_HSS
+int i2d_HSS_PUBKEY(HSS *a, unsigned char **pp);
+HSS *d2i_HSS_PUBKEY(HSS **a, const unsigned char **pp, long length);
+# endif
+# ifndef OPENSSL_NO_XMSS
+int i2d_XMSS_PUBKEY(XMSS *a, unsigned char **pp);
+XMSS *d2i_XMSS_PUBKEY(XMSS **a, const unsigned char **pp, long length);
+# endif
+# ifndef OPENSSL_NO_XMSSMT
+int i2d_XMSSMT_PUBKEY(XMSSMT *a, unsigned char **pp);
+XMSSMT *d2i_XMSSMT_PUBKEY(XMSSMT **a, const unsigned char **pp, long length);
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+int i2d_DILITHIUM_PUBKEY(DILITHIUM *a, unsigned char **pp);
+DILITHIUM *d2i_DILITHIUM_PUBKEY(DILITHIUM **a, const unsigned char **pp, long length);
+# endif
+# ifndef OPENSSL_NO_SPHINCS
+int i2d_SPHINCS_PUBKEY(SPHINCS *a, unsigned char **pp);
+SPHINCS *d2i_SPHINCS_PUBKEY(SPHINCS **a, const unsigned char **pp, long length);
+# endif
+# ifndef OPENSSL_NO_RAINBOW
+int i2d_RAINBOW_PUBKEY(RAINBOW *a, unsigned char **pp);
+RAINBOW *d2i_RAINBOW_PUBKEY(RAINBOW **a, const unsigned char **pp, long length);
+# endif
 # ifndef OPENSSL_NO_EC
 int i2d_EC_PUBKEY(EC_KEY *a, unsigned char **pp);
 EC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length);
@@ -819,6 +935,7 @@ DECLARE_ASN1_FUNCTIONS(X509_NAME)
 int X509_NAME_set(X509_NAME **xn, X509_NAME *name);
 
 DECLARE_ASN1_FUNCTIONS(X509_CINF)
+DECLARE_ASN1_FUNCTIONS(X509_PCINF)
 
 DECLARE_ASN1_FUNCTIONS(X509)
 DECLARE_ASN1_FUNCTIONS(X509_CERT_AUX)
@@ -896,6 +1013,7 @@ int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1,
 int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
                        X509_ALGOR *algor2, ASN1_BIT_STRING *signature,
                        void *asn, EVP_MD_CTX *ctx);
+int ASN1_get_sigparam(EVP_PKEY *pkey);
 # endif
 
 int X509_set_version(X509 *x, long version);
@@ -909,6 +1027,7 @@ int X509_set_notBefore(X509 *x, const ASN1_TIME *tm);
 int X509_set_notAfter(X509 *x, const ASN1_TIME *tm);
 int X509_set_pubkey(X509 *x, EVP_PKEY *pkey);
 EVP_PKEY *X509_get_pubkey(X509 *x);
+EVP_PKEY *X509_get_alt_pubkey(X509 *x);
 ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x);
 int X509_certificate_type(X509 *x, EVP_PKEY *pubkey /* optional */ );
 
@@ -955,6 +1074,7 @@ X509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,
 int X509_REQ_check_private_key(X509_REQ *x509, EVP_PKEY *pkey);
 
 int X509_check_private_key(X509 *x509, EVP_PKEY *pkey);
+int X509_check_alt_private_key(X509 *x509, EVP_PKEY *pkey);
 int X509_chain_check_suiteb(int *perror_depth,
                             X509 *x, STACK_OF(X509) *chain,
                             unsigned long flags);
@@ -1255,6 +1375,7 @@ void ERR_load_X509_strings(void);
 # define X509_F_X509_ATTRIBUTE_CREATE_BY_TXT              140
 # define X509_F_X509_ATTRIBUTE_GET0_DATA                  139
 # define X509_F_X509_ATTRIBUTE_SET1_DATA                  138
+# define X509_F_X509_CHECK_ALT_PRIVATE_KEY                107
 # define X509_F_X509_CHECK_PRIVATE_KEY                    128
 # define X509_F_X509_CRL_DIFF                             105
 # define X509_F_X509_CRL_PRINT_FP                         147
diff --git a/openssl-1.0.2r/crypto/x509/x509_cmp.c b/openssl-1.0.2r/crypto/x509/x509_cmp.c
index 2d82f8fa..d03cdc9d 100644
--- a/openssl-1.0.2r/crypto/x509/x509_cmp.c
+++ b/openssl-1.0.2r/crypto/x509/x509_cmp.c
@@ -314,6 +314,77 @@ EVP_PKEY *X509_get_pubkey(X509 *x)
     return (X509_PUBKEY_get(x->cert_info->key));
 }
 
+static EVP_PKEY *get_SAPKI_pubkey(SUBJECT_ALT_PUBLIC_KEY_INFO *sapki) {
+    X509_PUBKEY *x509_pub_qs = NULL;
+    EVP_PKEY *qs_pub_key = NULL;
+
+    /* Convert the x509 formatted public key into a pkey */
+    x509_pub_qs = X509_PUBKEY_new();
+    if (x509_pub_qs == NULL) {
+        goto end;
+    }
+    X509_ALGOR_free(x509_pub_qs->algor);
+    ASN1_BIT_STRING_free(x509_pub_qs->public_key);
+
+    x509_pub_qs->algor = sapki->algor;
+    x509_pub_qs->public_key = sapki->public_key;
+    x509_pub_qs->pkey = NULL;
+
+    qs_pub_key = X509_PUBKEY_get(x509_pub_qs);
+
+    x509_pub_qs->algor = NULL;
+    x509_pub_qs->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_qs);
+    x509_pub_qs = NULL;
+
+    if (qs_pub_key == NULL) {
+        goto end;
+    }
+
+end:
+
+    return qs_pub_key;
+}
+
+
+EVP_PKEY *X509_get_alt_pubkey(X509 *x)
+{
+    int qs_pub_key_ind = -1;
+    X509_EXTENSION *qs_pub_key_ext = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    EVP_PKEY *pk = NULL;
+
+    /* Find the ALT public key extension. */
+    qs_pub_key_ind = X509_get_ext_by_NID(x, NID_subjectAltPublicKeyInfo, -1);
+    if (qs_pub_key_ind < 0) {
+        goto end;
+    }
+
+    /* Get the ALT public key extension. */
+    qs_pub_key_ext = X509_get_ext(x, qs_pub_key_ind);
+    if (qs_pub_key_ext == NULL) {
+        goto end;
+    }
+
+    /* ASN.1 parse the ALT public key extension. */
+    sapki = X509V3_EXT_d2i(qs_pub_key_ext);
+    if (sapki == NULL) {
+        goto end;
+    }
+
+    pk = get_SAPKI_pubkey(sapki);
+    if (pk == NULL) {
+        goto end;
+    }
+
+end:
+
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+
+    return pk;
+}
+
 ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x)
 {
     if (!x)
@@ -352,6 +423,37 @@ int X509_check_private_key(X509 *x, EVP_PKEY *k)
     return 0;
 }
 
+int X509_check_alt_private_key(X509 *x, EVP_PKEY *k)
+{
+    EVP_PKEY *xk;
+    int ret;
+
+    xk = X509_get_alt_pubkey(x);
+
+    if (xk)
+        ret = EVP_PKEY_cmp(xk, k);
+    else
+        ret = -2;
+
+    switch (ret) {
+    case 1:
+        break;
+    case 0:
+        X509err(X509_F_X509_CHECK_ALT_PRIVATE_KEY, X509_R_KEY_VALUES_MISMATCH);
+        break;
+    case -1:
+        X509err(X509_F_X509_CHECK_ALT_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);
+        break;
+    case -2:
+        X509err(X509_F_X509_CHECK_ALT_PRIVATE_KEY, X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
+    }
+    if (xk)
+        EVP_PKEY_free(xk);
+    if (ret > 0)
+        return 1;
+    return 0;
+}
+
 /*
  * Check a suite B algorithm is permitted: pass in a public key and the NID
  * of its signature (or 0 if no signature). The pflags is a pointer to a
diff --git a/openssl-1.0.2r/crypto/x509/x509_err.c b/openssl-1.0.2r/crypto/x509/x509_err.c
index a2a8e1b0..5e4d7654 100644
--- a/openssl-1.0.2r/crypto/x509/x509_err.c
+++ b/openssl-1.0.2r/crypto/x509/x509_err.c
@@ -1,6 +1,6 @@
 /* crypto/x509/x509_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2018 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -88,6 +88,8 @@ static ERR_STRING_DATA X509_str_functs[] = {
      "X509_ATTRIBUTE_create_by_txt"},
     {ERR_FUNC(X509_F_X509_ATTRIBUTE_GET0_DATA), "X509_ATTRIBUTE_get0_data"},
     {ERR_FUNC(X509_F_X509_ATTRIBUTE_SET1_DATA), "X509_ATTRIBUTE_set1_data"},
+    {ERR_FUNC(X509_F_X509_CHECK_ALT_PRIVATE_KEY),
+     "X509_check_alt_private_key"},
     {ERR_FUNC(X509_F_X509_CHECK_PRIVATE_KEY), "X509_check_private_key"},
     {ERR_FUNC(X509_F_X509_CRL_DIFF), "X509_CRL_diff"},
     {ERR_FUNC(X509_F_X509_CRL_PRINT_FP), "X509_CRL_print_fp"},
diff --git a/openssl-1.0.2r/crypto/x509/x509type.c b/openssl-1.0.2r/crypto/x509/x509type.c
index 9219f753..838cb1d9 100644
--- a/openssl-1.0.2r/crypto/x509/x509type.c
+++ b/openssl-1.0.2r/crypto/x509/x509type.c
@@ -87,6 +87,24 @@ int X509_certificate_type(X509 *x, EVP_PKEY *pkey)
     case EVP_PKEY_DSA:
         ret = EVP_PK_DSA | EVP_PKT_SIGN;
         break;
+    case EVP_PKEY_HSS:
+        ret = EVP_PK_HSS | EVP_PKT_SIGN;
+        break;
+    case EVP_PKEY_XMSS:
+        ret = EVP_PK_XMSS | EVP_PKT_SIGN;
+        break;
+    case EVP_PKEY_XMSSMT:
+        ret = EVP_PK_XMSSMT | EVP_PKT_SIGN;
+        break;
+    case EVP_PKEY_DILITHIUM:
+        ret = EVP_PK_DILITHIUM | EVP_PKT_SIGN;
+        break;
+    case EVP_PKEY_SPHINCS:
+        ret = EVP_PK_SPHINCS | EVP_PKT_SIGN;
+        break;
+    case EVP_PKEY_RAINBOW:
+        ret = EVP_PK_RAINBOW | EVP_PKT_SIGN;
+        break;
     case EVP_PKEY_EC:
         ret = EVP_PK_EC | EVP_PKT_SIGN | EVP_PKT_EXCH;
         break;
@@ -116,6 +134,24 @@ int X509_certificate_type(X509 *x, EVP_PKEY *pkey)
         case NID_X9_62_id_ecPublicKey:
             ret |= EVP_PKS_EC;
             break;
+        case NID_hss:
+            ret |= EVP_PKS_HSS;
+            break;
+        case NID_xmss:
+            ret |= EVP_PKS_XMSS;
+            break;
+        case NID_xmssmt:
+            ret |= EVP_PKS_XMSSMT;
+            break;
+        case NID_dilithium:
+            ret |= EVP_PKS_DILITHIUM;
+            break;
+        case NID_sphincs:
+            ret |= EVP_PKS_SPHINCS;
+            break;
+        case NID_rainbow:
+            ret |= EVP_PKS_RAINBOW;
+            break;
         default:
             break;
         }
diff --git a/openssl-1.0.2r/crypto/x509/x_all.c b/openssl-1.0.2r/crypto/x509/x_all.c
index 0f26c546..185b44a0 100644
--- a/openssl-1.0.2r/crypto/x509/x_all.c
+++ b/openssl-1.0.2r/crypto/x509/x_all.c
@@ -70,6 +70,24 @@
 #ifndef OPENSSL_NO_DSA
 # include <openssl/dsa.h>
 #endif
+#ifndef OPENSSL_NO_HSS
+# include <openssl/hss.h>
+#endif
+#ifndef OPENSSL_NO_XMSS
+# include <openssl/xmss.h>
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+# include <openssl/xmssmt.h>
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+#ifndef OPENSSL_NO_SPHINCS
+# include <openssl/sphincs.h>
+#endif
+#ifndef OPENSSL_NO_RAINBOW
+# include <openssl/rainbow.h>
+#endif
 
 int X509_verify(X509 *a, EVP_PKEY *r)
 {
@@ -353,6 +371,271 @@ int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa)
 
 #endif
 
+#ifndef OPENSSL_NO_HSS
+# ifndef OPENSSL_NO_FP_API
+HSS *d2i_HSSPrivateKey_fp(FILE *fp, HSS **hss)
+{
+    return ASN1_d2i_fp_of(HSS, HSS_new, d2i_HSSPrivateKey, fp, hss);
+}
+
+int i2d_HSSPrivateKey_fp(FILE *fp, HSS *hss)
+{
+    return ASN1_i2d_fp_of_const(HSS, i2d_HSSPrivateKey, fp, hss);
+}
+
+HSS *d2i_HSS_PUBKEY_fp(FILE *fp, HSS **hss)
+{
+    return ASN1_d2i_fp_of(HSS, HSS_new, d2i_HSS_PUBKEY, fp, hss);
+}
+
+int i2d_HSS_PUBKEY_fp(FILE *fp, HSS *hss)
+{
+    return ASN1_i2d_fp_of(HSS, i2d_HSS_PUBKEY, fp, hss);
+}
+# endif
+
+HSS *d2i_HSSPrivateKey_bio(BIO *bp, HSS **hss)
+{
+    return ASN1_d2i_bio_of(HSS, HSS_new, d2i_HSSPrivateKey, bp, hss);
+}
+
+int i2d_HSSPrivateKey_bio(BIO *bp, HSS *hss)
+{
+    return ASN1_i2d_bio_of_const(HSS, i2d_HSSPrivateKey, bp, hss);
+}
+
+HSS *d2i_HSS_PUBKEY_bio(BIO *bp, HSS **hss)
+{
+    return ASN1_d2i_bio_of(HSS, HSS_new, d2i_HSS_PUBKEY, bp, hss);
+}
+
+int i2d_HSS_PUBKEY_bio(BIO *bp, HSS *hss)
+{
+    return ASN1_i2d_bio_of(HSS, i2d_HSS_PUBKEY, bp, hss);
+}
+#endif
+
+#ifndef OPENSSL_NO_XMSS
+# ifndef OPENSSL_NO_FP_API
+XMSS *d2i_XMSSPrivateKey_fp(FILE *fp, XMSS **xmss)
+{
+    return ASN1_d2i_fp_of(XMSS, XMSS_new, d2i_XMSSPrivateKey, fp, xmss);
+}
+
+int i2d_XMSSPrivateKey_fp(FILE *fp, XMSS *xmss)
+{
+    return ASN1_i2d_fp_of_const(XMSS, i2d_XMSSPrivateKey, fp, xmss);
+}
+
+XMSS *d2i_XMSS_PUBKEY_fp(FILE *fp, XMSS **xmss)
+{
+    return ASN1_d2i_fp_of(XMSS, XMSS_new, d2i_XMSS_PUBKEY, fp, xmss);
+}
+
+int i2d_XMSS_PUBKEY_fp(FILE *fp, XMSS *xmss)
+{
+    return ASN1_i2d_fp_of(XMSS, i2d_XMSS_PUBKEY, fp, xmss);
+}
+# endif
+
+XMSS *d2i_XMSSPrivateKey_bio(BIO *bp, XMSS **xmss)
+{
+    return ASN1_d2i_bio_of(XMSS, XMSS_new, d2i_XMSSPrivateKey, bp, xmss);
+}
+
+int i2d_XMSSPrivateKey_bio(BIO *bp, XMSS *xmss)
+{
+    return ASN1_i2d_bio_of_const(XMSS, i2d_XMSSPrivateKey, bp, xmss);
+}
+
+XMSS *d2i_XMSS_PUBKEY_bio(BIO *bp, XMSS **xmss)
+{
+    return ASN1_d2i_bio_of(XMSS, XMSS_new, d2i_XMSS_PUBKEY, bp, xmss);
+}
+
+int i2d_XMSS_PUBKEY_bio(BIO *bp, XMSS *xmss)
+{
+    return ASN1_i2d_bio_of(XMSS, i2d_XMSS_PUBKEY, bp, xmss);
+}
+#endif
+
+#ifndef OPENSSL_NO_XMSSMT
+# ifndef OPENSSL_NO_FP_API
+XMSSMT *d2i_XMSSMTPrivateKey_fp(FILE *fp, XMSSMT **xmssmt)
+{
+    return ASN1_d2i_fp_of(XMSSMT, XMSSMT_new, d2i_XMSSMTPrivateKey, fp, xmssmt);
+}
+
+int i2d_XMSSMTPrivateKey_fp(FILE *fp, XMSSMT *xmssmt)
+{
+    return ASN1_i2d_fp_of_const(XMSSMT, i2d_XMSSMTPrivateKey, fp, xmssmt);
+}
+
+XMSSMT *d2i_XMSSMT_PUBKEY_fp(FILE *fp, XMSSMT **xmssmt)
+{
+    return ASN1_d2i_fp_of(XMSSMT, XMSSMT_new, d2i_XMSSMT_PUBKEY, fp, xmssmt);
+}
+
+int i2d_XMSSMT_PUBKEY_fp(FILE *fp, XMSSMT *xmssmt)
+{
+    return ASN1_i2d_fp_of(XMSSMT, i2d_XMSSMT_PUBKEY, fp, xmssmt);
+}
+# endif
+
+XMSSMT *d2i_XMSSMTPrivateKey_bio(BIO *bp, XMSSMT **xmssmt)
+{
+    return ASN1_d2i_bio_of(XMSSMT, XMSSMT_new, d2i_XMSSMTPrivateKey, bp, xmssmt);
+}
+
+int i2d_XMSSMTPrivateKey_bio(BIO *bp, XMSSMT *xmssmt)
+{
+    return ASN1_i2d_bio_of_const(XMSSMT, i2d_XMSSMTPrivateKey, bp, xmssmt);
+}
+
+XMSSMT *d2i_XMSSMT_PUBKEY_bio(BIO *bp, XMSSMT **xmssmt)
+{
+    return ASN1_d2i_bio_of(XMSSMT, XMSSMT_new, d2i_XMSSMT_PUBKEY, bp, xmssmt);
+}
+
+int i2d_XMSSMT_PUBKEY_bio(BIO *bp, XMSSMT *xmssmt)
+{
+    return ASN1_i2d_bio_of(XMSSMT, i2d_XMSSMT_PUBKEY, bp, xmssmt);
+}
+#endif
+
+#ifndef OPENSSL_NO_DILITHIUM
+# ifndef OPENSSL_NO_FP_API
+DILITHIUM *d2i_DILITHIUMPrivateKey_fp(FILE *fp, DILITHIUM **dilithium)
+{
+    return ASN1_d2i_fp_of(DILITHIUM, DILITHIUM_new, d2i_DILITHIUMPrivateKey, fp, dilithium);
+}
+
+int i2d_DILITHIUMPrivateKey_fp(FILE *fp, DILITHIUM *dilithium)
+{
+    return ASN1_i2d_fp_of_const(DILITHIUM, i2d_DILITHIUMPrivateKey, fp, dilithium);
+}
+
+DILITHIUM *d2i_DILITHIUM_PUBKEY_fp(FILE *fp, DILITHIUM **dilithium)
+{
+    return ASN1_d2i_fp_of(DILITHIUM, DILITHIUM_new, d2i_DILITHIUM_PUBKEY, fp, dilithium);
+}
+
+int i2d_DILITHIUM_PUBKEY_fp(FILE *fp, DILITHIUM *dilithium)
+{
+    return ASN1_i2d_fp_of(DILITHIUM, i2d_DILITHIUM_PUBKEY, fp, dilithium);
+}
+# endif
+
+DILITHIUM *d2i_DILITHIUMPrivateKey_bio(BIO *bp, DILITHIUM **dilithium)
+{
+    return ASN1_d2i_bio_of(DILITHIUM, DILITHIUM_new, d2i_DILITHIUMPrivateKey, bp, dilithium);
+}
+
+int i2d_DILITHIUMPrivateKey_bio(BIO *bp, DILITHIUM *dilithium)
+{
+    return ASN1_i2d_bio_of_const(DILITHIUM, i2d_DILITHIUMPrivateKey, bp, dilithium);
+}
+
+DILITHIUM *d2i_DILITHIUM_PUBKEY_bio(BIO *bp, DILITHIUM **dilithium)
+{
+    return ASN1_d2i_bio_of(DILITHIUM, DILITHIUM_new, d2i_DILITHIUM_PUBKEY, bp, dilithium);
+}
+
+int i2d_DILITHIUM_PUBKEY_bio(BIO *bp, DILITHIUM *dilithium)
+{
+    return ASN1_i2d_bio_of(DILITHIUM, i2d_DILITHIUM_PUBKEY, bp, dilithium);
+}
+#endif
+
+#ifndef OPENSSL_NO_SPHINCS
+# ifndef OPENSSL_NO_FP_API
+SPHINCS *d2i_SPHINCSPrivateKey_fp(FILE *fp, SPHINCS **sphincs)
+{
+    return ASN1_d2i_fp_of(SPHINCS, SPHINCS_new, d2i_SPHINCSPrivateKey, fp, sphincs);
+}
+
+int i2d_SPHINCSPrivateKey_fp(FILE *fp, SPHINCS *sphincs)
+{
+    return ASN1_i2d_fp_of_const(SPHINCS, i2d_SPHINCSPrivateKey, fp, sphincs);
+}
+
+SPHINCS *d2i_SPHINCS_PUBKEY_fp(FILE *fp, SPHINCS **sphincs)
+{
+    return ASN1_d2i_fp_of(SPHINCS, SPHINCS_new, d2i_SPHINCS_PUBKEY, fp, sphincs);
+}
+
+int i2d_SPHINCS_PUBKEY_fp(FILE *fp, SPHINCS *sphincs)
+{
+    return ASN1_i2d_fp_of(SPHINCS, i2d_SPHINCS_PUBKEY, fp, sphincs);
+}
+# endif
+
+SPHINCS *d2i_SPHINCSPrivateKey_bio(BIO *bp, SPHINCS **sphincs)
+{
+    return ASN1_d2i_bio_of(SPHINCS, SPHINCS_new, d2i_SPHINCSPrivateKey, bp, sphincs);
+}
+
+int i2d_SPHINCSPrivateKey_bio(BIO *bp, SPHINCS *sphincs)
+{
+    return ASN1_i2d_bio_of_const(SPHINCS, i2d_SPHINCSPrivateKey, bp, sphincs);
+}
+
+SPHINCS *d2i_SPHINCS_PUBKEY_bio(BIO *bp, SPHINCS **sphincs)
+{
+    return ASN1_d2i_bio_of(SPHINCS, SPHINCS_new, d2i_SPHINCS_PUBKEY, bp, sphincs);
+}
+
+int i2d_SPHINCS_PUBKEY_bio(BIO *bp, SPHINCS *sphincs)
+{
+    return ASN1_i2d_bio_of(SPHINCS, i2d_SPHINCS_PUBKEY, bp, sphincs);
+}
+#endif
+
+#ifndef OPENSSL_NO_RAINBOW
+# ifndef OPENSSL_NO_FP_API
+RAINBOW *d2i_RAINBOWPrivateKey_fp(FILE *fp, RAINBOW **rainbow)
+{
+    return ASN1_d2i_fp_of(RAINBOW, RAINBOW_new, d2i_RAINBOWPrivateKey, fp, rainbow);
+}
+
+int i2d_RAINBOWPrivateKey_fp(FILE *fp, RAINBOW *rainbow)
+{
+    return ASN1_i2d_fp_of_const(RAINBOW, i2d_RAINBOWPrivateKey, fp, rainbow);
+}
+
+RAINBOW *d2i_RAINBOW_PUBKEY_fp(FILE *fp, RAINBOW **rainbow)
+{
+    return ASN1_d2i_fp_of(RAINBOW, RAINBOW_new, d2i_RAINBOW_PUBKEY, fp, rainbow);
+}
+
+int i2d_RAINBOW_PUBKEY_fp(FILE *fp, RAINBOW *rainbow)
+{
+    return ASN1_i2d_fp_of(RAINBOW, i2d_RAINBOW_PUBKEY, fp, rainbow);
+}
+# endif
+
+RAINBOW *d2i_RAINBOWPrivateKey_bio(BIO *bp, RAINBOW **rainbow)
+{
+    return ASN1_d2i_bio_of(RAINBOW, RAINBOW_new, d2i_RAINBOWPrivateKey, bp, rainbow);
+}
+
+int i2d_RAINBOWPrivateKey_bio(BIO *bp, RAINBOW *rainbow)
+{
+    return ASN1_i2d_bio_of_const(RAINBOW, i2d_RAINBOWPrivateKey, bp, rainbow);
+}
+
+RAINBOW *d2i_RAINBOW_PUBKEY_bio(BIO *bp, RAINBOW **rainbow)
+{
+    return ASN1_d2i_bio_of(RAINBOW, RAINBOW_new, d2i_RAINBOW_PUBKEY, bp, rainbow);
+}
+
+int i2d_RAINBOW_PUBKEY_bio(BIO *bp, RAINBOW *rainbow)
+{
+    return ASN1_i2d_bio_of(RAINBOW, i2d_RAINBOW_PUBKEY, bp, rainbow);
+}
+#endif
+
+
 #ifndef OPENSSL_NO_EC
 # ifndef OPENSSL_NO_FP_API
 EC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey)
diff --git a/openssl-1.0.2r/crypto/x509v3/Makefile b/openssl-1.0.2r/crypto/x509v3/Makefile
index 9791b77a..884522e6 100644
--- a/openssl-1.0.2r/crypto/x509v3/Makefile
+++ b/openssl-1.0.2r/crypto/x509v3/Makefile
@@ -22,13 +22,13 @@ v3_prn.c v3_utl.c v3err.c v3_genn.c v3_alt.c v3_skey.c v3_akey.c v3_pku.c \
 v3_int.c v3_enum.c v3_sxnet.c v3_cpols.c v3_crld.c v3_purp.c v3_info.c \
 v3_ocsp.c v3_akeya.c v3_pmaps.c v3_pcons.c v3_ncons.c v3_pcia.c v3_pci.c \
 pcy_cache.c pcy_node.c pcy_data.c pcy_map.c pcy_tree.c pcy_lib.c \
-v3_asid.c v3_addr.c v3_scts.c
+v3_asid.c v3_addr.c v3_scts.c v3_qr.c
 LIBOBJ= v3_bcons.o v3_bitst.o v3_conf.o v3_extku.o v3_ia5.o v3_lib.o \
 v3_prn.o v3_utl.o v3err.o v3_genn.o v3_alt.o v3_skey.o v3_akey.o v3_pku.o \
 v3_int.o v3_enum.o v3_sxnet.o v3_cpols.o v3_crld.o v3_purp.o v3_info.o \
 v3_ocsp.o v3_akeya.o v3_pmaps.o v3_pcons.o v3_ncons.o v3_pcia.o v3_pci.o \
 pcy_cache.o pcy_node.o pcy_data.o pcy_map.o pcy_tree.o pcy_lib.o \
-v3_asid.o v3_addr.o v3_scts.o
+v3_asid.o v3_addr.o v3_scts.o v3_qr.o
 
 SRC= $(LIBSRC)
 
diff --git a/openssl-1.0.2r/crypto/x509v3/ext_dat.h b/openssl-1.0.2r/crypto/x509v3/ext_dat.h
index c3a6fce7..d4523627 100644
--- a/openssl-1.0.2r/crypto/x509v3/ext_dat.h
+++ b/openssl-1.0.2r/crypto/x509v3/ext_dat.h
@@ -70,6 +70,7 @@ extern X509V3_EXT_METHOD v3_policy_mappings, v3_policy_constraints;
 extern X509V3_EXT_METHOD v3_name_constraints, v3_inhibit_anyp, v3_idp;
 extern X509V3_EXT_METHOD v3_addr, v3_asid;
 extern X509V3_EXT_METHOD v3_ct_scts[];
+extern X509V3_EXT_METHOD v3_altSignatureAlgorithm, v3_altSignatureValue, v3_subject_alt_public_key_info;
 
 /*
  * This table will be searched using OBJ_bsearch so it *must* kept in order
@@ -129,6 +130,9 @@ static const X509V3_EXT_METHOD *standard_exts[] = {
     &v3_freshest_crl,
     &v3_ct_scts[0],
     &v3_ct_scts[1],
+    &v3_subject_alt_public_key_info,
+    &v3_altSignatureAlgorithm,
+    &v3_altSignatureValue,
 };
 
 /* Number of standard extensions */
diff --git a/openssl-1.0.2r/crypto/x509v3/v3_qr.c b/openssl-1.0.2r/crypto/x509v3/v3_qr.c
new file mode 100644
index 00000000..a49f8f62
--- /dev/null
+++ b/openssl-1.0.2r/crypto/x509v3/v3_qr.c
@@ -0,0 +1,164 @@
+/* v3_qr.c */
+
+#include "cryptlib.h"
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/x509v3.h>
+
+/* ====================================================================
+ * General output.
+ * ====================================================================
+ */
+static int bitstring_print(BIO *bp, const char *prefix, const ASN1_BIT_STRING *str, int off)
+{
+    int n = 0;
+    int i = 0;
+
+    if (str == NULL || str->length == 0) {
+        return 1;
+    }
+
+    if (BIO_printf(bp, "%s", prefix) <= 0) {
+        return 0;
+    }
+
+    n = str->length;
+    for (i = 0; i < n; i++) {
+        if ((i % 15) == 0) {
+            if (BIO_puts(bp, "\n") <= 0 || !BIO_indent(bp, off + 4, 128))
+                return 0;
+        }
+
+        if (BIO_printf(bp, "%02x%s", str->data[i], ((i + 1) == n) ? "" : ":")
+            <= 0) {
+            return 0;
+        }
+    }
+
+    if (BIO_write(bp, "\n", 1) <= 0) {
+        return 0;
+    }
+
+    return 1;
+}
+
+/* ====================================================================
+ * ALT Public Key Extension.
+ * ====================================================================
+ */
+static int i2r_SUBJECT_ALT_PUBLIC_KEY_INFO(X509V3_EXT_METHOD *method,
+                                 SUBJECT_ALT_PUBLIC_KEY_INFO *altpub, BIO *out,
+                                 int indent);
+
+const X509V3_EXT_METHOD v3_subject_alt_public_key_info = {
+    NID_subjectAltPublicKeyInfo,
+    X509V3_EXT_MULTILINE, ASN1_ITEM_ref(SUBJECT_ALT_PUBLIC_KEY_INFO),
+    0, 0, 0, 0,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R) i2r_SUBJECT_ALT_PUBLIC_KEY_INFO, NULL,
+    NULL
+};
+
+/* This is the same as the definition of the X509 subject public key in x_pubkey.c  */
+ASN1_SEQUENCE(SUBJECT_ALT_PUBLIC_KEY_INFO) = {
+        ASN1_SIMPLE(SUBJECT_ALT_PUBLIC_KEY_INFO, algor, X509_ALGOR),
+        ASN1_SIMPLE(SUBJECT_ALT_PUBLIC_KEY_INFO, public_key, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(SUBJECT_ALT_PUBLIC_KEY_INFO)
+
+IMPLEMENT_ASN1_FUNCTIONS(SUBJECT_ALT_PUBLIC_KEY_INFO)
+
+static int i2r_SUBJECT_ALT_PUBLIC_KEY_INFO(X509V3_EXT_METHOD *method,
+                                 SUBJECT_ALT_PUBLIC_KEY_INFO *alt_pub, BIO *out,
+                                 int indent)
+{
+
+    X509_PUBKEY *x509_pub = NULL;
+    EVP_PKEY * pkey_pub = NULL;
+    int ret = 0;
+
+    x509_pub = X509_PUBKEY_new();
+    if (x509_pub == NULL) {
+        goto end;
+    }
+
+    /* Prevent the leaking of memory */
+    X509_ALGOR_free(x509_pub->algor);
+    ASN1_BIT_STRING_free(x509_pub->public_key);
+
+    x509_pub->algor = alt_pub->algor;
+    x509_pub->public_key = alt_pub->public_key;
+
+    pkey_pub = X509_PUBKEY_get(x509_pub);
+    if (pkey_pub == NULL) {
+        goto end;
+    }
+    BIO_indent(out, indent, 128);
+    BIO_printf(out, "%s\n", OBJ_nid2ln(OBJ_obj2nid(alt_pub->algor->algorithm)));
+    EVP_PKEY_print_public(out, pkey_pub, indent, NULL);
+    ret = 1;
+
+end:
+    if (pkey_pub)
+        EVP_PKEY_free(pkey_pub);
+    if(x509_pub) {
+        /* Prevent a double free */
+        x509_pub->algor = NULL;
+        x509_pub->public_key = NULL;
+        X509_PUBKEY_free(x509_pub);
+    }
+
+    return ret;
+}
+
+/* ====================================================================
+ * ALT Signature Value Extension.
+ * ====================================================================
+ */
+static int i2r_ALT_SIGNATURE_VALUE(X509V3_EXT_METHOD *method,
+                                 ASN1_BIT_STRING *signature, BIO *out,
+                                 int indent);
+
+const X509V3_EXT_METHOD v3_altSignatureValue = {
+    NID_altSignatureValue, 0, ASN1_ITEM_ref(ASN1_BIT_STRING),
+    0, 0, 0, 0,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R)i2r_ALT_SIGNATURE_VALUE, NULL,
+    NULL
+};
+
+static int i2r_ALT_SIGNATURE_VALUE(X509V3_EXT_METHOD *method,
+                                 ASN1_BIT_STRING *signature, BIO *out,
+                                 int indent)
+{
+    BIO_printf(out, "%*s", indent, "");
+    if (signature) {
+        bitstring_print(out, "Signature: ", signature, indent);
+    }
+    return 1;
+}
+
+/* ====================================================================
+ * ALT Signature Algorithm Extension.
+ * ====================================================================
+ */
+static int i2r_ALT_SIGALG(X509V3_EXT_METHOD *method,
+                                 X509_ALGOR *sigalg, BIO *out,
+                                 int indent);
+
+const X509V3_EXT_METHOD v3_altSignatureAlgorithm = {
+    NID_altSignatureAlgorithm, 0, ASN1_ITEM_ref(X509_ALGOR),
+    0, 0, 0, 0,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R)i2r_ALT_SIGALG, NULL,
+    NULL
+};
+
+static int i2r_ALT_SIGALG(X509V3_EXT_METHOD *method,
+                                 X509_ALGOR *sigalg, BIO *out,
+                                 int indent)
+{
+    BIO_indent(out, indent, 128);
+    BIO_printf(out, "%s\n", OBJ_nid2ln(OBJ_obj2nid(sigalg->algorithm)));
+    return 1;
+}
+
diff --git a/openssl-1.0.2r/crypto/x509v3/x509v3.h b/openssl-1.0.2r/crypto/x509v3/x509v3.h
index f5c61560..170a0216 100644
--- a/openssl-1.0.2r/crypto/x509v3/x509v3.h
+++ b/openssl-1.0.2r/crypto/x509v3/x509v3.h
@@ -154,6 +154,11 @@ DECLARE_STACK_OF(X509V3_EXT_METHOD)
 
 typedef BIT_STRING_BITNAME ENUMERATED_NAMES;
 
+typedef struct SUBJECT_ALT_PUBLIC_KEY_INFO_st {
+    X509_ALGOR *algor;
+    ASN1_BIT_STRING *public_key;
+} SUBJECT_ALT_PUBLIC_KEY_INFO;
+
 typedef struct BASIC_CONSTRAINTS_st {
     int ca;
     ASN1_INTEGER *pathlen;
@@ -503,6 +508,8 @@ typedef struct x509_purpose_st {
 
 DECLARE_STACK_OF(X509_PURPOSE)
 
+DECLARE_ASN1_FUNCTIONS(SUBJECT_ALT_PUBLIC_KEY_INFO)
+
 DECLARE_ASN1_FUNCTIONS(BASIC_CONSTRAINTS)
 
 DECLARE_ASN1_FUNCTIONS(SXNET)
diff --git a/openssl-1.0.2r/crypto/xmss/Makefile b/openssl-1.0.2r/crypto/xmss/Makefile
new file mode 100644
index 00000000..45fa072d
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmss/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/xmss/Makefile
+#
+
+DIR=	xmss
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= xmss_lib.c xmss_asn1.c xmss_err.c
+LIBOBJ= xmss_lib.o xmss_asn1.o xmss_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= xmss.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+xmss_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+xmss_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+xmss_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+xmss_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+xmss_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+xmss_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+xmss_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+xmss_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+xmss_asn1.o: ../../include/openssl/xmss.h ../cryptlib.h xmss_asn1.c
+xmss_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+xmss_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+xmss_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+xmss_err.o: ../../include/openssl/opensslconf.h
+xmss_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+xmss_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+xmss_err.o: ../../include/openssl/symhacks.h ../../include/openssl/xmss.h
+xmss_err.o: xmss_err.c
+xmss_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+xmss_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+xmss_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+xmss_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+xmss_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+xmss_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+xmss_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+xmss_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+xmss_lib.o: ../../include/openssl/opensslconf.h
+xmss_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+xmss_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+xmss_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+xmss_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+xmss_lib.o: ../../include/openssl/x509_vfy.h ../../include/openssl/xmss.h
+xmss_lib.o: ../cryptlib.h xmss_lib.c
diff --git a/openssl-1.0.2r/crypto/xmss/xmss.h b/openssl-1.0.2r/crypto/xmss/xmss.h
new file mode 100644
index 00000000..83f11b6c
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmss/xmss.h
@@ -0,0 +1,170 @@
+/* crypto/xmss/xmss.h based off of crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_XMSS_H
+# define HEADER_XMSS_H
+
+# include <openssl/e_os2.h>
+
+# ifdef OPENSSL_NO_XMSS
+#  error XMSS is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define XMSS_SECURITY_SIZE  64
+
+#define set_tree_height_ctrl_string        "tree_height"
+#define set_strategy_ctrl_string           "strategy"
+#define set_state_filename_ctrl_string     "state_filename"
+
+#define strategy_string_cpu_constrained    "cpu_constrained"
+#define strategy_string_memory_constrained "memory_constrained"
+#define strategy_string_full               "full"
+
+
+#define EVP_PKEY_CTRL_XMSS_TREE_HEIGHT_SET (EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_XMSS_STRATEGY_SET    (EVP_PKEY_ALG_CTRL + 2)
+
+#define XMSS_STRATEGY_CPU_CONSTRAINED      1
+#define XMSS_STRATEGY_MEMORY_CONSTRAINED   2
+#define XMSS_STRATEGY_FULL                 3
+
+struct xmss_st {
+    /* This first variable is used to pick up errors where a XMSS is passed
+     * instead of a EVP_PKEY. These first 2 members are standard for all
+     *  the algorithms.
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    /* The parameters of XMSS.  Please see the spec */
+    long tree_height;
+
+    /* public key */
+    ASN1_OCTET_STRING *pub_key;
+    /* private key */
+    ASN1_OCTET_STRING *priv_key;
+    /* private key state */
+    ASN1_OCTET_STRING *priv_state;
+    /* tree strategy */
+    long strategy;
+
+    /* private key state filename */
+    char *state_filename;
+
+    int flags;
+    int references;
+
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+/* memory management methods for the XMSS struct */
+XMSS *XMSS_new(void);
+XMSS *XMSS_new_with_engine(ENGINE *engine);
+void XMSS_free(XMSS *r);
+int XMSS_up_ref(XMSS *r);
+
+/* ASN.1 for public key */
+XMSS *d2i_XMSSPublicKey(XMSS **a, const unsigned char **pp, long length);
+int i2d_XMSSPublicKey(const XMSS *a, unsigned char **pp);
+
+/* ASN.1 for private key */
+XMSS *d2i_XMSSPrivateKey(XMSS **a, const unsigned char **pp, long length);
+int i2d_XMSSPrivateKey(const XMSS *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_XMSS_strings(void);
+
+/* Error codes for the XMSS functions. */
+
+/* Function codes. */
+# define XMSS_F_XMSS_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define XMSS_R_ENGINE_INIT_FAILURE                        100
+# define XMSS_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/xmss/xmss_asn1.c b/openssl-1.0.2r/crypto/xmss/xmss_asn1.c
new file mode 100644
index 00000000..181418b1
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmss/xmss_asn1.c
@@ -0,0 +1,120 @@
+/* xmss_asn1.c based off of dsa_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/xmss.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int xmss_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)XMSS_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        XMSS_free((XMSS *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(XMSSPrivateKey, xmss_cb) = {
+        ASN1_SIMPLE(XMSS, version, LONG),
+        ASN1_SIMPLE(XMSS, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(XMSS, tree_height, LONG),
+        ASN1_SIMPLE(XMSS, strategy, LONG),
+        ASN1_SIMPLE(XMSS, pub_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(XMSS, XMSSPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(XMSS, XMSSPrivateKey, XMSSPrivateKey)
+
+XMSS *d2i_XMSSPublicKey(XMSS **a, const unsigned char **pp, long length) {
+    XMSS *xmss = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    xmss = XMSS_new();
+    if (xmss == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        XMSS_free(xmss);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            XMSS_free(*a);
+        *a = xmss;
+    }
+
+    xmss->pub_key = pub_key;
+    return xmss;
+}
+
+int i2d_XMSSPublicKey(const XMSS *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
diff --git a/openssl-1.0.2r/crypto/xmss/xmss_err.c b/openssl-1.0.2r/crypto/xmss/xmss_err.c
new file mode 100644
index 00000000..9554868c
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmss/xmss_err.c
@@ -0,0 +1,94 @@
+/* crypto/xmss/xmss_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2017 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/xmss.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_XMSS,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_XMSS,0,reason)
+
+static ERR_STRING_DATA XMSS_str_functs[] = {
+    {ERR_FUNC(XMSS_F_XMSS_NEW_WITH_ENGINE), "XMSS_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA XMSS_str_reasons[] = {
+    {ERR_REASON(XMSS_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(XMSS_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_XMSS_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(XMSS_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, XMSS_str_functs);
+        ERR_load_strings(0, XMSS_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/xmss/xmss_lib.c b/openssl-1.0.2r/crypto/xmss/xmss_lib.c
new file mode 100644
index 00000000..e815aa69
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmss/xmss_lib.c
@@ -0,0 +1,183 @@
+/* crypto/xmss/xmss_lib.c based off of crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/xmss.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char XMSS_version[] = "XMSS" OPENSSL_VERSION_PTEXT;
+
+
+XMSS *XMSS_new(void) {
+    return XMSS_new_with_engine(NULL);
+}
+
+XMSS *XMSS_new_with_engine(ENGINE *engine)
+{
+    XMSS *ret;
+
+    ret = (XMSS *)OPENSSL_malloc(sizeof(XMSS));
+    if (ret == NULL) {
+        XMSSerr(XMSS_F_XMSS_NEW_WITH_ENGINE, XMSS_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            XMSSerr(XMSS_F_XMSS_NEW_WITH_ENGINE, XMSS_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where 
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+    ret->tree_height = -1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->priv_state = NULL;
+    ret->strategy = -1;
+    ret->state_filename = NULL;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_XMSS, ret, &ret->ex_data);
+    return (ret);
+}
+
+void XMSS_free(XMSS *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_XMSS);
+#ifdef REF_PRINT
+    REF_PRINT("XMSS", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "XMSS_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+#ifndef OPENSSL_NO_ENGINE
+    if (r->engine)
+        ENGINE_finish(r->engine);
+#endif
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_XMSS, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->priv_state != NULL) {
+        OPENSSL_cleanse(r->priv_state->data, (size_t)r->priv_state->length);
+        ASN1_OCTET_STRING_free(r->priv_state);
+    }
+    if (r->state_filename != NULL) {
+        OPENSSL_free(r->state_filename);
+    }
+    r->strategy = -1;
+
+    OPENSSL_free(r);
+}
+
+int XMSS_up_ref(XMSS *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_XMSS);
+#ifdef REF_PRINT
+    REF_PRINT("XMSS", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "XMSS_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
diff --git a/openssl-1.0.2r/crypto/xmssmt/Makefile b/openssl-1.0.2r/crypto/xmssmt/Makefile
new file mode 100644
index 00000000..ef950c5a
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmssmt/Makefile
@@ -0,0 +1,111 @@
+#
+# OpenSSL/crypto/xmssmt/Makefile
+#
+
+DIR=	xmssmt
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+#TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= xmssmt_lib.c xmssmt_asn1.c xmssmt_err.c
+LIBOBJ= xmssmt_lib.o xmssmt_asn1.o xmssmt_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= xmssmt.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	ranlib ../../libcrypto.a
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+update: depend
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+xmssmt_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+xmssmt_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+xmssmt_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+xmssmt_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+xmssmt_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+xmssmt_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+xmssmt_asn1.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
+xmssmt_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+xmssmt_asn1.o: ../../include/openssl/xmssmt.h ../cryptlib.h xmssmt_asn1.c
+xmssmt_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+xmssmt_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+xmssmt_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+xmssmt_err.o: ../../include/openssl/opensslconf.h
+xmssmt_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+xmssmt_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+xmssmt_err.o: ../../include/openssl/symhacks.h ../../include/openssl/xmssmt.h
+xmssmt_err.o: xmssmt_err.c
+xmssmt_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+xmssmt_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+xmssmt_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+xmssmt_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+xmssmt_lib.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+xmssmt_lib.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+xmssmt_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+xmssmt_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+xmssmt_lib.o: ../../include/openssl/opensslconf.h
+xmssmt_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+xmssmt_lib.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+xmssmt_lib.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+xmssmt_lib.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+xmssmt_lib.o: ../../include/openssl/x509_vfy.h ../../include/openssl/xmssmt.h
+xmssmt_lib.o: ../cryptlib.h xmssmt_lib.c
diff --git a/openssl-1.0.2r/crypto/xmssmt/xmssmt.h b/openssl-1.0.2r/crypto/xmssmt/xmssmt.h
new file mode 100644
index 00000000..48e7f3d2
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmssmt/xmssmt.h
@@ -0,0 +1,172 @@
+/* crypto/xmssmt/xmssmt.h based off of crypto/dsa/dsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/*
+ * The DSS routines are based on patches supplied by
+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
+ * work and I have just tweaked them a little to fit into my
+ * stylistic vision for SSLeay :-) */
+
+#ifndef HEADER_XMSSMT_H
+# define HEADER_XMSSMT_H
+
+# include <openssl/e_os2.h>
+
+# ifdef OPENSSL_NO_XMSSMT
+#  error XMSSMT is disabled.
+# endif
+
+# ifndef OPENSSL_NO_BIO
+#  include <openssl/bio.h>
+# endif
+# include <openssl/crypto.h>
+# include <openssl/ossl_typ.h>
+
+#include <openssl/asn1.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define XMSSMT_SECURITY_SIZE  64
+
+#define set_tree_height_ctrl_string          "tree_height"
+#define set_tree_layers_ctrl_string          "tree_layers"
+#define set_strategy_ctrl_string             "strategy"
+#define set_state_filename_ctrl_string       "state_filename"
+
+#define strategy_string_cpu_constrained      "cpu_constrained"
+#define strategy_string_memory_constrained   "memory_constrained"
+#define strategy_string_full                 "full"
+
+#define EVP_PKEY_CTRL_XMSSMT_TREE_HEIGHT_SET (EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_XMSSMT_TREE_LAYERS_SET (EVP_PKEY_ALG_CTRL + 2)
+#define EVP_PKEY_CTRL_XMSSMT_STRATEGY_SET    (EVP_PKEY_ALG_CTRL + 3)
+
+#define XMSSMT_STRATEGY_CPU_CONSTRAINED      1
+#define XMSSMT_STRATEGY_MEMORY_CONSTRAINED   2
+#define XMSSMT_STRATEGY_FULL                 3
+
+struct xmssmt_st {
+    /* This first variable is used to pick up errors where a XMSSMT is passed
+     * instead of a EVP_PKEY. These first 2 members are standard for all
+     *  the algorithms.
+     */
+    int pad;
+    long version;
+    int write_params;
+
+    /* The parameters of XMSSMT.  Please see the spec */
+    long tree_height;
+    long tree_layers;
+
+    /* public key */
+    ASN1_OCTET_STRING *pub_key;
+    /* private key */
+    ASN1_OCTET_STRING *priv_key;
+    /* private key state */
+    ASN1_OCTET_STRING *priv_state;
+    /* tree strategy */
+    long strategy;
+
+    /* private key state filename */
+    char *state_filename;
+
+    int flags;
+    int references;
+
+    CRYPTO_EX_DATA ex_data;
+
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+};
+
+/* memory management methods for the XMSSMT struct */
+XMSSMT *XMSSMT_new(void);
+XMSSMT *XMSSMT_new_with_engine(ENGINE *engine);
+void XMSSMT_free(XMSSMT *r);
+int XMSSMT_up_ref(XMSSMT *r);
+
+/* ASN.1 for public key */
+XMSSMT *d2i_XMSSMTPublicKey(XMSSMT **a, const unsigned char **pp, long length);
+int i2d_XMSSMTPublicKey(const XMSSMT *a, unsigned char **pp);
+
+/* ASN.1 for private key */
+XMSSMT *d2i_XMSSMTPrivateKey(XMSSMT **a, const unsigned char **pp, long length);
+int i2d_XMSSMTPrivateKey(const XMSSMT *a, unsigned char **pp);
+
+/* BEGIN ERROR CODES */
+/*
+ * The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_XMSSMT_strings(void);
+
+/* Error codes for the XMSSMT functions. */
+
+/* Function codes. */
+# define XMSSMT_F_XMSSMT_NEW_WITH_ENGINE                        100
+
+/* Reason codes. */
+# define XMSSMT_R_ENGINE_INIT_FAILURE                        100
+# define XMSSMT_R_MALLOC_FAILURE                             101
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff --git a/openssl-1.0.2r/crypto/xmssmt/xmssmt_asn1.c b/openssl-1.0.2r/crypto/xmssmt/xmssmt_asn1.c
new file mode 100644
index 00000000..38ce555c
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmssmt/xmssmt_asn1.c
@@ -0,0 +1,121 @@
+/* xmssmt_asn1.c based off of dsa_asn1.c */
+/*
+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/xmssmt.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/rand.h>
+
+/* Override the default free and new methods */
+static int xmssmt_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
+                  void *exarg)
+{
+    if (operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)XMSSMT_new();
+        if (*pval)
+            return 2;
+        return 0;
+    } else if (operation == ASN1_OP_FREE_PRE) {
+        XMSSMT_free((XMSSMT *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+ASN1_SEQUENCE_cb(XMSSMTPrivateKey, xmssmt_cb) = {
+        ASN1_SIMPLE(XMSSMT, version, LONG),
+        ASN1_SIMPLE(XMSSMT, priv_key, ASN1_OCTET_STRING),
+        ASN1_SIMPLE(XMSSMT, tree_height, LONG),
+        ASN1_SIMPLE(XMSSMT, tree_layers, LONG),
+        ASN1_SIMPLE(XMSSMT, strategy, LONG),
+        ASN1_SIMPLE(XMSSMT, pub_key, ASN1_OCTET_STRING),
+} ASN1_SEQUENCE_END_cb(XMSSMT, XMSSMTPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(XMSSMT, XMSSMTPrivateKey, XMSSMTPrivateKey)
+
+XMSSMT *d2i_XMSSMTPublicKey(XMSSMT **a, const unsigned char **pp, long length) {
+    XMSSMT *xmssmt = NULL;
+    ASN1_OCTET_STRING *pub_key = NULL;
+
+    xmssmt = XMSSMT_new();
+    if (xmssmt == NULL)
+        return NULL;
+
+    pub_key = d2i_ASN1_OCTET_STRING(NULL, pp, length);
+    if (pub_key == NULL) {
+        XMSSMT_free(xmssmt);
+        return NULL;
+    }
+
+    if (a) {
+        if (*a)
+            XMSSMT_free(*a);
+        *a = xmssmt;
+    }
+
+    xmssmt->pub_key = pub_key;
+    return xmssmt;
+}
+
+int i2d_XMSSMTPublicKey(const XMSSMT *a, unsigned char **pp) {
+    return i2d_ASN1_OCTET_STRING(a->pub_key, pp);
+}
diff --git a/openssl-1.0.2r/crypto/xmssmt/xmssmt_err.c b/openssl-1.0.2r/crypto/xmssmt/xmssmt_err.c
new file mode 100644
index 00000000..67e10a32
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmssmt/xmssmt_err.c
@@ -0,0 +1,94 @@
+/* crypto/xmssmt/xmssmt_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2017 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/*
+ * NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/xmssmt.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+# define ERR_FUNC(func) ERR_PACK(ERR_LIB_XMSSMT,func,0)
+# define ERR_REASON(reason) ERR_PACK(ERR_LIB_XMSSMT,0,reason)
+
+static ERR_STRING_DATA XMSSMT_str_functs[] = {
+    {ERR_FUNC(XMSSMT_F_XMSSMT_NEW_WITH_ENGINE), "XMSSMT_new_with_engine"},
+    {0, NULL}
+};
+
+static ERR_STRING_DATA XMSSMT_str_reasons[] = {
+    {ERR_REASON(XMSSMT_R_ENGINE_INIT_FAILURE), "engine init failure"},
+    {ERR_REASON(XMSSMT_R_MALLOC_FAILURE), "malloc failure"},
+    {0, NULL}
+};
+
+#endif
+
+void ERR_load_XMSSMT_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+
+    if (ERR_func_error_string(XMSSMT_str_functs[0].error) == NULL) {
+        ERR_load_strings(0, XMSSMT_str_functs);
+        ERR_load_strings(0, XMSSMT_str_reasons);
+    }
+#endif
+}
diff --git a/openssl-1.0.2r/crypto/xmssmt/xmssmt_lib.c b/openssl-1.0.2r/crypto/xmssmt/xmssmt_lib.c
new file mode 100644
index 00000000..fc69eafa
--- /dev/null
+++ b/openssl-1.0.2r/crypto/xmssmt/xmssmt_lib.c
@@ -0,0 +1,184 @@
+/* crypto/xmssmt/xmssmt_lib.c based off of crypto/dsa/dsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Original version from Steven Schoch <schoch@sheba.arc.nasa.gov> */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/xmssmt.h>
+#include <openssl/asn1.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
+
+#ifdef OPENSSL_FIPS
+# include <openssl/fips.h>
+#endif
+
+const char XMSSMT_version[] = "XMSSMT" OPENSSL_VERSION_PTEXT;
+
+
+XMSSMT *XMSSMT_new(void) {
+    return XMSSMT_new_with_engine(NULL);
+}
+
+XMSSMT *XMSSMT_new_with_engine(ENGINE *engine)
+{
+    XMSSMT *ret;
+
+    ret = (XMSSMT *)OPENSSL_malloc(sizeof(XMSSMT));
+    if (ret == NULL) {
+        XMSSMTerr(XMSSMT_F_XMSSMT_NEW_WITH_ENGINE, XMSSMT_R_MALLOC_FAILURE);
+        return (NULL);
+    }
+    if (engine) {
+        if (!ENGINE_init(engine)) {
+            XMSSMTerr(XMSSMT_F_XMSSMT_NEW_WITH_ENGINE, XMSSMT_R_ENGINE_INIT_FAILURE);
+            OPENSSL_free(ret);
+            return NULL;
+        }
+        ret->engine = engine;
+    } else {
+
+        /*
+         * It appears that there is some situation in the current setup where
+         * OpenSSL_free will NOT memset this to 0. This results in some leftover
+         * value that ENGINE_finish tries to use below...
+         */
+
+        ret->engine = NULL;
+    }
+
+    ret->pad = 0;
+    ret->version = 0;
+    ret->write_params = 1;
+    ret->tree_height = -1;
+    ret->tree_layers = -1;
+    ret->pub_key = NULL;
+    ret->priv_key = NULL;
+    ret->priv_state = NULL;
+    ret->strategy = -1;
+    ret->state_filename = NULL;
+
+    ret->references = 1;
+    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_XMSSMT, ret, &ret->ex_data);
+    return (ret);
+}
+
+void XMSSMT_free(XMSSMT *r)
+{
+    int i;
+
+    if (r == NULL)
+        return;
+
+    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_XMSSMT);
+#ifdef REF_PRINT
+    REF_PRINT("XMSSMT", r);
+#endif
+    if (i > 0)
+        return;
+#ifdef REF_CHECK
+    if (i < 0) {
+        fprintf(stderr, "XMSSMT_free, bad reference count\n");
+        abort();
+    }
+#endif
+
+#ifndef OPENSSL_NO_ENGINE
+    if (r->engine)
+        ENGINE_finish(r->engine);
+#endif
+
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_XMSSMT, r, &r->ex_data);
+
+    if (r->pub_key != NULL)
+        ASN1_OCTET_STRING_free(r->pub_key);
+    if (r->priv_key != NULL) {
+        OPENSSL_cleanse(r->priv_key->data, (size_t)r->priv_key->length);
+        ASN1_OCTET_STRING_free(r->priv_key);
+    }
+    if (r->priv_state != NULL) {
+        OPENSSL_cleanse(r->priv_state->data, (size_t)r->priv_state->length);
+        ASN1_OCTET_STRING_free(r->priv_state);
+    }
+    if (r->state_filename != NULL) {
+        OPENSSL_free(r->state_filename);
+    }
+    r->strategy = -1;
+
+    OPENSSL_free(r);
+}
+
+int XMSSMT_up_ref(XMSSMT *r)
+{
+    int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_XMSSMT);
+#ifdef REF_PRINT
+    REF_PRINT("XMSSMT", r);
+#endif
+#ifdef REF_CHECK
+    if (i < 2) {
+        fprintf(stderr, "XMSSMT_up_ref, bad reference count\n");
+        abort();
+    }
+#endif
+    return ((i > 1) ? 1 : 0);
+}
+
diff --git a/openssl-1.0.2r/ssl/d1_srvr.c b/openssl-1.0.2r/ssl/d1_srvr.c
index 8502b242..b196a187 100644
--- a/openssl-1.0.2r/ssl/d1_srvr.c
+++ b/openssl-1.0.2r/ssl/d1_srvr.c
@@ -515,6 +515,10 @@ int dtls1_accept(SSL *s)
 #endif
                 || (alg_k & SSL_kDHE)
                 || (alg_k & SSL_kEECDH)
+                || (alg_k & SSL_kENHDH)
+                || (alg_k & SSL_kESIDH)
+                || (alg_k & SSL_kEKYBER)
+                || (alg_k & SSL_kESIKE)
                 || ((alg_k & SSL_kRSA)
                     && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
                         || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
diff --git a/openssl-1.0.2r/ssl/s3_both.c b/openssl-1.0.2r/ssl/s3_both.c
index 054ded1c..dd3e6cf5 100644
--- a/openssl-1.0.2r/ssl/s3_both.c
+++ b/openssl-1.0.2r/ssl/s3_both.c
@@ -124,6 +124,10 @@
 #include <openssl/evp.h>
 #include <openssl/x509.h>
 
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+
 /*
  * send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or
  * SSL3_RT_CHANGE_CIPHER_SPEC)
@@ -501,6 +505,21 @@ int ssl_cert_type(X509 *x, EVP_PKEY *pkey)
         ret = SSL_PKEY_GOST94;
     } else if (i == NID_id_GostR3410_2001 || i == NID_id_GostR3410_2001_cc) {
         ret = SSL_PKEY_GOST01;
+    } else if (i == EVP_PKEY_HSS) {
+        ret = SSL_PKEY_HSS;
+    } else if (i == EVP_PKEY_XMSS) {
+        ret = SSL_PKEY_XMSS;
+    } else if (i == EVP_PKEY_XMSSMT) {
+        ret = SSL_PKEY_XMSSMT;
+    } else if (i == EVP_PKEY_DILITHIUM) {
+        /*
+         * TODO (ISARA): We may be able to make parameter selection more generic (T3876).
+         */
+        if (pk->pkey.dilithium->parameter_set == DILITHIUM_III_SHAKE_R2) {
+            ret = SSL_PKEY_DILITHIUM_III_SHAKE_R2;
+        } else if (pk->pkey.dilithium->parameter_set == DILITHIUM_IV_SHAKE_R2) {
+            ret = SSL_PKEY_DILITHIUM_IV_SHAKE_R2;
+        }
     } else if (x && (i == EVP_PKEY_DH || i == EVP_PKEY_DHX)) {
         /*
          * For DH two cases: DH certificate signed with RSA and DH
diff --git a/openssl-1.0.2r/ssl/s3_clnt.c b/openssl-1.0.2r/ssl/s3_clnt.c
index bd0929d0..4caf57aa 100644
--- a/openssl-1.0.2r/ssl/s3_clnt.c
+++ b/openssl-1.0.2r/ssl/s3_clnt.c
@@ -156,22 +156,291 @@
 #include <openssl/objects.h>
 #include <openssl/evp.h>
 #include <openssl/md5.h>
+#include <openssl/x509v3.h>
 #ifdef OPENSSL_FIPS
 # include <openssl/fips.h>
 #endif
 #ifndef OPENSSL_NO_DH
 # include <openssl/dh.h>
 #endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
 #include <openssl/bn.h>
 #ifndef OPENSSL_NO_ENGINE
 # include <openssl/engine.h>
 #endif
+#ifndef OPENSSL_NO_NHDH
+#include <openssl/nhdh.h>
+#endif
+#ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+#endif
+#ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+#endif
+#ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+#endif
 
 static int ca_dn_cmp(const X509_NAME *const *a, const X509_NAME *const *b);
 #ifndef OPENSSL_NO_TLSEXT
 static int ssl3_check_finished(SSL *s);
 #endif
 
+/*
+ * This creates the TLS premaster secret on the client-side.
+ *
+ * For DHs, it creates the client public key to send to the server.
+ * For KEMs, it creates the client ciphertext to send to the server.
+ */
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+static int iqrssl_generate_client_pubkey_premaster_secret(SSL *s, int algo_type, EVP_PKEY_CTX **client_iqre_pkey_ctx,
+    EVP_PKEY **client_iqre_pkey, unsigned char **iqre_premaster_secret, size_t *iqre_premaster_secret_size)
+{
+    int ret = -1;
+    int qs_idx = 0;
+
+    EVP_PKEY *server_iqre_pubpkey = NULL;
+    const unsigned char *server_iqre_pubkey_octet = NULL;
+    size_t server_iqre_pubkey_octet_size = 0;
+
+    EVP_PKEY_CTX *client_iqre_pkey_ctx_tmp = NULL;
+    EVP_PKEY *client_iqre_pkey_tmp = NULL;
+
+    size_t iqre_premaster_secret_size_tmp = 0;
+    int evp_pkey_ctrl_paramset = 0;
+
+    if (algo_type == EVP_PKEY_NHDH) {
+        evp_pkey_ctrl_paramset = EVP_PKEY_CTRL_NHDH_ROLE_SET;
+    } else if (algo_type == EVP_PKEY_SIDH) {
+        evp_pkey_ctrl_paramset = EVP_PKEY_CTRL_SIDH_ROLE_SET;
+    } else if (EVP_PKEY_is_QS_kem(algo_type)) {
+        // no-op, as there is no role set for KEMs.
+    }else {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        goto end;
+    }
+
+    /*
+     * Create client pkey context for IQR key agreement schemes.
+     * IQR engine needs to be loaded (e.g., in the app code space) before this step.
+     */
+    client_iqre_pkey_ctx_tmp = EVP_PKEY_CTX_new_id(algo_type, NULL);
+    if (client_iqre_pkey_ctx_tmp == NULL) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        goto end;
+    }
+
+    *client_iqre_pkey_ctx = client_iqre_pkey_ctx_tmp;
+
+    /*
+     * This currently is no-op for both DHs and KEMs, but the
+     * underlying EVP implementation could change in the future.
+     */
+    if (EVP_PKEY_keygen_init(client_iqre_pkey_ctx_tmp) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        goto end;
+    }
+
+    /*
+     * Client is the responder of the key exchange.
+     * This function call shall only be used for DHs.
+     */
+    int isInitiator = 0;
+    if (EVP_PKEY_is_QS_dh(algo_type)) {
+        if (EVP_PKEY_CTX_ctrl(client_iqre_pkey_ctx_tmp, algo_type, -1, evp_pkey_ctrl_paramset, 1, &isInitiator) <= 0) {
+            SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+            goto end;
+        }
+    }
+
+    /* Set the negotiated parameter for the key exchange algo. */
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx]) {
+            int parameter_set = tls1_qs_keyexch_get_parameter_set(s->session->shared_qs_key_exch_parameters[qs_idx]);
+            int i = 0;
+
+            for (i = 0; i < SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num; i++) {
+                if (parameter_set == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_internal[i]) {
+                    break;
+                }
+            }
+
+            if (i == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num) {
+                SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+                return -1;
+            }
+
+            if (EVP_PKEY_CTX_ctrl(client_iqre_pkey_ctx_tmp, algo_type, -1,
+                QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_PKEY_CTRL_CMD][qs_idx], 1, &parameter_set) <= 0) {
+                SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+                return -1;
+            }
+        }
+    }
+
+    /*
+     * Create client pkey struct.
+     *
+     * This is only needed for DHs, as KEMs do not have client-side public and private key pairs.
+     */
+    if (EVP_PKEY_is_QS_dh(algo_type)) {
+        if (EVP_PKEY_keygen(client_iqre_pkey_ctx_tmp, &client_iqre_pkey_tmp) <= 0) {
+            SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+            goto end;
+        }
+
+        *client_iqre_pkey = client_iqre_pkey_tmp;
+    }
+
+    /*
+     * For DHs, the actual private and public key pair is created in this step.
+     *
+     * For KEMs, this is no-op.
+     */
+    if (EVP_PKEY_derive_init(client_iqre_pkey_ctx_tmp) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        goto end;
+    }
+
+    /* Restore server key from DER to PKEY. */
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx]) {
+            server_iqre_pubkey_octet = s->session->sess_cert->peer_qs_pub_tmp[qs_idx];
+            server_iqre_pubkey_octet_size = s->session->sess_cert->peer_qs_pub_size_tmp[qs_idx];
+
+            if (server_iqre_pubkey_octet == NULL || server_iqre_pubkey_octet_size == 0) {
+                SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_INTERNAL_ERROR);
+                goto end;
+            }
+        }
+    }
+
+    server_iqre_pubpkey = o2i_PublicKey(algo_type, NULL, server_iqre_pubkey_octet, server_iqre_pubkey_octet_size);
+    if (server_iqre_pubpkey == NULL) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_ASN1_LIB);
+        goto end;
+    }
+
+    /*
+     * Give the server public key to the client for deriving the premaster secret.
+     *
+     * For KEMs, the encapsulation operation is performed.
+     * */
+    if (EVP_PKEY_derive_set_peer(client_iqre_pkey_ctx_tmp, server_iqre_pubpkey) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        goto end;
+    }
+
+    /* Get the size of the premaster secret. */
+    if (EVP_PKEY_derive(client_iqre_pkey_ctx_tmp, NULL, &iqre_premaster_secret_size_tmp) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        goto end;
+    }
+
+    *iqre_premaster_secret = OPENSSL_malloc(iqre_premaster_secret_size_tmp);
+    if (*iqre_premaster_secret == NULL) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_MALLOC_FAILURE);
+        goto end;
+    }
+
+    /* Client generates the premaster secret. */
+    if (EVP_PKEY_derive(client_iqre_pkey_ctx_tmp, *iqre_premaster_secret, &iqre_premaster_secret_size_tmp) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        goto end;
+    }
+
+    *iqre_premaster_secret_size = iqre_premaster_secret_size_tmp;
+
+    /* For KEMs, the client pkey contains the ciphertext that will be sent to the server. */
+    if (EVP_PKEY_is_QS_kem(algo_type)) {
+        *client_iqre_pkey = EVP_PKEY_CTX_get0_pkey(client_iqre_pkey_ctx_tmp);
+        if ((*client_iqre_pkey) == NULL) {
+            SSLerr(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET, ERR_R_EVP_LIB);
+            goto end;
+        }
+
+        /*
+         * We need to increment the reference count on this pkey as it is
+         * actually the peer pkey set in EVP_PKEY_derive_set_peer().
+         *
+         * This means that it will be freed one more time after KEM info is
+         * processed.
+         *
+         * Perhaps we shall consider not setting peer pkey as the ctx->pkey
+         * in client_iqre_pkey_ctx for KEMs? Or at least making it a duplicate?
+         * (This would require changes in <kem>_pmeth.c.)
+         */
+        CRYPTO_add(&(*client_iqre_pkey)->references, 1, CRYPTO_LOCK_EVP_PKEY);
+    }
+
+    ret = 1;
+
+end:
+    EVP_PKEY_free(server_iqre_pubpkey);
+
+    return ret;
+}
+
+static int iqrssl_parse_server_key_exch_msg(SSL *s, long algo_type, unsigned char **message, long *message_size, long *parsed_size,
+    int *alert_type)
+{
+    int qs_idx = 0;
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            unsigned char *server_pubkey_octet = NULL;
+            size_t server_pubkey_octet_size = 0;
+
+            if ((*message_size) < 4) {
+                /* The message does not even contain the server key exchange parameter and public key size. */
+                *alert_type = SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_IQRSSL_PARSE_SERVER_KEY_EXCH_MSG, SSL_R_BAD_LENGTH);
+                return -1;
+            }
+
+            /* Get the server key exchange parameter. */
+            n2s((*message), s->session->shared_qs_key_exch_parameters[qs_idx]);
+            *message_size = (*message_size) - 2;
+            *parsed_size = (*parsed_size) + 2;
+
+            /* Read the server public key size. */
+            n2s((*message), server_pubkey_octet_size);
+            *message_size = (*message_size) - 2;
+            *parsed_size = (*parsed_size) + 2;
+
+            if ((*message_size) < server_pubkey_octet_size) {
+                /* The message does not contain the whole server public key. */
+                *alert_type = SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_IQRSSL_PARSE_SERVER_KEY_EXCH_MSG, SSL_R_BAD_LENGTH);
+                return -1;
+            }
+
+            server_pubkey_octet = OPENSSL_malloc(server_pubkey_octet_size);
+            if (server_pubkey_octet == NULL) {
+                SSLerr(SSL_F_IQRSSL_PARSE_SERVER_KEY_EXCH_MSG, ERR_R_MALLOC_FAILURE);
+                return -2;
+            }
+
+            /* Get the server public key. */
+            memcpy(server_pubkey_octet, (*message), server_pubkey_octet_size);
+
+            *message = (*message) + server_pubkey_octet_size;
+            *message_size = (*message_size) - server_pubkey_octet_size;
+            *parsed_size = (*parsed_size) + server_pubkey_octet_size;
+
+            /* Save the server public key for later for client premaster secret generation. */
+            s->session->sess_cert->peer_qs_pub_tmp[qs_idx] = server_pubkey_octet;
+            s->session->sess_cert->peer_qs_pub_size_tmp[qs_idx] = server_pubkey_octet_size;
+        }
+    }
+
+    return 1;
+}
+
+#endif
+
 #ifndef OPENSSL_NO_SSL3_METHOD
 static const SSL_METHOD *ssl3_get_client_method(int ver)
 {
@@ -1324,14 +1593,40 @@ int ssl3_get_server_certificate(SSL *s)
     }
 
     if (need_cert) {
-        int exp_idx = ssl_cipher_get_cert_index(s->s3->tmp.new_cipher);
+        int exp_idx = ssl_cipher_get_cert_index(NULL, pkey, s->s3->tmp.new_cipher);
         if (exp_idx >= 0 && i != exp_idx) {
-            x = NULL;
-            al = SSL_AD_ILLEGAL_PARAMETER;
-            SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
-                   SSL_R_WRONG_CERTIFICATE_TYPE);
-            goto f_err;
+            EVP_PKEY_free(pkey);
+
+            /* Get the QS alternative PKEY. */
+            pkey = SSL_get_alt_pubkey(x);
+            if (pkey == NULL) {
+                x = NULL;
+                al = SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
+                       SSL_R_WRONG_CERTIFICATE_TYPE);
+                goto f_err;
+            }
+
+            i = ssl_cert_type(NULL, pkey);
+
+            /*
+             * Call ssl_cipher_get_cert_index() again to obtain the
+             * accurate parameter index using the alt pkey, in the case
+             * of multiple parameters support.
+             */
+            exp_idx = ssl_cipher_get_cert_index(NULL, pkey, s->s3->tmp.new_cipher);
+
+            if (i != exp_idx) {
+                x = NULL;
+                al = SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
+                       SSL_R_WRONG_CERTIFICATE_TYPE);
+                goto f_err;
+            }
+
+            sc->peer_pkeys[i].is_mpka_cert = 1;
         }
+
         sc->peer_cert_type = i;
         CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
         /*
@@ -1379,10 +1674,11 @@ int ssl3_get_key_exchange(SSL *s)
 #endif
     EVP_MD_CTX md_ctx;
     unsigned char *param, *p;
-    int al, j, ok;
+    int al, j, ok, qs_idx, ret;
     long i, param_len, n, alg_k, alg_a;
     EVP_PKEY *pkey = NULL;
     const EVP_MD *md = NULL;
+    EVP_PKEY_CTX *ctx = NULL;
 #ifndef OPENSSL_NO_RSA
     RSA *rsa = NULL;
 #endif
@@ -1459,6 +1755,16 @@ int ssl3_get_key_exchange(SSL *s)
             s->session->sess_cert->peer_ecdh_tmp = NULL;
         }
 #endif
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+            if (s->session->sess_cert->peer_qs_pub_tmp[qs_idx]) {
+                OPENSSL_free(s->session->sess_cert->peer_qs_pub_tmp[qs_idx]);
+                s->session->sess_cert->peer_qs_pub_tmp[qs_idx] = NULL;
+                s->session->sess_cert->peer_qs_pub_size_tmp[qs_idx] = 0;
+            }
+        }
+#endif
     } else {
         s->session->sess_cert = ssl_sess_cert_new();
     }
@@ -1820,7 +2126,6 @@ int ssl3_get_key_exchange(SSL *s)
         goto f_err;
     }
 #endif                          /* !OPENSSL_NO_DH */
-
 #ifndef OPENSSL_NO_ECDH
     else if (alg_k & SSL_kEECDH) {
         EC_GROUP *ngroup;
@@ -1908,6 +2213,16 @@ int ssl3_get_key_exchange(SSL *s)
         n -= param_len;
         p += encoded_pt_len;
 
+        /* Hybrid QS key exchange algorithms with ECDH for TLS key exchange */
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        ret = iqrssl_parse_server_key_exch_msg(s, alg_k, &p, &n, &param_len, &al);
+        if (ret == -1) {
+            goto f_err;
+        } else if (ret == -2) {
+            goto err;
+        }
+#endif
+
         /*
          * The ECC/TLS specification does not mention the use of DSA to sign
          * ECParameters in the server key exchange message. We do support RSA
@@ -1920,6 +2235,21 @@ int ssl3_get_key_exchange(SSL *s)
                 X509_get_pubkey(s->session->
                                 sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
 # endif
+# ifndef OPENSSL_NO_DILITHIUM
+        else if (alg_a & SSL_aDILITHIUM)
+            /*
+             * We need to use peer_cert_type as index here as there
+             * are more than one Dilithium parameter and there is
+             * one type for each parameter. The auth algo from the
+             * ciphersuite can only tell us the algorithm name but
+             * contains no info on the parameter.
+             */
+            if (s->session->sess_cert->peer_pkeys[s->session->sess_cert->peer_cert_type].is_mpka_cert) {
+                pkey = SSL_get_alt_pubkey(s->session->sess_cert->peer_pkeys[s->session->sess_cert->peer_cert_type].x509);
+            } else {
+                pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[s->session->sess_cert->peer_cert_type].x509);
+            }
+# endif
 # ifndef OPENSSL_NO_ECDSA
         else if (alg_a & SSL_aECDSA)
             pkey =
@@ -1934,12 +2264,44 @@ int ssl3_get_key_exchange(SSL *s)
         bn_ctx = NULL;
         EC_POINT_free(srvr_ecpoint);
         srvr_ecpoint = NULL;
-    } else if (alg_k) {
+    }
+#endif                          /* !OPENSSL_NO_ECDH */
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    else if (iqrssl_is_qs_kem_key_exch(alg_k)) {
+        ret = iqrssl_parse_server_key_exch_msg(s, alg_k, &p, &n, &param_len, &al);
+        if (ret == -1) {
+            goto f_err;
+        } else if (ret == -2) {
+            goto err;
+        }
+
+        if (0) {}
+# ifndef OPENSSL_NO_RSA
+        else if (alg_a & SSL_aRSA) {
+            pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
+        }
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+        else if (alg_a & SSL_aDILITHIUM) {
+            if (s->session->sess_cert->peer_pkeys[s->session->sess_cert->peer_cert_type].is_mpka_cert) {
+                pkey = SSL_get_alt_pubkey(s->session->sess_cert->peer_pkeys[s->session->sess_cert->peer_cert_type].x509);
+            } else {
+                pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[s->session->sess_cert->peer_cert_type].x509);
+            }
+        }
+# endif
+# ifndef OPENSSL_NO_ECDSA
+        else if (alg_a & SSL_aECDSA) {
+            pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
+        }
+# endif
+    }
+#endif                          /* !OPENSSL_NO_QS_KEY_EXCHANGE */
+    else if (alg_k) {
         al = SSL_AD_UNEXPECTED_MESSAGE;
         SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
         goto f_err;
     }
-#endif                          /* !OPENSSL_NO_ECDH */
 
     /* p points to the next byte, there are 'n' bytes left */
 
@@ -2022,21 +2384,64 @@ int ssl3_get_key_exchange(SSL *s)
         } else
 #endif
         {
-            if (EVP_VerifyInit_ex(&md_ctx, md, NULL) <= 0
-                    || EVP_VerifyUpdate(&md_ctx, &(s->s3->client_random[0]),
-                                        SSL3_RANDOM_SIZE) <= 0
-                    || EVP_VerifyUpdate(&md_ctx, &(s->s3->server_random[0]),
-                                        SSL3_RANDOM_SIZE) <= 0
-                    || EVP_VerifyUpdate(&md_ctx, param, param_len) <= 0) {
-                al = SSL_AD_INTERNAL_ERROR;
-                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EVP_LIB);
-                goto f_err;
-            }
-            if (EVP_VerifyFinal(&md_ctx, p, (int)n, pkey) <= 0) {
-                /* bad signature */
-                al = SSL_AD_DECRYPT_ERROR;
-                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
-                goto f_err;
+            if (md == EVP_md_null()) {
+                /* Intrinsic. Do the same work as below, except with raw signing
+                 * instead of having a message digest.
+                 */
+
+                /* Construct the input to the signature algorithm. */
+                unsigned char *in = OPENSSL_malloc(SSL3_RANDOM_SIZE + SSL3_RANDOM_SIZE + param_len);
+                if (in == NULL) {
+                    al = SSL_AD_INTERNAL_ERROR;
+                    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
+                       ERR_R_MALLOC_FAILURE);
+                    goto f_err;
+                }
+                unsigned char *inp = in;
+
+                memcpy(inp, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
+                inp += SSL3_RANDOM_SIZE;
+                memcpy(inp, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
+                inp += SSL3_RANDOM_SIZE;
+                memcpy(inp, param, param_len);
+                inp = NULL;
+
+                /* Execute the verification. */
+                ctx = EVP_PKEY_CTX_new(pkey, NULL);
+                if (ctx == NULL) {
+                    OPENSSL_free(in);
+                    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_LIB_EVP);
+                    al = SSL_AD_INTERNAL_ERROR;
+                    goto f_err;
+                }
+
+                if ((EVP_PKEY_verify_init(ctx) <= 0)
+                        || (EVP_PKEY_verify(ctx, p, (int)n,
+                                            in, SSL3_RANDOM_SIZE + SSL3_RANDOM_SIZE + param_len) <= 0)) {
+                    OPENSSL_free(in);
+                    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
+                    al = SSL_AD_INTERNAL_ERROR;
+                    goto f_err;
+                }
+
+                OPENSSL_free(in);
+            } else {
+                if (EVP_VerifyInit_ex(&md_ctx, md, NULL) <= 0
+                        || EVP_VerifyUpdate(&md_ctx, &(s->s3->client_random[0]),
+                                            SSL3_RANDOM_SIZE) <= 0
+                        || EVP_VerifyUpdate(&md_ctx, &(s->s3->server_random[0]),
+                                            SSL3_RANDOM_SIZE) <= 0
+                        || EVP_VerifyUpdate(&md_ctx, param, param_len) <= 0) {
+                    al = SSL_AD_INTERNAL_ERROR;
+                    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                    goto f_err;
+                }
+                if (EVP_VerifyFinal(&md_ctx, p, (int)n, pkey) <= 0) {
+                    /* bad signature */
+                    al = SSL_AD_DECRYPT_ERROR;
+                    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
+                    goto f_err;
+                }
             }
         }
     } else {
@@ -2056,6 +2461,7 @@ int ssl3_get_key_exchange(SSL *s)
     }
     EVP_PKEY_free(pkey);
     EVP_MD_CTX_cleanup(&md_ctx);
+    EVP_PKEY_CTX_free(ctx);
     return (1);
  f_err:
     ssl3_send_alert(s, SSL3_AL_FATAL, al);
@@ -2076,6 +2482,7 @@ int ssl3_get_key_exchange(SSL *s)
         EC_KEY_free(ecdh);
 #endif
     EVP_MD_CTX_cleanup(&md_ctx);
+    EVP_PKEY_CTX_free(ctx);
     s->state = SSL_ST_ERR;
     return (-1);
 }
@@ -2286,10 +2693,12 @@ int ssl3_get_new_session_ticket(SSL *s)
     unsigned char *d;
     unsigned long ticket_lifetime_hint;
 
+    /* Increase message size to 65280 (0xFF00), which is the maximum size of
+     * session ticket sent by the server, in order to accommodate peer QS (or MPKA) certificate. */
     n = s->method->ssl_get_message(s,
                                    SSL3_ST_CR_SESSION_TICKET_A,
                                    SSL3_ST_CR_SESSION_TICKET_B,
-                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);
+                                   SSL3_MT_NEWSESSION_TICKET, 65280, &ok);
 
     if (!ok)
         return ((int)n);
@@ -2519,6 +2928,19 @@ int ssl3_send_client_key_exchange(SSL *s)
     BN_CTX *bn_ctx = NULL;
 #endif
 
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    int qs_idx = 0;
+
+    EVP_PKEY_CTX *client_key_exch_pkey_ctx[QS_TLS_KEY_EXCH_ALGOS_NUM] = { NULL };
+    EVP_PKEY *client_key_exch_pkey[QS_TLS_KEY_EXCH_ALGOS_NUM] = { NULL };
+
+    unsigned char *iqre_premaster_secret = NULL;
+    size_t iqre_premaster_secret_size = 0;
+
+    unsigned char *cached_premaster_secret = NULL;
+    size_t cached_premaster_secret_size = 0;
+#endif
+
     if (s->state == SSL3_ST_CW_KEY_EXCH_A) {
         p = ssl_handshake_start(s);
 
@@ -2933,12 +3355,57 @@ int ssl3_send_client_key_exchange(SSL *s)
                 goto err;
             }
 
-            /* generate master key from the result */
-            s->session->master_key_length =
-                s->method->ssl3_enc->generate_master_secret(s,
-                                                            s->
-                                                            session->master_key,
-                                                            p, n);
+            /* Hybrid QS key exchange algorithms with ECDH for TLS key exchange */
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+            for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                    /* Add QS premaster secret */
+                    if (iqrssl_generate_client_pubkey_premaster_secret(s, QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx],
+                        &(client_key_exch_pkey_ctx[qs_idx]), &(client_key_exch_pkey[qs_idx]), &iqre_premaster_secret,
+                        &iqre_premaster_secret_size) < 0) {
+                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                        goto err;
+                    }
+
+                    /* Needs to advance p by n to account for other key exchange algo premaster secret. */
+                    memcpy(p + n, iqre_premaster_secret, iqre_premaster_secret_size);
+
+                    n += iqre_premaster_secret_size;
+
+                    /* Erase secret from memory */
+                    OPENSSL_cleanse(iqre_premaster_secret, iqre_premaster_secret_size);
+                    OPENSSL_free(iqre_premaster_secret);
+                    iqre_premaster_secret = NULL;
+                    iqre_premaster_secret_size = 0;
+                }
+            }
+#endif
+
+            if (iqrssl_is_qs_kem_key_exch(alg_k)) {
+                /*
+                 * For QS KEM based key exchange, master secret generation will
+                 * be performed towards the end of this function when the entire
+                 * ClientKeyExchange message becomes available.
+                 *
+                 * Here we save the premaster secret for later usage.
+                 */
+
+                cached_premaster_secret = OPENSSL_malloc(n);
+                if (cached_premaster_secret == NULL) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
+                    goto err;
+                }
+
+                cached_premaster_secret_size = n;
+                memcpy(cached_premaster_secret, p, cached_premaster_secret_size);
+            } else {
+                /* generate master key from the result */
+                s->session->master_key_length =
+                    s->method->ssl3_enc->generate_master_secret(s,
+                                                                s->
+                                                                session->master_key,
+                                                                p, n);
+            }
 
             memset(p, 0, n);    /* clean up */
 
@@ -2977,6 +3444,20 @@ int ssl3_send_client_key_exchange(SSL *s)
                 /* copy the point */
                 memcpy((unsigned char *)p, encodedPoint, n);
                 /* increment n to account for length field */
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+                for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                    if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                        /*
+                         * Advance pointer in order to append IQR DH public key or KEM ciphertext.
+                         * Note that p has already advanced by 1 to account for ECDH length.
+                         */
+                        p += n;
+                        break;
+                    }
+                }
+#endif
+
                 n += 1;
             }
 
@@ -3218,6 +3699,53 @@ int ssl3_send_client_key_exchange(SSL *s)
                 goto err;
             }
         }
+#endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        else if (iqrssl_is_qs_kem_key_exch(alg_k)) {
+            n = 0;
+
+            for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                    /* Add QS premaster secret */
+                    if (iqrssl_generate_client_pubkey_premaster_secret(s, QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx],
+                        &(client_key_exch_pkey_ctx[qs_idx]), &(client_key_exch_pkey[qs_idx]), &iqre_premaster_secret,
+                        &iqre_premaster_secret_size) < 0) {
+                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                        goto err;
+                    }
+
+                    /* Needs to advance p by n to account for other KEM algo premaster secret. */
+                    memcpy(p + n, iqre_premaster_secret, iqre_premaster_secret_size);
+
+                    n += iqre_premaster_secret_size;
+
+                    /* Erase secret from memory */
+                    OPENSSL_cleanse(iqre_premaster_secret, iqre_premaster_secret_size);
+                    OPENSSL_free(iqre_premaster_secret);
+                    iqre_premaster_secret = NULL;
+                    iqre_premaster_secret_size = 0;
+                }
+            }
+
+           /*
+            * For QS KEM based key exchange, master secret generation will
+            * be performed towards the end of this function when the entire
+            * ClientKeyExchange message becomes available.
+            *
+            * Here we save the premaster secret for later usage.
+            */
+           cached_premaster_secret = OPENSSL_malloc(n);
+           if (cached_premaster_secret == NULL) {
+               SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
+               goto err;
+           }
+
+           cached_premaster_secret_size = n;
+           memcpy(cached_premaster_secret, p, cached_premaster_secret_size);
+
+           memset(p, 0, n);    /* clean up */
+           n = 0;
+        }
 #endif
         else {
             ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
@@ -3225,8 +3753,72 @@ int ssl3_send_client_key_exchange(SSL *s)
             goto err;
         }
 
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+            unsigned char *client_key_exch_octet = NULL;
+            size_t client_key_exch_octet_size = 0;
+
+            if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                /* Send client QS key exchange pubkey / ciphertext to the server. */
+                if (EVP_PKEY_is_QS_dh(QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx])) {
+                    client_key_exch_octet_size = i2o_PublicKey(client_key_exch_pkey[qs_idx],
+                                                               &(client_key_exch_octet));
+                } else if (EVP_PKEY_is_QS_kem(QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx])){
+                    client_key_exch_octet_size = i2o_KemInfo(client_key_exch_pkey[qs_idx],
+                                                             &(client_key_exch_octet));
+                } else {
+                    /* Shouldn't be happening. */
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ASN1_LIB);
+                    goto err;
+                }
+
+                if (client_key_exch_octet_size == 0) {
+                    OPENSSL_free(client_key_exch_octet);
+
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ASN1_LIB);
+                    goto err;
+                }
+
+                /* 2 bytes for storing the length of client_key_exch_pubkey_octet. */
+                n += 2 + client_key_exch_octet_size;
+
+                s2n(client_key_exch_octet_size, p);
+
+                /* Add client key exchange public key to the message. */
+                memcpy(p, client_key_exch_octet, client_key_exch_octet_size);
+                p += client_key_exch_octet_size;
+
+                OPENSSL_free(s->session->sess_cert->peer_qs_pub_tmp[qs_idx]);
+                s->session->sess_cert->peer_qs_pub_tmp[qs_idx] = NULL;
+
+                OPENSSL_free(client_key_exch_octet);
+
+                EVP_PKEY_free(client_key_exch_pkey[qs_idx]);
+                client_key_exch_pkey[qs_idx] = NULL;
+
+                EVP_PKEY_CTX_free(client_key_exch_pkey_ctx[qs_idx]);
+                client_key_exch_pkey_ctx[qs_idx] = NULL;
+            }
+        }
+#endif
+
         ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, n);
         s->state = SSL3_ST_CW_KEY_EXCH_B;
+
+        if (iqrssl_is_qs_kem_key_exch(alg_k)) {
+            /* Generate hybrid master secret.
+             *
+             * "s->init_buf->data" contains the whole ClientKeyExchange message,
+             * which consists of 1 byte message_type (handshake type 16), followed
+             * by 3 bytes message_length, followed by message_length bytes of message_data.
+             */
+            s->session->master_key_length = iqrssl_generate_hybrid_master_secret(s, s->session->master_key,
+                cached_premaster_secret, cached_premaster_secret_size, (unsigned char *) s->init_buf->data, s->init_num);
+
+            OPENSSL_cleanse(cached_premaster_secret, cached_premaster_secret_size);
+            OPENSSL_free(cached_premaster_secret);
+            cached_premaster_secret = NULL;
+        }
     }
 
     /* SSL3_ST_CW_KEY_EXCH_B */
@@ -3239,6 +3831,22 @@ int ssl3_send_client_key_exchange(SSL *s)
     if (clnt_ecdh != NULL)
         EC_KEY_free(clnt_ecdh);
     EVP_PKEY_free(srvr_pub_pkey);
+#endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        EVP_PKEY_free(client_key_exch_pkey[qs_idx]);
+        EVP_PKEY_CTX_free(client_key_exch_pkey_ctx[qs_idx]);
+    }
+
+    if (iqre_premaster_secret != NULL) {
+        OPENSSL_cleanse(iqre_premaster_secret, iqre_premaster_secret_size);
+        OPENSSL_free(iqre_premaster_secret);
+    }
+
+    if (cached_premaster_secret != NULL) {
+        OPENSSL_cleanse(cached_premaster_secret, cached_premaster_secret_size);
+        OPENSSL_free(cached_premaster_secret);
+    }
 #endif
     s->state = SSL_ST_ERR;
     return (-1);
@@ -3250,6 +3858,7 @@ int ssl3_send_client_verify(SSL *s)
     unsigned char data[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];
     EVP_PKEY *pkey;
     EVP_PKEY_CTX *pctx = NULL;
+    EVP_PKEY_CTX *ctx = NULL;
     EVP_MD_CTX mctx;
     unsigned u = 0;
     unsigned long n;
@@ -3282,22 +3891,75 @@ int ssl3_send_client_verify(SSL *s)
         if (SSL_USE_SIGALGS(s)) {
             long hdatalen = 0;
             void *hdata;
-            const EVP_MD *md = s->cert->key->digest;
+            const EVP_MD *md = NULL;
+
+            if (s->cert->key->is_mpka_cert == 1 && s->cert->peer_mpkac_support == 1) {
+                /*
+                 * If client cert is an MPKAC, and the peer supports Catalyst,
+                 * then the signature shall be generated with the alternative private key.
+                 */
+
+                int i = 0;
+                EVP_PKEY *alt_pub_key =  SSL_get_alt_pubkey(s->cert->key->x509);
+                if (alt_pub_key == NULL) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+
+                i = ssl_cert_type(s->cert->key->x509, alt_pub_key);
+                if (i < 0 || s->cert->pkeys[i].privatekey == NULL) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
+                    EVP_PKEY_free(alt_pub_key);
+                    goto err;
+                }
+
+                pkey = s->cert->pkeys[i].privatekey;
+                md = s->cert->pkeys[i].digest;
+
+                EVP_PKEY_free(alt_pub_key);
+            } else {
+                md = s->cert->key->digest;
+            }
+
             hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
             if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md)) {
                 SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             p += 2;
+
+            if (md == EVP_md_null()) {
 #ifdef SSL_DEBUG
-            fprintf(stderr, "Using TLS 1.2 with client alg %s\n",
-                    EVP_MD_name(md));
+                fprintf(stderr, "Using TLS 1.2 with client-side raw signing\n");
 #endif
-            if (!EVP_SignInit_ex(&mctx, md, NULL)
-                || !EVP_SignUpdate(&mctx, hdata, hdatalen)
-                || !EVP_SignFinal(&mctx, p + 2, &u, pkey)) {
-                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_EVP_LIB);
-                goto err;
+                /* Execute the signature scheme */
+                ctx = EVP_PKEY_CTX_new(pkey, NULL);
+                if (ctx == NULL) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_EVP_LIB);
+                    goto err;
+                }
+
+                size_t tmp_size = 0;
+                if ((EVP_PKEY_sign_init(ctx) <= 0)
+                    || (EVP_PKEY_sign(ctx, NULL, &tmp_size,
+                                      NULL, 0) <= 0)
+                    || (EVP_PKEY_sign(ctx, p + 2, &tmp_size,
+                                      hdata, hdatalen) <= 0)) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_EVP_LIB);
+                    goto err;
+                }
+                u = tmp_size;
+            } else {
+#ifdef SSL_DEBUG
+                fprintf(stderr, "Using TLS 1.2 with client alg %s\n",
+                        EVP_MD_name(md));
+#endif
+                if (!EVP_SignInit_ex(&mctx, md, NULL)
+                    || !EVP_SignUpdate(&mctx, hdata, hdatalen)
+                    || !EVP_SignFinal(&mctx, p + 2, &u, pkey)) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_EVP_LIB);
+                    goto err;
+                }
             }
             s2n(u, p);
             n = u + 4;
@@ -3330,6 +3992,17 @@ int ssl3_send_client_verify(SSL *s)
             n = j + 2;
         } else
 #endif
+#ifndef OPENSSL_NO_DILITHIUM
+        if (pkey->type == EVP_PKEY_DILITHIUM) {
+            if (EVP_PKEY_sign(pctx, &(p[2]), (size_t *)&j, &(data[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH) <= 0) {
+                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_EVP_LIB);
+                goto err;
+            }
+
+            s2n(j, p);
+            n = j + 2;
+        } else
+#endif
 #ifndef OPENSSL_NO_ECDSA
         if (pkey->type == EVP_PKEY_EC) {
             if (!ECDSA_sign(pkey->save_type,
@@ -3368,10 +4041,12 @@ int ssl3_send_client_verify(SSL *s)
     }
     EVP_MD_CTX_cleanup(&mctx);
     EVP_PKEY_CTX_free(pctx);
+    EVP_PKEY_CTX_free(ctx);
     return ssl_do_write(s);
  err:
     EVP_MD_CTX_cleanup(&mctx);
     EVP_PKEY_CTX_free(pctx);
+    EVP_PKEY_CTX_free(ctx);
     s->state = SSL_ST_ERR;
     return (-1);
 }
@@ -3543,42 +4218,80 @@ int ssl3_check_cert_and_algorithm(SSL *s)
     /* This is the passed certificate */
 
     idx = sc->peer_cert_type;
-#ifndef OPENSSL_NO_ECDH
-    if (idx == SSL_PKEY_ECC) {
-        if (ssl_check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509, s) == 0) {
-            /* check failed */
-            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);
-            goto f_err;
-        } else {
-            return 1;
-        }
-    } else if (alg_a & SSL_aECDSA) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
-               SSL_R_MISSING_ECDSA_SIGNING_CERT);
-        goto f_err;
-    } else if (alg_k & (SSL_kECDHr | SSL_kECDHe)) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_ECDH_CERT);
-        goto f_err;
-    }
-#endif
+
     pkey = X509_get_pubkey(sc->peer_pkeys[idx].x509);
     pkey_bits = EVP_PKEY_bits(pkey);
     i = X509_certificate_type(sc->peer_pkeys[idx].x509, pkey);
     EVP_PKEY_free(pkey);
 
-    /* Check that we have a certificate if we require one */
-    if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA | EVP_PKT_SIGN)) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
-               SSL_R_MISSING_RSA_SIGNING_CERT);
-        goto f_err;
-    }
+    if (sc->peer_pkeys[idx].is_mpka_cert) {
+        EVP_PKEY *alt_pkey = SSL_get_alt_pubkey(sc->peer_pkeys[idx].x509);
+        if (alt_pkey == NULL) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_NO_PUBLICKEY);
+            goto f_err;
+        }
+
+#ifndef OPENSSL_NO_DILITHIUM
+        if (alg_a & SSL_aDILITHIUM) {
+            if (alt_pkey->type != EVP_PKEY_DILITHIUM) {
+                EVP_PKEY_free(alt_pkey);
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                       SSL_R_MISSING_DILITHIUM_SIGNING_CERT);
+                goto f_err;
+            }
+        } else
+#endif
+        {
+            EVP_PKEY_free(alt_pkey);
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_WRONG_SIGNATURE_TYPE);
+            goto f_err;
+        }
+
+        EVP_PKEY_free(alt_pkey);
+    } else {
+#ifndef OPENSSL_NO_ECDH
+        if (idx == SSL_PKEY_ECC) {
+            if (ssl_check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509, s) == 0) {
+                /* check failed */
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);
+                goto f_err;
+            } else {
+                return 1;
+            }
+        } else if (alg_a & SSL_aECDSA) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_MISSING_ECDSA_SIGNING_CERT);
+            goto f_err;
+        } else if (alg_k & (SSL_kECDHr | SSL_kECDHe)) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_ECDH_CERT);
+            goto f_err;
+        }
+#endif
+
+        /* Check that we have a certificate if we require one */
+        if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA | EVP_PKT_SIGN)) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_MISSING_RSA_SIGNING_CERT);
+            goto f_err;
+        }
 #ifndef OPENSSL_NO_DSA
-    else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA | EVP_PKT_SIGN)) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
-               SSL_R_MISSING_DSA_SIGNING_CERT);
-        goto f_err;
-    }
+        else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA | EVP_PKT_SIGN)) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_MISSING_DSA_SIGNING_CERT);
+            goto f_err;
+        }
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+        else if ((alg_a & SSL_aDILITHIUM) && !has_bits(i, EVP_PK_DILITHIUM | EVP_PKT_SIGN)) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_MISSING_DILITHIUM_SIGNING_CERT);
+            goto f_err;
+        }
 #endif
+    }
+
 #ifndef OPENSSL_NO_RSA
     if (alg_k & SSL_kRSA) {
         if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
diff --git a/openssl-1.0.2r/ssl/s3_lib.c b/openssl-1.0.2r/ssl/s3_lib.c
index 10c6db68..8e3ae97d 100644
--- a/openssl-1.0.2r/ssl/s3_lib.c
+++ b/openssl-1.0.2r/ssl/s3_lib.c
@@ -2886,8 +2886,430 @@ OPENSSL_GLOBAL SSL_CIPHER ssl3_ciphers[] = {
      256,
      },
 
+#ifndef OPENSSL_NO_NHDH
+    /* Cipher FF07 */
+    {
+     1,
+     TLS1_TXT_ECDHE_NHDH_RSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_NHDH_RSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID,
+     SSL_aRSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+
+    /* Cipher FF08 */
+    {
+     1,
+     TLS1_TXT_ECDHE_NHDH_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_NHDH_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_NHDH */
+
+#ifndef OPENSSL_NO_SIDH
+    /* Cipher FF10 */
+    {
+     1,
+     TLS1_TXT_ECDHE_SIDH_RSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_SIDH_RSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID,
+     SSL_aRSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+
+    /* Cipher FF11 */
+    {
+     1,
+     TLS1_TXT_ECDHE_SIDH_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_SIDH_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_SIDH */
+
+#if !((defined OPENSSL_NO_NHDH) || (defined OPENSSL_NO_SIDH))
+    /* Cipher FF12 */
+    {
+     1,
+     TLS1_TXT_ECDHE_NHDH_SIDH_RSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_NHDH_SIDH_RSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID,
+     SSL_aRSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+
+    /* Cipher FF13 */
+    {
+     1,
+     TLS1_TXT_ECDHE_NHDH_SIDH_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_NHDH_SIDH_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_NHDH && OPENSSL_NO_SIDH */
+
+#if !((defined OPENSSL_NO_NHDH) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF14 */
+    {
+     1,
+     TLS1_TXT_ECDHE_NHDH_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_NHDH_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_NHDH && OPENSSL_NO_DILITHIUM */
+
+#if !((defined OPENSSL_NO_SIDH) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF15 */
+    {
+     1,
+     TLS1_TXT_ECDHE_SIDH_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_SIDH_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_SIDH && OPENSSL_NO_DILITHIUM */
+
+#if !((defined OPENSSL_NO_NHDH) || (defined OPENSSL_NO_SIDH) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF16 */
+    {
+     1,
+     TLS1_TXT_ECDHE_NHDH_SIDH_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_NHDH_SIDH_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_NHDH && OPENSSL_NO_SIDH && OPENSSL_NO_DILITHIUM */
+
+#ifndef OPENSSL_NO_SIKE
+    /* Cipher FF17 */
+    {
+     1,
+     TLS1_TXT_ECDHE_SIKE_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_SIKE_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_SIKE */
+
+#ifndef OPENSSL_NO_KYBER
+    /* Cipher FF18 */
+    {
+     1,
+     TLS1_TXT_ECDHE_KYBER_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_KYBER_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_KYBER */
+
+#ifndef OPENSSL_NO_SIKE
+    /* Cipher FF19 */
+    {
+     1,
+     TLS1_TXT_ECDHE_SIKE_RSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_SIKE_RSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID,
+     SSL_aRSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_SIKE */
+
+#ifndef OPENSSL_NO_KYBER
+    /* Cipher FF1A */
+    {
+     1,
+     TLS1_TXT_ECDHE_KYBER_RSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_KYBER_RSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID,
+     SSL_aRSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_KYBER */
+
+#if !((defined OPENSSL_NO_SIKE) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF1B */
+    {
+     1,
+     TLS1_TXT_ECDHE_SIKE_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_SIKE_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_SIKE && OPENSSL_NO_DILITHIUM */
+
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF1C */
+    {
+     1,
+     TLS1_TXT_ECDHE_KYBER_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_KYBER_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_KYBER && OPENSSL_NO_DILITHIUM */
+
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_SIKE) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF1D */
+    {
+     1,
+     TLS1_TXT_ECDHE_KYBER_SIKE_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_KYBER_SIKE_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_KYBER && OPENSSL_NO_SIKE && OPENSSL_NO_DILITHIUM */
+
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_SIKE))
+    /* Cipher FF1E */
+    {
+     1,
+     TLS1_TXT_ECDHE_KYBER_SIKE_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_KYBER_SIKE_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_KYBER && OPENSSL_NO_SIKE */
+
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_SIKE))
+    /* Cipher FF1F */
+    {
+     1,
+     TLS1_TXT_ECDHE_KYBER_SIKE_RSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_ECDHE_KYBER_SIKE_RSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID,
+     SSL_aRSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_KYBER && OPENSSL_NO_SIKE */
+
 #endif                          /* OPENSSL_NO_ECDH */
 
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF20 */
+    {
+     1,
+     TLS1_TXT_KYBER_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_KYBER_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kEKYBER,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_KYBER && OPENSSL_NO_DILITHIUM */
+
+#ifndef OPENSSL_NO_KYBER
+    /* Cipher FF21 */
+    {
+     1,
+     TLS1_TXT_KYBER_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_KYBER_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kEKYBER,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+
+     /* Cipher FF22 */
+     {
+      1,
+      TLS1_TXT_KYBER_RSA_WITH_AES_256_GCM_SHA384,
+      TLS1_CK_KYBER_RSA_WITH_AES_256_GCM_SHA384,
+      SSL_kEKYBER,
+      SSL_aRSA,
+      SSL_AES256GCM,
+      SSL_AEAD,
+      SSL_TLSV1_2,
+      SSL_NOT_EXP | SSL_HIGH,
+      SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+      256,
+      256,
+      },
+#endif                          /* OPENSSL_NO_KYBER */
+
+#if !((defined OPENSSL_NO_SIKE) || (defined OPENSSL_NO_DILITHIUM))
+    /* Cipher FF23 */
+    {
+     1,
+     TLS1_TXT_SIKE_DILM_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_SIKE_DILM_WITH_AES_256_GCM_SHA384,
+     SSL_kESIKE,
+     SSL_aDILITHIUM,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+#endif                          /* OPENSSL_NO_SIKE && OPENSSL_NO_DILITHIUM */
+
+#ifndef OPENSSL_NO_SIKE
+    /* Cipher FF24 */
+    {
+     1,
+     TLS1_TXT_SIKE_ECDSA_WITH_AES_256_GCM_SHA384,
+     TLS1_CK_SIKE_ECDSA_WITH_AES_256_GCM_SHA384,
+     SSL_kESIKE,
+     SSL_aECDSA,
+     SSL_AES256GCM,
+     SSL_AEAD,
+     SSL_TLSV1_2,
+     SSL_NOT_EXP | SSL_HIGH,
+     SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+     256,
+     256,
+     },
+
+     /* Cipher FF25 */
+     {
+      1,
+      TLS1_TXT_SIKE_RSA_WITH_AES_256_GCM_SHA384,
+      TLS1_CK_SIKE_RSA_WITH_AES_256_GCM_SHA384,
+      SSL_kESIKE,
+      SSL_aRSA,
+      SSL_AES256GCM,
+      SSL_AEAD,
+      SSL_TLSV1_2,
+      SSL_NOT_EXP | SSL_HIGH,
+      SSL_HANDSHAKE_MAC_SHA384 | TLS1_PRF_SHA384,
+      256,
+      256,
+      },
+#endif                          /* OPENSSL_NO_SIKE */
+
 #ifdef TEMP_GOST_TLS
 /* Cipher FF00 */
     {
@@ -3037,6 +3459,7 @@ int ssl3_new(SSL *s)
 
 void ssl3_free(SSL *s)
 {
+    int i = 0;
     if (s == NULL || s->s3 == NULL)
         return;
 
@@ -3062,7 +3485,16 @@ void ssl3_free(SSL *s)
     if (s->s3->tmp.ecdh != NULL)
         EC_KEY_free(s->s3->tmp.ecdh);
 #endif
-
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (i = 0; i < QS_TLS_KEY_EXCH_ALGOS_NUM; i++) {
+        if (s->s3->tmp.server_qs_pkey[i] != NULL) {
+            EVP_PKEY_free(s->s3->tmp.server_qs_pkey[i]);
+        }
+        if (s->s3->tmp.server_qs_pkey_ctx[i] != NULL) {
+            EVP_PKEY_CTX_free(s->s3->tmp.server_qs_pkey_ctx[i]);
+        }
+    }
+#endif
     if (s->s3->tmp.ca_names != NULL)
         sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);
     if (s->s3->handshake_buffer) {
@@ -3088,6 +3520,7 @@ void ssl3_clear(SSL *s)
     unsigned char *rp, *wp;
     size_t rlen, wlen;
     int init_extra;
+    int i = 0;
 
 #ifdef TLSEXT_TYPE_opaque_prf_input
     if (s->s3->client_opaque_prf_input != NULL)
@@ -3118,6 +3551,18 @@ void ssl3_clear(SSL *s)
         s->s3->tmp.ecdh = NULL;
     }
 #endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (i = 0; i < QS_TLS_KEY_EXCH_ALGOS_NUM; i++) {
+        if (s->s3->tmp.server_qs_pkey[i] != NULL) {
+            EVP_PKEY_free(s->s3->tmp.server_qs_pkey[i]);
+            s->s3->tmp.server_qs_pkey[i] = NULL;
+        }
+        if (s->s3->tmp.server_qs_pkey_ctx[i] != NULL) {
+            EVP_PKEY_CTX_free(s->s3->tmp.server_qs_pkey_ctx[i]);
+            s->s3->tmp.server_qs_pkey_ctx[i] = NULL;
+        }
+    }
+#endif
 #ifndef OPENSSL_NO_TLSEXT
 # ifndef OPENSSL_NO_EC
     s->s3->is_probably_safari = 0;
@@ -3177,6 +3622,98 @@ static char *MS_CALLBACK srp_password_from_info_cb(SSL *s, void *arg)
 static int ssl3_set_req_cert_type(CERT *c, const unsigned char *p,
                                   size_t len);
 
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+#define QS_PARAM_NID_ARRAY_FORMAT   0
+#define QS_PARAM_STRING_FORMAT      1
+static int qs_set_keyexch_parameters(long algo_type, SSL_CTX *ctx, SSL *ssl, long larg, void *parg, int param_format)
+{
+    int qs_idx = 0;
+
+    if ((ctx == NULL && ssl == NULL) || (ctx != NULL && ssl != NULL) || parg == NULL) {
+        return 0;
+    }
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            if (ctx != NULL) {
+                if (param_format == QS_PARAM_NID_ARRAY_FORMAT) {
+                    return tls1_set_qs_keyexch_parameters(algo_type, &(ctx->qs_key_exch_parameters[qs_idx]),
+                                                      &(ctx->qs_key_exch_parameters_length[qs_idx]), parg, larg);
+                } else if ((param_format== QS_PARAM_STRING_FORMAT)) {
+                    return tls1_set_qs_keyexch_parameters_list(algo_type, &(ctx->qs_key_exch_parameters[qs_idx]),
+                                                      &(ctx->qs_key_exch_parameters_length[qs_idx]), parg);
+                } else {
+                    return 0;
+                }
+            } else if (ssl != NULL) {
+                if (param_format == QS_PARAM_NID_ARRAY_FORMAT) {
+                    return tls1_set_qs_keyexch_parameters(algo_type, &(ssl->qs_key_exch_parameters[qs_idx]),
+                                                      &(ssl->qs_key_exch_parameters_length[qs_idx]), parg, larg);
+                } else if ((param_format== QS_PARAM_STRING_FORMAT)) {
+                    return tls1_set_qs_keyexch_parameters_list(algo_type, &(ssl->qs_key_exch_parameters[qs_idx]),
+                                                      &(ssl->qs_key_exch_parameters_length[qs_idx]), parg);
+                } else {
+                    return 0;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int qs_param_codepoint2nid(long algo_type, unsigned int codepoint)
+{
+    int qs_idx = 0;
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            break;
+        }
+    }
+
+    if (qs_idx != QS_TLS_KEY_EXCH_ALGOS_NUM) {
+        int i = 0;
+        unsigned int tmp_codepoint = 0;
+
+        for (i = 0; i < SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num; i++) {
+            tmp_codepoint = (((unsigned int) SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[i * 2]) << 8) |
+                            (((unsigned int) SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[i * 2 + 1]));
+
+            if (tmp_codepoint == codepoint) {
+                return SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_nid[i];
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int qs_get_shared_keyexch_parameter(long algo_type, SSL *ssl)
+{
+    int qs_idx = 0;
+    const SSL_CIPHER *negotiated_ciphersuite = NULL;
+
+    if (ssl == NULL || ssl->session == NULL) {
+        return 0;
+    }
+
+    negotiated_ciphersuite = SSL_get_current_cipher(ssl);
+    if (!(negotiated_ciphersuite->algorithm_mkey & algo_type)) {
+        /* The negotiated ciphersuite does not contain this key exchange algorithm. */
+        return 0;
+    }
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            return qs_param_codepoint2nid(algo_type, ssl->session->shared_qs_key_exch_parameters[qs_idx]);
+        }
+    }
+
+    return 0;
+}
+#endif
+
 long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)
 {
     int ret = 0;
@@ -3508,6 +4045,45 @@ long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)
         return 1;
 # endif
 #endif
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    case SSL_CTRL_SET_NHDH_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kENHDH, NULL, s, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_SIDH_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kESIDH, NULL, s, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_KYBER_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kEKYBER, NULL, s, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_SIKE_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kESIKE, NULL, s, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_NHDH_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kENHDH, NULL, s, 0, parg, QS_PARAM_STRING_FORMAT);
+
+    case SSL_CTRL_SET_SIDH_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kESIDH, NULL, s, 0, parg, QS_PARAM_STRING_FORMAT);
+
+    case SSL_CTRL_SET_KYBER_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kEKYBER, NULL, s, 0, parg, QS_PARAM_STRING_FORMAT);
+
+    case SSL_CTRL_SET_SIKE_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kESIKE, NULL, s, 0, parg, QS_PARAM_STRING_FORMAT);
+
+    case SSL_CTRL_GET_SHARED_NHDH_PARAMETER:
+        return qs_get_shared_keyexch_parameter(SSL_kENHDH, s);
+
+    case SSL_CTRL_GET_SHARED_SIDH_PARAMETER:
+        return qs_get_shared_keyexch_parameter(SSL_kESIDH, s);
+
+    case SSL_CTRL_GET_SHARED_KYBER_PARAMETER:
+        return qs_get_shared_keyexch_parameter(SSL_kEKYBER, s);
+
+    case SSL_CTRL_GET_SHARED_SIKE_PARAMETER:
+        return qs_get_shared_keyexch_parameter(SSL_kESIKE, s);
+#endif
+
     case SSL_CTRL_SET_SIGALGS:
         return tls1_set_sigalgs(s->cert, parg, larg, 0);
 
@@ -3651,6 +4227,10 @@ long ssl3_callback_ctrl(SSL *s, int cmd, void (*fp) (void))
 {
     int ret = 0;
 
+    // TODO: ???
+
+
+
 #if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)
     if (
 # ifndef OPENSSL_NO_RSA
@@ -3897,6 +4477,33 @@ long ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)
         return 1;
 #  endif
 # endif
+
+# ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    case SSL_CTRL_SET_NHDH_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kENHDH, ctx, NULL, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_SIDH_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kESIDH, ctx, NULL, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_KYBER_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kEKYBER, ctx, NULL, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_SIKE_PARAMETERS:
+        return qs_set_keyexch_parameters(SSL_kESIKE, ctx, NULL, larg, parg, QS_PARAM_NID_ARRAY_FORMAT);
+
+    case SSL_CTRL_SET_NHDH_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kENHDH, ctx, NULL, 0, parg, QS_PARAM_STRING_FORMAT);
+
+    case SSL_CTRL_SET_SIDH_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kESIDH, ctx, NULL, 0, parg, QS_PARAM_STRING_FORMAT);
+
+    case SSL_CTRL_SET_KYBER_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kEKYBER, ctx, NULL, 0, parg, QS_PARAM_STRING_FORMAT);
+
+    case SSL_CTRL_SET_SIKE_PARAMETERS_LIST:
+        return qs_set_keyexch_parameters(SSL_kESIKE, ctx, NULL, 0, parg, QS_PARAM_STRING_FORMAT);
+# endif
+
     case SSL_CTRL_SET_SIGALGS:
         return tls1_set_sigalgs(ctx->cert, parg, larg, 0);
 
@@ -4213,6 +4820,25 @@ SSL_CIPHER *ssl3_choose_cipher(SSL *s, STACK_OF(SSL_CIPHER) *clnt,
             }
 #endif
             ret = sk_SSL_CIPHER_value(allow, ii);
+
+            /*
+             * Since key exchange algorithm is part of the ciphersuite
+             * negotiation, we made (QS) key exchange algorithm parameter
+             * negotiation a part of it too.
+             *
+             * For a key exchange algorithm that supports parameter
+             * negotiation, if a matching parameter was found, it's saved
+             * in the session object for use during key exchange operation.
+             *
+             * If a matching parameter was not found for a key exchange
+             * algorithm, then all ciphersuites that use this key exchange algo
+             * will not be considered.
+             */
+            if (!tls1_qs_keyexch_have_shared_param(s, ret)) {
+                ret = NULL;
+                continue;
+            }
+
             break;
         }
     }
@@ -4228,6 +4854,9 @@ int ssl3_get_req_cert_type(SSL *s, unsigned char *p)
 #ifndef OPENSSL_NO_ECDSA
     int have_ecdsa_sign = 0;
 #endif
+#ifndef OPENSSL_NO_DILITHIUM
+    int have_dilithium_sign = 0;
+#endif
 #if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_ECDH)
     int nostrict = 1;
 #endif
@@ -4256,6 +4885,12 @@ int ssl3_get_req_cert_type(SSL *s, unsigned char *p)
         case TLSEXT_signature_dsa:
             have_dsa_sign = 1;
             break;
+#ifndef OPENSSL_NO_DILITHIUM
+         case TLSEXT_signature_dilithium_III_SHAKE_r2:
+         case TLSEXT_signature_dilithium_IV_SHAKE_r2:
+            have_dilithium_sign = 1;
+            break;
+#endif
 #ifndef OPENSSL_NO_ECDSA
         case TLSEXT_signature_ecdsa:
             have_ecdsa_sign = 1;
@@ -4279,6 +4914,14 @@ int ssl3_get_req_cert_type(SSL *s, unsigned char *p)
     }
 #endif
 
+#ifndef OPENSSL_NO_DILITHIUM
+    if (s->version >= TLS1_2_VERSION) {
+        if (have_dilithium_sign) {
+            p[ret++] = TLS_CT_DILITHIUM_SIGN;
+        }
+    }
+#endif
+
 #ifndef OPENSSL_NO_DH
     if (alg_k & (SSL_kDHr | SSL_kEDH)) {
 # ifndef OPENSSL_NO_RSA
diff --git a/openssl-1.0.2r/ssl/s3_srvr.c b/openssl-1.0.2r/ssl/s3_srvr.c
index 70340181..05a4a8b2 100644
--- a/openssl-1.0.2r/ssl/s3_srvr.c
+++ b/openssl-1.0.2r/ssl/s3_srvr.c
@@ -164,11 +164,26 @@
 #ifndef OPENSSL_NO_DH
 # include <openssl/dh.h>
 #endif
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
 #include <openssl/bn.h>
 #ifndef OPENSSL_NO_KRB5
 # include <openssl/krb5_asn.h>
 #endif
 #include <openssl/md5.h>
+#ifndef OPENSSL_NO_NHDH
+#include <openssl/nhdh.h>
+#endif
+#ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+#endif
+#ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+#endif
+#ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+#endif
 
 #ifndef OPENSSL_NO_SSL3_METHOD
 static const SSL_METHOD *ssl3_get_server_method(int ver);
@@ -209,6 +224,278 @@ static int ssl_check_srp_ext_ClientHello(SSL *s, int *al)
 }
 #endif
 
+/*
+ * This creates a server public and private key pair for an IQR QS key exchange algorithm.
+ *
+ * The IQR QS key exchange algorithm can be either DH-based or KEM-based.
+ */
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+static int iqrssl_generate_server_pubkey(SSL *s, int algo_type, unsigned char **server_iqre_pubkey_octet,
+    int *server_iqre_pubkey_octet_size, int *n)
+{
+    EVP_PKEY_CTX *server_iqre_pkey_ctx = NULL;
+    EVP_PKEY *server_iqre_pkey = NULL;
+
+    unsigned char *server_iqre_pubkey_octet_tmp = NULL;
+    int server_iqre_pubkey_octet_size_tmp = 0;
+    int evp_pkey_ctrl_paramset = 0;
+
+    int qs_idx = 0;
+
+    if (algo_type == EVP_PKEY_NHDH) {
+        evp_pkey_ctrl_paramset = EVP_PKEY_CTRL_NHDH_ROLE_SET;
+    } else if (algo_type == EVP_PKEY_SIDH) {
+        evp_pkey_ctrl_paramset = EVP_PKEY_CTRL_SIDH_ROLE_SET;
+    } else if (EVP_PKEY_is_QS_kem(algo_type)) {
+        // no-op, as there is no role set for KEMs.
+    } else {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    /*
+     * Create server pkey context for IQR key agreement schemes.
+     * IQR engine needs to be loaded (e.g., in the app code space) before this step.
+     */
+    server_iqre_pkey_ctx = EVP_PKEY_CTX_new_id(algo_type, NULL);
+    if (server_iqre_pkey_ctx == NULL) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    /* Save the context for later for deriving the server shared secret. */
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx]) {
+            s->s3->tmp.server_qs_pkey_ctx[qs_idx] = server_iqre_pkey_ctx;
+        }
+    }
+
+    /*
+     * This currently is no-op for both DHs and KEMs, but the
+     * underlying EVP implementation could change in the future.
+     */
+    if (EVP_PKEY_keygen_init(server_iqre_pkey_ctx) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    /*
+     * Server is the initiator of the key exchange.
+     * This function call shall only be used for DHs.
+     */
+    int isInitiator = 1;
+    if (EVP_PKEY_is_QS_dh(algo_type)) {
+        if (EVP_PKEY_CTX_ctrl(server_iqre_pkey_ctx, algo_type, -1, evp_pkey_ctrl_paramset, 1, &isInitiator) <= 0) {
+            SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+            return -1;
+        }
+    }
+
+    /* Set the negotiated parameter for the key exchange algo. */
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx]) {
+            int parameter_set = tls1_qs_keyexch_get_parameter_set(s->session->shared_qs_key_exch_parameters[qs_idx]);
+            int i = 0;
+
+            for (i = 0; i < SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num; i++) {
+                if (parameter_set == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_internal[i]) {
+                    break;
+                }
+            }
+
+            if (i == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num) {
+                SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+                return -1;
+            }
+
+            if (EVP_PKEY_CTX_ctrl(server_iqre_pkey_ctx, algo_type, -1,
+                QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_PKEY_CTRL_CMD][qs_idx], 1, &parameter_set) <= 0) {
+                SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+                return -1;
+            }
+        }
+    }
+
+    /*
+     * Create server pkey struct.
+     *
+     * For KEMs, this is where the server key pair is created.
+     *
+     * For DHs, this creates the algo structure that holds the keys,
+     * but the keys themselves are not yet created.
+     */
+    if (EVP_PKEY_keygen(server_iqre_pkey_ctx, &server_iqre_pkey) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    /* Save the pkey for later for deriving the server shared secret. */
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx]) {
+            s->s3->tmp.server_qs_pkey[qs_idx] = server_iqre_pkey;
+        }
+    }
+
+    /*
+     * For DHs, this is the actual step that creates the server public and private keys.
+     *
+     * For KEMs, this function is a no-op on the server-side.
+     */
+    if (EVP_PKEY_derive_init(server_iqre_pkey_ctx) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    /* Get the raw public key octets. */
+    server_iqre_pubkey_octet_size_tmp = i2o_PublicKey(server_iqre_pkey, &server_iqre_pubkey_octet_tmp);
+    if (server_iqre_pubkey_octet_size_tmp == 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY, ERR_R_ASN1_LIB);
+        return -1;
+    }
+
+    /*
+     * 2 bytes for storing the parameter codepoint and 2 bytes for storing
+     * the length of server_pubkey_octet.
+     */
+    *n = *n + 4 + server_iqre_pubkey_octet_size_tmp;
+
+    *server_iqre_pubkey_octet = server_iqre_pubkey_octet_tmp;
+    *server_iqre_pubkey_octet_size = server_iqre_pubkey_octet_size_tmp;
+
+    return 1;
+}
+
+/*
+ * This creates the TLS premaster secret on the server-side.
+ */
+static int iqrssl_generate_server_premaster_secret(SSL *s, int algo_type, EVP_PKEY *client_iqre_pubpkey,
+    unsigned char **iqre_premaster_secret, size_t *iqre_premaster_secret_size)
+{
+    size_t iqre_premaster_secret_size_tmp = 0;
+    EVP_PKEY_CTX *server_iqre_pkey_ctx = NULL;
+    EVP_PKEY *server_iqre_pkey = NULL;
+
+    int qs_idx = 0;
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx]) {
+            server_iqre_pkey_ctx = s->s3->tmp.server_qs_pkey_ctx[qs_idx];
+            server_iqre_pkey = s->s3->tmp.server_qs_pkey[qs_idx];
+        }
+    }
+
+    if (server_iqre_pkey_ctx == NULL || server_iqre_pkey == NULL) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PREMASTER_SECRET, ERR_R_INTERNAL_ERROR);
+        return -1;
+    }
+
+    /* Give the client public key to the server for deriving the premaster secret. */
+    if (EVP_PKEY_derive_set_peer(server_iqre_pkey_ctx, client_iqre_pubpkey) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    /* Get the size of the premaster secret. */
+    if (EVP_PKEY_derive(server_iqre_pkey_ctx, NULL, &iqre_premaster_secret_size_tmp) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    *iqre_premaster_secret = OPENSSL_malloc(iqre_premaster_secret_size_tmp);
+    if (*iqre_premaster_secret == NULL) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PREMASTER_SECRET, ERR_R_MALLOC_FAILURE);
+        return -1;
+    }
+
+    /* Server generates the premaster secret. */
+    if (EVP_PKEY_derive(server_iqre_pkey_ctx, *iqre_premaster_secret, &iqre_premaster_secret_size_tmp) <= 0) {
+        SSLerr(SSL_F_IQRSSL_GENERATE_SERVER_PREMASTER_SECRET, ERR_R_EVP_LIB);
+        return -1;
+    }
+
+    *iqre_premaster_secret_size = iqre_premaster_secret_size_tmp;
+
+    EVP_PKEY_free(server_iqre_pkey);
+    EVP_PKEY_CTX_free(server_iqre_pkey_ctx);
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx]) {
+            s->s3->tmp.server_qs_pkey[qs_idx] = NULL;
+            s->s3->tmp.server_qs_pkey_ctx[qs_idx] = NULL;
+        }
+    }
+
+    return 1;
+}
+
+static int iqrssl_parse_client_key_exch_msg(long algo_type, unsigned char **message, long *message_size,
+    EVP_PKEY **client_key_exch_pkey, int *alert_type)
+{
+    int qs_idx = 0;
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            unsigned char *client_key_exchange_octet = NULL;
+            size_t client_key_exchange_octet_size = 0;
+
+            /* Parse client key exchange message. */
+            if ((*message_size) < 2) {
+                /* The message does not even contain the client key exchange size. */
+                *alert_type = SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG, SSL_R_BAD_LENGTH);
+                return -1;
+            }
+
+            /* Read the client key exchange size. */
+            n2s((*message), client_key_exchange_octet_size);
+            *message_size = (*message_size) - 2;
+
+            if ((*message_size) < client_key_exchange_octet_size) {
+                /* The message does not contain the whole client key exchange data. */
+                *alert_type = SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG, SSL_R_BAD_LENGTH);
+                return -1;
+            }
+
+            client_key_exchange_octet = OPENSSL_malloc(client_key_exchange_octet_size);
+            if (client_key_exchange_octet == NULL) {
+                SSLerr(SSL_F_IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG, ERR_R_MALLOC_FAILURE);
+                return -2;
+            }
+
+            /* Get the client key exchange data. */
+            memcpy(client_key_exchange_octet, (*message), client_key_exchange_octet_size);
+            *message = (*message) + client_key_exchange_octet_size;
+
+            if (EVP_PKEY_is_QS_dh(QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx])) {
+                client_key_exch_pkey[qs_idx] = o2i_PublicKey(QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx], NULL,
+                    (const unsigned char *)client_key_exchange_octet, client_key_exchange_octet_size);
+            } else if (EVP_PKEY_is_QS_kem(QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx])) {
+                client_key_exch_pkey[qs_idx] = o2i_KemInfo(QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx], NULL,
+                    (const unsigned char *)client_key_exchange_octet, client_key_exchange_octet_size);
+            } else {
+                /* Shouldn't be happening. */
+                OPENSSL_free(client_key_exchange_octet);
+
+                SSLerr(SSL_F_IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG, ERR_R_ASN1_LIB);
+                return -2;
+            }
+
+            if (client_key_exch_pkey[qs_idx] == NULL) {
+                OPENSSL_free(client_key_exchange_octet);
+
+                SSLerr(SSL_F_IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG, ERR_R_ASN1_LIB);
+                return -2;
+            }
+
+            OPENSSL_free(client_key_exchange_octet);
+        }
+    }
+
+    return 1;
+}
+#endif
+
 int ssl3_accept(SSL *s)
 {
     BUF_MEM *buf;
@@ -487,6 +774,10 @@ int ssl3_accept(SSL *s)
 #endif
                 || (alg_k & SSL_kEDH)
                 || (alg_k & SSL_kEECDH)
+                || (alg_k & SSL_kESIDH)
+                || (alg_k & SSL_kENHDH)
+                || (alg_k & SSL_kEKYBER)
+                || (alg_k & SSL_kESIKE)
                 || ((alg_k & SSL_kRSA)
                     && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
                         || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
@@ -1265,6 +1556,8 @@ int ssl3_get_client_hello(SSL *s)
         }
     }
 
+    tls1_qs_keyexch_find_shared_param(s);
+
     if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb) {
         SSL_CIPHER *pref_cipher = NULL;
 
@@ -1621,6 +1914,11 @@ int ssl3_send_server_key_exchange(SSL *s)
     int encodedlen = 0;
     int curve_id = 0;
     BN_CTX *bn_ctx = NULL;
+#endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    int qs_idx = 0;
+    unsigned char *server_key_exch_pubkey_octet[QS_TLS_KEY_EXCH_ALGOS_NUM] = { NULL };
+    int server_key_exch_pubkey_octet_size[QS_TLS_KEY_EXCH_ALGOS_NUM] = { 0 };
 #endif
     EVP_PKEY *pkey;
     const EVP_MD *md = NULL;
@@ -1633,6 +1931,7 @@ int ssl3_send_server_key_exchange(SSL *s)
     int nr[4], kn;
     BUF_MEM *buf;
     EVP_MD_CTX md_ctx;
+    EVP_PKEY_CTX *ctx = NULL;
 
     EVP_MD_CTX_init(&md_ctx);
     if (s->state == SSL3_ST_SW_KEY_EXCH_A) {
@@ -1832,6 +2131,19 @@ int ssl3_send_server_key_exchange(SSL *s)
             r[1] = NULL;
             r[2] = NULL;
             r[3] = NULL;
+
+            /* Hybrid QS key exchange algorithms with ECDH for TLS key exchange */
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+            for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                if (type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                    if (iqrssl_generate_server_pubkey(s, QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx],
+                        &(server_key_exch_pubkey_octet[qs_idx]), &(server_key_exch_pubkey_octet_size[qs_idx]), &n) < 0) {
+                        SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                        goto err;
+                    }
+                }
+            }
+#endif
         } else
 #endif                          /* !OPENSSL_NO_ECDH */
 #ifndef OPENSSL_NO_PSK
@@ -1856,6 +2168,19 @@ int ssl3_send_server_key_exchange(SSL *s)
             r[2] = s->srp_ctx.s;
             r[3] = s->srp_ctx.B;
         } else
+#endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        if (iqrssl_is_qs_kem_key_exch(type)) {
+            for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                if (type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                    if (iqrssl_generate_server_pubkey(s, QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx],
+                        &(server_key_exch_pubkey_octet[qs_idx]), &(server_key_exch_pubkey_octet_size[qs_idx]), &n) < 0) {
+                        SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                        goto err;
+                    }
+                }
+            }
+        } else
 #endif
         {
             al = SSL_AD_HANDSHAKE_FAILURE;
@@ -1957,6 +2282,30 @@ int ssl3_send_server_key_exchange(SSL *s)
         }
 #endif
 
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+            if (type & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                if (server_key_exch_pubkey_octet[qs_idx] == NULL) {
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                    goto err;
+                }
+
+                /* Add server key exchange parameter codepoint to the message. */
+                s2n(s->session->shared_qs_key_exch_parameters[qs_idx], p);
+
+                /* Add server key exchange public key size to the message. */
+                s2n(server_key_exch_pubkey_octet_size[qs_idx], p);
+
+                /* Add server key exchange public key to the message. */
+                memcpy(p, server_key_exch_pubkey_octet[qs_idx], server_key_exch_pubkey_octet_size[qs_idx]);
+                p += server_key_exch_pubkey_octet_size[qs_idx];
+
+                OPENSSL_free(server_key_exch_pubkey_octet[qs_idx]);
+                server_key_exch_pubkey_octet[qs_idx] = NULL;
+            }
+        }
+#endif
+
 #ifndef OPENSSL_NO_PSK
         if (type & SSL_kPSK) {
             size_t len = strlen(s->ctx->psk_identity_hint);
@@ -2021,10 +2370,58 @@ int ssl3_send_server_key_exchange(SSL *s)
                     }
                     p += 2;
                 }
+
+                if (md == EVP_md_null()) {
+                    /* Intrinsic. Do the same work as below except with raw signing
+                     * instead of having a message digest.
+                     */
 #ifdef SSL_DEBUG
-                fprintf(stderr, "Using hash %s\n", EVP_MD_name(md));
+                    fprintf(stderr, "Using raw signing\n");
 #endif
-                if (EVP_SignInit_ex(&md_ctx, md, NULL) <= 0
+                    /* Construct the input to the signature algorithm. */
+                    unsigned char *in = OPENSSL_malloc(SSL3_RANDOM_SIZE + SSL3_RANDOM_SIZE + n);
+                    if (in == NULL) {
+                        al = SSL_AD_INTERNAL_ERROR;
+                        SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                           ERR_R_MALLOC_FAILURE);
+                        goto f_err;
+                    }
+                    unsigned char *inp = in;
+
+                    memcpy(inp, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
+                    inp += SSL3_RANDOM_SIZE;
+                    memcpy(inp, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
+                    inp += SSL3_RANDOM_SIZE;
+                    memcpy(inp, d, n);
+                    inp = NULL;
+
+                    /* Execute the signature scheme. */
+                    ctx = EVP_PKEY_CTX_new(pkey, NULL);
+                    if (ctx == NULL) {
+                        OPENSSL_free(in);
+                        SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_EVP);
+                        al = SSL_AD_INTERNAL_ERROR;
+                        goto f_err;
+                    }
+
+                    size_t tmp_size = 0;
+                    if ((EVP_PKEY_sign_init(ctx) <= 0)
+                        || (EVP_PKEY_sign(ctx, NULL, &tmp_size,
+                                          NULL, 0) <= 0)
+                        || (EVP_PKEY_sign(ctx, &(p[2]), &tmp_size,
+                                          in, SSL3_RANDOM_SIZE + SSL3_RANDOM_SIZE + n) <= 0)) {
+                        OPENSSL_free(in);
+                        al = SSL_AD_INTERNAL_ERROR;
+                        SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_EVP);
+                        goto f_err;
+                    }
+                    OPENSSL_free(in);
+                    i = tmp_size;
+                } else {
+#ifdef SSL_DEBUG
+                    fprintf(stderr, "Using hash %s\n", EVP_MD_name(md));
+#endif
+                    if (EVP_SignInit_ex(&md_ctx, md, NULL) <= 0
                         || EVP_SignUpdate(&md_ctx, &(s->s3->client_random[0]),
                                           SSL3_RANDOM_SIZE) <= 0
                         || EVP_SignUpdate(&md_ctx, &(s->s3->server_random[0]),
@@ -2032,9 +2429,10 @@ int ssl3_send_server_key_exchange(SSL *s)
                         || EVP_SignUpdate(&md_ctx, d, n) <= 0
                         || EVP_SignFinal(&md_ctx, &(p[2]),
                                          (unsigned int *)&i, pkey) <= 0) {
-                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_EVP);
-                    al = SSL_AD_INTERNAL_ERROR;
-                    goto f_err;
+                        SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_EVP);
+                        al = SSL_AD_INTERNAL_ERROR;
+                        goto f_err;
+                    }
                 }
                 s2n(i, p);
                 n += i + 2;
@@ -2054,6 +2452,7 @@ int ssl3_send_server_key_exchange(SSL *s)
 
     s->state = SSL3_ST_SW_KEY_EXCH_B;
     EVP_MD_CTX_cleanup(&md_ctx);
+    EVP_PKEY_CTX_free(ctx);
     return ssl_do_write(s);
  f_err:
     ssl3_send_alert(s, SSL3_AL_FATAL, al);
@@ -2063,7 +2462,15 @@ int ssl3_send_server_key_exchange(SSL *s)
         OPENSSL_free(encodedPoint);
     BN_CTX_free(bn_ctx);
 #endif
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        OPENSSL_free(server_key_exch_pubkey_octet[qs_idx]);
+    }
+#endif
+
     EVP_MD_CTX_cleanup(&md_ctx);
+    EVP_PKEY_CTX_free(ctx);
     s->state = SSL_ST_ERR;
     return (-1);
 }
@@ -2202,10 +2609,28 @@ int ssl3_get_client_key_exchange(SSL *s)
     BN_CTX *bn_ctx = NULL;
 #endif
 
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    EVP_PKEY *client_key_exch_pkey[QS_TLS_KEY_EXCH_ALGOS_NUM] = { NULL };
+
+    unsigned char *iqre_premaster_secret = NULL;
+    size_t iqre_premaster_secret_size = 0;
+
+    unsigned char *cached_client_key_exchange_msg = NULL;
+    size_t cached_client_key_exchange_msg_size = 0;
+
+    int qs_idx = 0;
+    int qs_ret = 0;
+#endif
+
+    /*
+     * Increase the message size to 8192 bytes in order to accommodate
+     * quantum-safe key exchange algorithms. It also enables support for
+     * RSA key size 16384-bit as well.
+     */
     n = s->method->ssl_get_message(s,
                                    SSL3_ST_SR_KEY_EXCH_A,
                                    SSL3_ST_SR_KEY_EXCH_B,
-                                   SSL3_MT_CLIENT_KEY_EXCHANGE, 2048, &ok);
+                                   SSL3_MT_CLIENT_KEY_EXCHANGE, 8192, &ok);
 
     if (!ok)
         return ((int)n);
@@ -2213,6 +2638,27 @@ int ssl3_get_client_key_exchange(SSL *s)
 
     alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
+    if (iqrssl_is_qs_kem_key_exch(alg_k)) {
+        /*
+         * For QS KEM based key exchange, we need to save the entire
+         * ClientKeyExchange message before the containing buffer becomes
+         * invalid. This is later used for generating hybrid master secret.
+         *
+         * "s->init_buf->data" contains the whole ClientKeyExchange message,
+         * which consists of 1 byte message_type (handshake type 16), followed
+         * by 3 bytes message_length, followed by message_length bytes of message_data.
+         */
+
+        cached_client_key_exchange_msg = OPENSSL_malloc(n + SSL3_HM_HEADER_LENGTH);
+        if (cached_client_key_exchange_msg == NULL) {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+
+        cached_client_key_exchange_msg_size = n + SSL3_HM_HEADER_LENGTH;
+        memcpy(cached_client_key_exchange_msg, s->init_buf->data, cached_client_key_exchange_msg_size);
+    }
+
 #ifndef OPENSSL_NO_RSA
     if (alg_k & SSL_kRSA) {
         unsigned char rand_premaster_secret[SSL_MAX_MASTER_KEY_LENGTH];
@@ -2750,22 +3196,56 @@ int ssl3_get_client_key_exchange(SSL *s)
             /* Get encoded point length */
             i = *p;
             p += 1;
-            if (n != 1 + i) {
-                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_LENGTH_MISMATCH);
-                al = SSL_AD_DECODE_ERROR;
-                goto f_err;
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+            for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                    if (n < 1 + i) {
+                        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
+                        goto err;
+                    }
+                    break;
+                }
+            }
+
+            if (qs_idx == QS_TLS_KEY_EXCH_ALGOS_NUM) {
+#endif
+                if (n != 1 + i) {
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
+                    goto err;
+                }
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
             }
+#endif
             if (EC_POINT_oct2point(group, clnt_ecpoint, p, i, bn_ctx) == 0) {
                 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
-                al = SSL_AD_HANDSHAKE_FAILURE;
-                goto f_err;
+                goto err;
             }
-            /*
-             * p is pointing to somewhere in the buffer currently, so set it
-             * to the start
-             */
-            p = (unsigned char *)s->init_buf->data;
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+            for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                    p += i;
+                    n = n - (1 + i);
+                    break;
+                }
+            }
+#endif
+        }
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        qs_ret = iqrssl_parse_client_key_exch_msg(alg_k, &p, &n, client_key_exch_pkey, &al);
+        if (qs_ret == -1) {
+            goto f_err;
+        } else if (qs_ret == -2) {
+            goto err;
         }
+#endif
+
+        /*
+         * p is pointing to somewhere in the buffer currently, so set it
+         * to the start
+         */
+        p = (unsigned char *)s->init_buf->data;
 
         /* Compute the shared pre-master secret */
         field_size = EC_GROUP_get_degree(group);
@@ -2787,12 +3267,54 @@ int ssl3_get_client_key_exchange(SSL *s)
         EC_KEY_free(s->s3->tmp.ecdh);
         s->s3->tmp.ecdh = NULL;
 
-        /* Compute the master secret */
-        s->session->master_key_length =
-            s->method->ssl3_enc->generate_master_secret(s,
-                                                        s->
-                                                        session->master_key,
-                                                        p, i);
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+            if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                /* Generate QS premaster secret. */
+                if (iqrssl_generate_server_premaster_secret(s, QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx],
+                    client_key_exch_pkey[qs_idx],
+                    &iqre_premaster_secret, &iqre_premaster_secret_size) < 0) {
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                    goto err;
+                }
+
+                EVP_PKEY_free(client_key_exch_pkey[qs_idx]);
+                client_key_exch_pkey[qs_idx] = NULL;
+
+                if (i + iqre_premaster_secret_size > s->init_buf->max) {
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+
+                memcpy(p + i, iqre_premaster_secret, iqre_premaster_secret_size);
+                i += iqre_premaster_secret_size;
+
+                /* Erase secret from memory */
+                OPENSSL_cleanse(iqre_premaster_secret, iqre_premaster_secret_size);
+                OPENSSL_free(iqre_premaster_secret);
+                iqre_premaster_secret = NULL;
+                iqre_premaster_secret_size = 0;
+            }
+        }
+#endif
+
+        if (iqrssl_is_qs_kem_key_exch(alg_k)) {
+            /* Generate hybrid master secret */
+
+            s->session->master_key_length = iqrssl_generate_hybrid_master_secret(s, s->session->master_key, p, i,
+                cached_client_key_exchange_msg, cached_client_key_exchange_msg_size);
+
+            OPENSSL_free(cached_client_key_exchange_msg);
+            cached_client_key_exchange_msg = NULL;
+        } else {
+            /* Compute the master secret */
+
+            s->session->master_key_length =
+                s->method->ssl3_enc->generate_master_secret(s,
+                                                            s->
+                                                            session->master_key,
+                                                            p, i);
+        }
 
         OPENSSL_cleanse(p, i);
         return (ret);
@@ -2927,6 +3449,56 @@ int ssl3_get_client_key_exchange(SSL *s)
         p += i;
     } else
 #endif                          /* OPENSSL_NO_SRP */
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    if (iqrssl_is_qs_kem_key_exch(alg_k)) {
+        qs_ret = iqrssl_parse_client_key_exch_msg(alg_k, &p, &n, client_key_exch_pkey, &al);
+        if (qs_ret == -1) {
+            goto f_err;
+        } else if (qs_ret == -2) {
+            goto err;
+        }
+
+        p = (unsigned char *)s->init_buf->data;
+        i = 0;
+
+        for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+            if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                /* Generate QS premaster secret. */
+                if (iqrssl_generate_server_premaster_secret(s, QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_EVP_NAME][qs_idx],
+                    client_key_exch_pkey[qs_idx], &iqre_premaster_secret, &iqre_premaster_secret_size) < 0) {
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB);
+                    goto err;
+                }
+
+                EVP_PKEY_free(client_key_exch_pkey[qs_idx]);
+                client_key_exch_pkey[qs_idx] = NULL;
+
+                if (i + iqre_premaster_secret_size > s->init_buf->max) {
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+
+                memcpy(p + i, iqre_premaster_secret, iqre_premaster_secret_size);
+                i += iqre_premaster_secret_size;
+
+                /* Erase secret from memory */
+                OPENSSL_cleanse(iqre_premaster_secret, iqre_premaster_secret_size);
+                OPENSSL_free(iqre_premaster_secret);
+                iqre_premaster_secret = NULL;
+                iqre_premaster_secret_size = 0;
+            }
+        }
+
+        /* Generate hybrid master secret */
+        s->session->master_key_length = iqrssl_generate_hybrid_master_secret(s, s->session->master_key, p, i,
+            cached_client_key_exchange_msg, cached_client_key_exchange_msg_size);
+
+        OPENSSL_free(cached_client_key_exchange_msg);
+        cached_client_key_exchange_msg = NULL;
+
+        OPENSSL_cleanse(p, i);
+    } else
+#endif                          /* OPENSSL_NO_QS_KEY_EXCHANGE */
     if (alg_k & SSL_kGOST) {
         int ret = 0;
         EVP_PKEY_CTX *pkey_ctx;
@@ -3020,6 +3592,18 @@ int ssl3_get_client_key_exchange(SSL *s)
     if (srvr_ecdh != NULL)
         EC_KEY_free(srvr_ecdh);
     BN_CTX_free(bn_ctx);
+#endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        EVP_PKEY_free(client_key_exch_pkey[qs_idx]);
+    }
+
+    if (iqre_premaster_secret != NULL) {
+        OPENSSL_cleanse(iqre_premaster_secret, iqre_premaster_secret_size);
+        OPENSSL_free(iqre_premaster_secret);
+    }
+
+    OPENSSL_free(cached_client_key_exchange_msg);
 #endif
     s->state = SSL_ST_ERR;
     return (-1);
@@ -3033,7 +3617,9 @@ int ssl3_get_cert_verify(SSL *s)
     long n;
     int type = 0, i, j;
     X509 *peer;
+    int alt_pub_key_idx = -1;
     const EVP_MD *md = NULL;
+    EVP_PKEY_CTX *ctx = NULL;
     EVP_MD_CTX mctx;
     EVP_MD_CTX_init(&mctx);
 
@@ -3060,10 +3646,33 @@ int ssl3_get_cert_verify(SSL *s)
         return ((int)n);
 
     peer = s->session->peer;
-    pkey = X509_get_pubkey(peer);
-    if (pkey == NULL) {
-        al = SSL_AD_INTERNAL_ERROR;
-        goto f_err;
+
+
+    /* Test if the client cert is an MPKAC. */
+    alt_pub_key_idx = X509_get_ext_by_NID(peer, NID_subjectAltPublicKeyInfo, -1);
+
+    if (alt_pub_key_idx < 0) {
+        /* Client cert is not an MPKAC. */
+        pkey = X509_get_pubkey(peer);
+        if (pkey == NULL) {
+            al = SSL_AD_INTERNAL_ERROR;
+            goto f_err;
+        }
+    } else {
+        /* Client cert is an MPKAC. */
+
+        /* Get the alternative key instead.
+         *
+         * At this point, the server knows that the client signed the cert-verify with the
+         * alternative private key, because this server is one that supports Catalyst (otherwise,
+         * this code would not be here), and has communicated this fact to the client via
+         * cert-request.
+         */
+        pkey = SSL_get_alt_pubkey(peer);
+        if (pkey == NULL) {
+            al = SSL_AD_INTERNAL_ERROR;
+            goto f_err;
+        }
     }
 
     type = X509_certificate_type(peer, pkey);
@@ -3125,21 +3734,43 @@ int ssl3_get_cert_verify(SSL *s)
             al = SSL_AD_INTERNAL_ERROR;
             goto f_err;
         }
+
+        if (md == EVP_md_null()) {
 #ifdef SSL_DEBUG
-        fprintf(stderr, "Using TLS 1.2 with client verify alg %s\n",
-                EVP_MD_name(md));
+             fprintf(stderr, "Using TLS 1.2 with client verify alg raw\n");
 #endif
-        if (!EVP_VerifyInit_ex(&mctx, md, NULL)
-            || !EVP_VerifyUpdate(&mctx, hdata, hdatalen)) {
-            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
-            al = SSL_AD_INTERNAL_ERROR;
-            goto f_err;
-        }
+             /* Execute the verification. */
+             ctx = EVP_PKEY_CTX_new(pkey, NULL);
+             if (ctx == NULL) {
+                 SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_LIB_EVP);
+                 al = SSL_AD_INTERNAL_ERROR;
+                 goto f_err;
+             }
+
+            if ((EVP_PKEY_verify_init(ctx) <= 0)
+                || (EVP_PKEY_verify(ctx, p, (int)i,
+                                    hdata, hdatalen) <= 0)) {
+                SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_SIGNATURE);
+                al = SSL_AD_INTERNAL_ERROR;
+                goto f_err;
+            }
+        } else {
+#ifdef SSL_DEBUG
+            fprintf(stderr, "Using TLS 1.2 with client verify alg %s\n",
+                    EVP_MD_name(md));
+#endif
+            if (!EVP_VerifyInit_ex(&mctx, md, NULL)
+                || !EVP_VerifyUpdate(&mctx, hdata, hdatalen)) {
+                SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
+                al = SSL_AD_INTERNAL_ERROR;
+                goto f_err;
+            }
 
-        if (EVP_VerifyFinal(&mctx, p, i, pkey) <= 0) {
-            al = SSL_AD_DECRYPT_ERROR;
-            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_SIGNATURE);
-            goto f_err;
+            if (EVP_VerifyFinal(&mctx, p, i, pkey) <= 0) {
+                al = SSL_AD_DECRYPT_ERROR;
+                SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_SIGNATURE);
+                goto f_err;
+            }
         }
     } else
 #ifndef OPENSSL_NO_RSA
@@ -3172,6 +3803,33 @@ int ssl3_get_cert_verify(SSL *s)
         }
     } else
 #endif
+#ifndef OPENSSL_NO_DILITHIUM
+    if (pkey->type == EVP_PKEY_DILITHIUM) {
+        EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey, NULL);
+        if (pctx == NULL) {
+            al = SSL_AD_INTERNAL_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_MALLOC_FAILURE);
+            goto f_err;
+        }
+
+        if (EVP_PKEY_verify_init(pctx) <= 0) {
+            EVP_PKEY_CTX_free(pctx);
+            al = SSL_AD_INTERNAL_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
+            goto f_err;
+        }
+
+        j = EVP_PKEY_verify(pctx, p, i, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH);
+
+        EVP_PKEY_CTX_free(pctx);
+
+        if (j <= 0) {
+            al = SSL_AD_DECRYPT_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_DILITHIUM_SIGNATURE);
+            goto f_err;
+        }
+    } else
+#endif
 #ifndef OPENSSL_NO_ECDSA
     if (pkey->type == EVP_PKEY_EC) {
         j = ECDSA_verify(pkey->save_type,
@@ -3237,6 +3895,7 @@ int ssl3_get_cert_verify(SSL *s)
     }
     EVP_MD_CTX_cleanup(&mctx);
     EVP_PKEY_free(pkey);
+    EVP_PKEY_CTX_free(ctx);
     return (ret);
 }
 
diff --git a/openssl-1.0.2r/ssl/ssl.h b/openssl-1.0.2r/ssl/ssl.h
index 4bc1f4e6..a93e32a9 100644
--- a/openssl-1.0.2r/ssl/ssl.h
+++ b/openssl-1.0.2r/ssl/ssl.h
@@ -223,6 +223,9 @@ extern "C" {
 # define SSL_MAX_KEY_ARG_LENGTH                  8
 # define SSL_MAX_MASTER_KEY_LENGTH               48
 
+# define QS_TLS_KEY_EXCH_ALGOS_NUM                4
+# define QS_TLS_MAX_KEY_EXCH_PARAM_NUM            32
+
 /* These are used to specify which ciphers to use and not to use */
 
 # define SSL_TXT_EXP40           "EXPORT40"
@@ -256,6 +259,18 @@ extern "C" {
 # define SSL_TXT_kPSK            "kPSK"
 # define SSL_TXT_kGOST           "kGOST"
 # define SSL_TXT_kSRP            "kSRP"
+# define SSL_TXT_kENHDH             "kENHDH"
+# define SSL_TXT_kECDHE_NHDH        "kECDHE-NHDH"
+# define SSL_TXT_kESIDH             "kESIDH"
+# define SSL_TXT_kECDHE_SIDH        "kECDHE-SIDH"
+# define SSL_TXT_kECDHE_NHDH_SIDH   "kECDHE-NHDH-SIDH"
+# define SSL_TXT_kEKYBER            "kEKYBER"
+# define SSL_TXT_kECDHE_KYBER       "kECDHE-KYBER"
+# define SSL_TXT_kESIKE             "kESIKE"
+# define SSL_TXT_kECDHE_SIKE        "kECDHE-SIKE"
+# define SSL_TXT_kECDHE_KYBER_SIKE  "kECDHE-KYBER-SIKE"
+# define SSL_TXT_kKYBER             "kKYBER"
+# define SSL_TXT_kSIKE              "kSIKE"
 
 # define SSL_TXT_aRSA            "aRSA"
 # define SSL_TXT_aDSS            "aDSS"
@@ -280,9 +295,22 @@ extern "C" {
 # define SSL_TXT_ECDHE           "ECDHE"/* alias for ECDHE" */
 # define SSL_TXT_AECDH           "AECDH"
 # define SSL_TXT_ECDSA           "ECDSA"
+# define SSL_TXT_DILITHIUM       "DILITHIUM"
 # define SSL_TXT_KRB5            "KRB5"
 # define SSL_TXT_PSK             "PSK"
 # define SSL_TXT_SRP             "SRP"
+# define SSL_TXT_ECDHE_NHDH         "ECDHE-NHDH"
+# define SSL_TXT_ECDHE_SIDH         "ECDHE-SIDH"
+# define SSL_TXT_ECDHE_NHDH_SIDH    "ECDHE-NHDH-SIDH"
+# define SSL_TXT_ECDHE_KYBER        "ECDHE-KYBER"
+# define SSL_TXT_ECDHE_SIKE         "ECDHE-SIKE"
+# define SSL_TXT_ECDHE_KYBER_SIKE   "ECDHE-KYBER-SIKE"
+# define SSL_TXT_KYBER              "KYBER"
+# define SSL_TXT_SIKE               "SIKE"
+
+#if ((defined OPENSSL_NO_NHDH) && (defined OPENSSL_NO_SIDH) && (defined OPENSSL_NO_KYBER) && (defined OPENSSL_NO_SIKE))
+#define OPENSSL_NO_QS_KEY_EXCHANGE
+#endif
 
 # define SSL_TXT_DES             "DES"
 # define SSL_TXT_3DES            "3DES"
@@ -571,6 +599,10 @@ struct ssl_session_st {
 #  ifndef OPENSSL_NO_SRP
     char *srp_username;
 #  endif
+#  ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    /* QS key exchange parameter shared between the client and the server. */
+    unsigned int shared_qs_key_exch_parameters[QS_TLS_KEY_EXCH_ALGOS_NUM];
+#  endif
 };
 
 # endif
@@ -1180,6 +1212,11 @@ struct ssl_ctx_st {
     size_t tlsext_ellipticcurvelist_length;
     unsigned char *tlsext_ellipticcurvelist;
 #   endif                       /* OPENSSL_NO_EC */
+
+#   ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    size_t qs_key_exch_parameters_length[QS_TLS_KEY_EXCH_ALGOS_NUM];
+    unsigned char *qs_key_exch_parameters[QS_TLS_KEY_EXCH_ALGOS_NUM];
+#   endif                       /* OPENSSL_NO_QS_KEY_EXCHANGE */
 #  endif
 };
 
@@ -1622,6 +1659,15 @@ struct ssl_st {
     /* our list */
     unsigned char *tlsext_ellipticcurvelist;
 #   endif                       /* OPENSSL_NO_EC */
+
+#   ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    size_t qs_key_exch_parameters_length[QS_TLS_KEY_EXCH_ALGOS_NUM];
+    unsigned char *qs_key_exch_parameters[QS_TLS_KEY_EXCH_ALGOS_NUM];
+
+    /* Array containing the combination of ECC curves and QS key exchange algorithm parameters. */
+    unsigned char *curves_and_qs_params;
+    size_t curves_and_qs_params_size;
+#   endif                       /* OPENSSL_NO_QS_KEY_EXCHANGE */
     /*
      * draft-rescorla-tls-opaque-prf-input-00.txt information to be used for
      * handshakes
@@ -1978,6 +2024,18 @@ DECLARE_PEM_rw(SSL_SESSION, SSL_SESSION)
 # define SSL_CTRL_CHECK_PROTO_VERSION            119
 # define DTLS_CTRL_SET_LINK_MTU                  120
 # define DTLS_CTRL_GET_LINK_MIN_MTU              121
+# define SSL_CTRL_SET_NHDH_PARAMETERS            200
+# define SSL_CTRL_SET_NHDH_PARAMETERS_LIST       201
+# define SSL_CTRL_SET_SIDH_PARAMETERS            202
+# define SSL_CTRL_SET_SIDH_PARAMETERS_LIST       203
+# define SSL_CTRL_SET_KYBER_PARAMETERS           204
+# define SSL_CTRL_SET_KYBER_PARAMETERS_LIST      205
+# define SSL_CTRL_SET_SIKE_PARAMETERS            206
+# define SSL_CTRL_SET_SIKE_PARAMETERS_LIST       207
+# define SSL_CTRL_GET_SHARED_NHDH_PARAMETER      208
+# define SSL_CTRL_GET_SHARED_SIDH_PARAMETER      209
+# define SSL_CTRL_GET_SHARED_KYBER_PARAMETER     210
+# define SSL_CTRL_GET_SHARED_SIKE_PARAMETER      211
 # define SSL_CERT_SET_FIRST                      1
 # define SSL_CERT_SET_NEXT                       2
 # define SSL_CERT_SET_SERVER                     3
@@ -2087,6 +2145,119 @@ DECLARE_PEM_rw(SSL_SESSION, SSL_SESSION)
         SSL_CTX_ctrl(ctx,SSL_CTRL_SET_ECDH_AUTO,onoff,NULL)
 # define SSL_set_ecdh_auto(s, onoff) \
         SSL_ctrl(s,SSL_CTRL_SET_ECDH_AUTO,onoff,NULL)
+
+# ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+/** Set the list of allowed parameters for TLS QS key exchange algorithms.
+ *
+ * These functions can be used on both the client side and the server
+ * side. By default, all supported parameters are set for each QS key exchange
+ * algorithm.
+ *
+ * "SSL_CTX_set1_xxxx_parameters()" sets the parameters in the SSL_CTX object
+ * for key exchange algorithm "xxxx" using an int array of parameter NIDs via
+ * "nid_list", and the number of NIDs via "nid_list_len".
+ *
+ * "SSL_CTX_set1_xxxx_parameters_list()" sets the parameters in the SSL_CTX
+ * object for key exchange algorithm "xxxx" using parameters in string format,
+ * via "str_list".
+ *
+ * "SSL_set1_xxxx_parameters()" and ""SSL_set1_xxxx_parameters_list()" are
+ * similar to "SSL_CTX_set1_xxxx_parameters()" and
+ * "SSL_CTX_set1_xxxx_parameters_list()", respectively, except that the
+ * parameters are set in the SSL object.
+ *
+ * The following are supported parameters for each QS key exchange algorithm.
+ *
+ *  Algorithm         NID                    String
+ *   Kyber      NID_Kyber_768_r2         "Kyber_768_r2"
+ *              NID_Kyber_1024_r2        "Kyber_1024_r2"
+ *
+ *   SIKE       NID_SIKE_p503_r2         "SIKE_p503_r2"
+ *              NID_SIKE_p751_r2         "SIKE_p751_r2"
+ *
+ *   NHDH       NID_NewHope_1024_v0      "NewHope_1024_v0"
+ *
+ *   SIDH       NID_SIDH_p503_r2         "SIDH_p503_r2"
+ *              NID_SIDH_p751_r2         "SIDH_p751_r2"
+ *
+ * Parameters are ordered from most preferred to least preferred in the array
+ * or string. To specify multiple parameters with string format, use colon to
+ * separate the parameters, e.g., "Kyber_1024_r2:Kyber_768_r2".
+ *
+ * Each function returns 1 on success and 0 on failure.
+ */
+# define SSL_CTX_set1_kyber_parameters(ctx, nid_list, nid_list_len) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_KYBER_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_CTX_set1_kyber_parameters_list(ctx, str_list) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_KYBER_PARAMETERS_LIST,0,(char *)str_list)
+
+# define SSL_set1_kyber_parameters(ssl, nid_list, nid_list_len) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_KYBER_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_set1_kyber_parameters_list(ssl, str_list) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_KYBER_PARAMETERS_LIST,0,(char *)str_list)
+
+# define SSL_CTX_set1_sike_parameters(ctx, nid_list, nid_list_len) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIKE_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_CTX_set1_sike_parameters_list(ctx, str_list) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIKE_PARAMETERS_LIST,0,(char *)str_list)
+
+# define SSL_set1_sike_parameters(ssl, nid_list, nid_list_len) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_SIKE_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_set1_sike_parameters_list(ssl, str_list) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_SIKE_PARAMETERS_LIST,0,(char *)str_list)
+
+# define SSL_CTX_set1_nhdh_parameters(ctx, nid_list, nid_list_len) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_NHDH_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_CTX_set1_nhdh_parameters_list(ctx, str_list) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_NHDH_PARAMETERS_LIST,0,(char *)str_list)
+
+# define SSL_set1_nhdh_parameters(ssl, nid_list, nid_list_len) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_NHDH_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_set1_nhdh_parameters_list(ssl, str_list) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_NHDH_PARAMETERS_LIST,0,(char *)str_list)
+
+# define SSL_CTX_set1_sidh_parameters(ctx, nid_list, nid_list_len) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIDH_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_CTX_set1_sidh_parameters_list(ctx, str_list) \
+        SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIDH_PARAMETERS_LIST,0,(char *)str_list)
+
+# define SSL_set1_sidh_parameters(ssl, nid_list, nid_list_len) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_SIDH_PARAMETERS,nid_list_len,nid_list)
+
+# define SSL_set1_sidh_parameters_list(ssl, str_list) \
+        SSL_ctrl(ssl,SSL_CTRL_SET_SIDH_PARAMETERS_LIST,0,(char *)str_list)
+
+/** Get the shared parameter of a TLS QS key exchange algorithm that has been
+ * negotiated for the TLS session.
+ *
+ * These functions shall be called after TLS handshake has already been
+ * successfully performed. The corresponding SSL object on which the connection
+ * is established needs to be passed in as input.
+ *
+ * Each function returns the NID of the shared parameter, and 0 if there is no
+ * shared parameter (most likely the negotiated cipher suite does not contain
+ * the corresponding key exchange algorithm) or a failure occurs.
+ */
+# define SSL_get_shared_kyber_parameter(ssl) \
+        SSL_ctrl(ssl,SSL_CTRL_GET_SHARED_KYBER_PARAMETER,0,NULL)
+
+# define SSL_get_shared_sike_parameter(ssl) \
+        SSL_ctrl(ssl,SSL_CTRL_GET_SHARED_SIKE_PARAMETER,0,NULL)
+
+# define SSL_get_shared_nhdh_parameter(ssl) \
+        SSL_ctrl(ssl,SSL_CTRL_GET_SHARED_NHDH_PARAMETER,0,NULL)
+
+# define SSL_get_shared_sidh_parameter(ssl) \
+        SSL_ctrl(ssl,SSL_CTRL_GET_SHARED_SIDH_PARAMETER,0,NULL)
+# endif    /* OPENSSL_NO_QS_KEY_EXCHANGE */
+
 # define SSL_CTX_set1_sigalgs(ctx, slist, slistlen) \
         SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SIGALGS,slistlen,(int *)slist)
 # define SSL_CTX_set1_sigalgs_list(ctx, s) \
@@ -2197,6 +2368,11 @@ int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);
 int SSL_use_certificate_file(SSL *ssl, const char *file, int type);
 int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
+
+/* Register the alternative private key (contained in a file) corresponding
+ * to the MPKA certificate for the SSL context.
+ */
+int SSL_CTX_use_ALTPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);
 /* PEM type */
 int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);
@@ -2273,8 +2449,19 @@ int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
 int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d,
                                    long len);
 int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
+
+/* Register the alternative private key in EVP_PKEY form corresponding
+ * to the MPKA certificate for the SSL context.
+ */
+int SSL_CTX_use_ALTPrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
 int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx,
                                 const unsigned char *d, long len);
+
+/* Register the alternative private key in ASN.1 form corresponding
+ * to the MPKA certificate for the SSL context.
+ */
+int SSL_CTX_use_ALTPrivateKey_ASN1(int type, SSL_CTX *ctx,
+                                const unsigned char *d, long len);
 int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
 int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len,
                                  const unsigned char *d);
@@ -2428,6 +2615,8 @@ X509 *SSL_get_certificate(const SSL *ssl);
  * EVP_PKEY
  */ struct evp_pkey_st *SSL_get_privatekey(const SSL *ssl);
 
+EVP_PKEY *SSL_get_alt_pubkey(X509 *x);
+
 X509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx);
 EVP_PKEY *SSL_CTX_get0_privatekey(const SSL_CTX *ctx);
 
@@ -2587,6 +2776,7 @@ const struct openssl_ssl_test_functions *SSL_test_functions(void);
  * The following lines are auto generated by the script mkerr.pl. Any changes
  * made after this point may be overwritten when the script is next run.
  */
+
 void ERR_load_SSL_strings(void);
 
 /* Error codes for the SSL functions. */
@@ -2637,6 +2827,13 @@ void ERR_load_SSL_strings(void);
 # define SSL_F_GET_SERVER_STATIC_DH_KEY                   340
 # define SSL_F_GET_SERVER_VERIFY                          110
 # define SSL_F_I2D_SSL_SESSION                            111
+# define SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB                454
+# define SSL_F_IQRSSL_CERT_VERIFY                         453
+# define SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET 450
+# define SSL_F_IQRSSL_GENERATE_SERVER_PREMASTER_SECRET    452
+# define SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY              451
+# define SSL_F_IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG           341
+# define SSL_F_IQRSSL_PARSE_SERVER_KEY_EXCH_MSG           342
 # define SSL_F_READ_N                                     112
 # define SSL_F_REQUEST_CERTIFICATE                        113
 # define SSL_F_SERVER_FINISH                              239
@@ -2744,6 +2941,9 @@ void ERR_load_SSL_strings(void);
 # define SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT             219
 # define SSL_F_SSL_CTX_SET_SSL_VERSION                    170
 # define SSL_F_SSL_CTX_SET_TRUST                          229
+# define SSL_F_SSL_CTX_USE_ALTPRIVATEKEY                  455
+# define SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_ASN1             456
+# define SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE             457
 # define SSL_F_SSL_CTX_USE_CERTIFICATE                    171
 # define SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1               172
 # define SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE         220
@@ -2786,6 +2986,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_F_SSL_SESSION_PRINT_FP                       190
 # define SSL_F_SSL_SESSION_SET1_ID_CONTEXT                312
 # define SSL_F_SSL_SESS_CERT_NEW                          225
+# define SSL_F_SSL_SET_ALT_PKEY                           458
 # define SSL_F_SSL_SET_CERT                               191
 # define SSL_F_SSL_SET_CIPHER_LIST                        271
 # define SSL_F_SSL_SET_FD                                 192
@@ -2846,6 +3047,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_R_BAD_DH_P_LENGTH                            110
 # define SSL_R_BAD_DH_P_VALUE                             395
 # define SSL_R_BAD_DIGEST_LENGTH                          111
+# define SSL_R_BAD_DILITHIUM_SIGNATURE                    551
 # define SSL_R_BAD_DSA_SIGNATURE                          112
 # define SSL_R_BAD_ECC_CERT                               304
 # define SSL_R_BAD_ECDSA_SIGNATURE                        305
@@ -2886,6 +3088,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_R_CA_DN_TOO_LONG                             132
 # define SSL_R_CCS_RECEIVED_EARLY                         133
 # define SSL_R_CERTIFICATE_VERIFY_FAILED                  134
+# define SSL_R_CERT_ALT_PUBKEY_ALG_DUPLICATE              394
 # define SSL_R_CERT_CB_ERROR                              377
 # define SSL_R_CERT_LENGTH_MISMATCH                       135
 # define SSL_R_CHALLENGE_IS_DIFFERENT                     136
@@ -2962,6 +3165,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_R_MISSING_DH_DSA_CERT                        162
 # define SSL_R_MISSING_DH_KEY                             163
 # define SSL_R_MISSING_DH_RSA_CERT                        164
+# define SSL_R_MISSING_DILITHIUM_SIGNING_CERT             553
 # define SSL_R_MISSING_DSA_SIGNING_CERT                   165
 # define SSL_R_MISSING_ECDH_CERT                          382
 # define SSL_R_MISSING_ECDSA_SIGNING_CERT                 381
@@ -3158,7 +3362,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_R_X509_LIB                                   268
 # define SSL_R_X509_VERIFICATION_SETUP_PROBLEMS           269
 
-#ifdef  __cplusplus
+# ifdef  __cplusplus
 }
-#endif
+# endif
 #endif
diff --git a/openssl-1.0.2r/ssl/ssl3.h b/openssl-1.0.2r/ssl/ssl3.h
index e681d50a..231efe71 100644
--- a/openssl-1.0.2r/ssl/ssl3.h
+++ b/openssl-1.0.2r/ssl/ssl3.h
@@ -459,7 +459,7 @@ typedef struct ssl3_buffer_st {
  * SSL3_CT_NUMBER is used to size arrays and it must be large enough to
  * contain all of the cert types defined either for SSLv3 and TLSv1.
  */
-# define SSL3_CT_NUMBER                  9
+# define SSL3_CT_NUMBER                  12
 
 # define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS       0x0001
 # define SSL3_FLAGS_DELAY_CLIENT_FINISHED        0x0002
@@ -567,6 +567,10 @@ typedef struct ssl3_state_st {
 #  endif
 #  ifndef OPENSSL_NO_ECDH
         EC_KEY *ecdh;           /* holds short lived ECDH key */
+#  endif
+#  ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+        EVP_PKEY_CTX *server_qs_pkey_ctx[QS_TLS_KEY_EXCH_ALGOS_NUM];  /* holds short lived QS pkey context */
+        EVP_PKEY *server_qs_pkey[QS_TLS_KEY_EXCH_ALGOS_NUM];  /* holds short lived QS pkey */
 #  endif
         /* used when SSL_ST_FLUSH_DATA is entered */
         int next_state;
diff --git a/openssl-1.0.2r/ssl/ssl_cert.c b/openssl-1.0.2r/ssl/ssl_cert.c
index 363d2b2d..dd582e45 100644
--- a/openssl-1.0.2r/ssl/ssl_cert.c
+++ b/openssl-1.0.2r/ssl/ssl_cert.c
@@ -128,12 +128,447 @@
 #include <openssl/bio.h>
 #include <openssl/pem.h>
 #include <openssl/x509v3.h>
+#include <openssl/asn1.h>
 #ifndef OPENSSL_NO_DH
 # include <openssl/dh.h>
 #endif
 #include <openssl/bn.h>
 #include "ssl_locl.h"
 
+
+static int iqrssl_cert_verify(X509_STORE_CTX *ctx)
+{
+    X509 *subject_cert = NULL;
+    X509 *issuer_cert = NULL;
+    X509 *alt_free_cert = NULL;
+
+    STACK_OF(X509) *cert_chain = NULL;
+    int cert_depth = 0;
+
+    int alt_pub_key_idx = -1;
+    int alt_sig_alg_ind = -1;
+    X509_ALGOR *alt_sig_alg = NULL;
+    X509_EXTENSION *alt_sig_alg_ext = NULL;
+
+    int alt_sig_val_idx = -1;
+    X509_EXTENSION *alt_sig_val_ext = NULL;
+    X509_EXTENSION *new_alt_sig_val_ext = NULL;
+
+    ASN1_BIT_STRING *alt_sig_val = NULL;
+
+    EVP_PKEY *pkey_cls_vfy = NULL;
+    EVP_PKEY *alt_pub_key = NULL;
+
+    int ok = 0;
+
+    subject_cert = X509_STORE_CTX_get_current_cert(ctx);
+    if (subject_cert == NULL) {
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    }
+
+    cert_chain = X509_STORE_CTX_get1_chain(ctx);
+    if (cert_chain == NULL) {
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    }
+
+    cert_depth = X509_STORE_CTX_get_error_depth(ctx);
+    if (sk_X509_num(cert_chain) - 1 == cert_depth) {
+        /* This is a root cert.
+         * If it is self-signed then skip verifying it.
+         * If it is not self-signed then we do not have the signer cert
+         * so we cannot verify it.
+         */
+
+        ok = 1;
+        goto end;
+    }
+
+    /* Grab the next cert in the stack, which should be the issuer cert. OpenSSL upper layer
+     * should have checked that for us so we do not need to bother with any checks.
+     */
+    issuer_cert = sk_X509_value(cert_chain, cert_depth + 1);
+    if (issuer_cert == NULL) {
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    }
+
+    /* Find the issuer's subject alternative public key info extension. */
+    alt_pub_key_idx = X509_get_ext_by_NID(issuer_cert, NID_subjectAltPublicKeyInfo, -1);
+
+    /* Find the subject's alternative signature extension. */
+    alt_sig_val_idx = X509_get_ext_by_NID(subject_cert, NID_altSignatureValue, -1);
+
+    if (alt_pub_key_idx < 0 && alt_sig_val_idx < 0) {
+        /* Both the issuer cert and the subject cert are classical.
+         * The following verifies the subject cert classically (not necessarily with
+         * classical sig algorithms, because classical cert can still be created
+         * with QS sig algorithms).
+         */
+
+        pkey_cls_vfy = X509_get_pubkey(issuer_cert);
+        if (pkey_cls_vfy == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Perform cert verification. */
+        if (X509_verify(subject_cert, pkey_cls_vfy) <= 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+    } else if (alt_pub_key_idx >= 0 && alt_sig_val_idx < 0) {
+        /* The issuer cert is an MPKAC but the subject cert is classical.
+         * Such cert-chains are rejected as per MPKAC design
+         * (https://tools.ietf.org/html/draft-truskovsky-lamps-pq-hybrid-x509-01).
+         */
+
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    } else if (alt_pub_key_idx < 0 && alt_sig_val_idx >= 0) {
+        /* Cannot find issuer's subject alternative public key info extension,
+         * but the subject cert contains alternative signature extension.
+         * This should not happen, as the classical issuer cannot produce a
+         * MPKAC. Therefore, something is wrong, e.g., the issuer/subject
+         * cert is incorrect).
+         */
+
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    } else if (alt_pub_key_idx >= 0 && alt_sig_val_idx >= 0) {
+        /* Both the issuer cert and the subject cert are MPKACs.
+         * Verify the subject cert with both the classical sig algorithm
+         * and the alternative sig algorithm.
+         */
+
+        /* Perform classical signature verification. */
+        pkey_cls_vfy = X509_get_pubkey(issuer_cert);
+        if (pkey_cls_vfy == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        if (X509_verify(subject_cert, pkey_cls_vfy) <= 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Perform alt signature verification. */
+        /* Get the issuer's subject alternative public key. */
+        alt_pub_key = SSL_get_alt_pubkey(issuer_cert);
+
+        if (alt_pub_key == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Find the subject's alternative signature algorithm extension. */
+        alt_sig_alg_ind = X509_get_ext_by_NID(subject_cert, NID_altSignatureAlgorithm, -1);
+        if (alt_sig_alg_ind < 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Get the subject's alternative signature algorithm extension. */
+        alt_sig_alg_ext = X509_get_ext(subject_cert, alt_sig_alg_ind);
+        if (alt_sig_alg_ext == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Convert the subject's alternative signature algorithm extension into internal representation. */
+        alt_sig_alg = X509V3_EXT_d2i(alt_sig_alg_ext);
+        if (alt_sig_alg == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Get the subject's alternative signature extension. */
+        alt_sig_val_ext = X509_get_ext(subject_cert, alt_sig_val_idx);
+        if (alt_sig_val_ext == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Converting the subject's alternative signature extension into internal representation. */
+        alt_sig_val = X509V3_EXT_d2i(alt_sig_val_ext);
+        if (alt_sig_val == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Duplicate the subject certificate, remove the alternative signature extension, and verify against that. */
+        alt_free_cert = X509_dup(subject_cert);
+        if (alt_free_cert == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        new_alt_sig_val_ext = X509_get_ext(alt_free_cert, alt_sig_val_idx);
+        if (new_alt_sig_val_ext == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        if (X509_delete_ext(alt_free_cert, alt_sig_val_idx) == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Stuff is being cached. (https://www.openssl.org/docs/man1.1.0/crypto/X509_sign.html.) */
+        alt_free_cert->cert_info->enc.modified = 1;
+
+        /* Perform cert verification. */
+        if (ASN1_item_verify(ASN1_ITEM_rptr(X509_PCINF), alt_sig_alg, alt_sig_val, alt_free_cert->cert_info, alt_pub_key) <= 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+    }
+
+    ok = 1;
+
+end:
+    if (cert_chain) {
+        sk_X509_pop_free(cert_chain, X509_free);
+    }
+
+    if (pkey_cls_vfy) {
+        EVP_PKEY_free(pkey_cls_vfy);
+    }
+
+    if (alt_pub_key) {
+        EVP_PKEY_free(alt_pub_key);
+    }
+
+    if (alt_sig_alg) {
+        X509_ALGOR_free(alt_sig_alg);
+    }
+
+    if (alt_sig_val) {
+        ASN1_BIT_STRING_free(alt_sig_val);
+    }
+
+    if (alt_free_cert) {
+        X509_free(alt_free_cert);
+    }
+
+    if (new_alt_sig_val_ext) {
+        X509_EXTENSION_free(new_alt_sig_val_ext);
+    }
+
+    return ok;
+}
+
+static int iqrssl_check_cert_time(X509_STORE_CTX *ctx, X509 *x)
+{
+    time_t *ptime = 0;
+    int i = 0;
+
+    if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME) {
+        ptime = &ctx->param->check_time;
+    } else {
+        ptime = NULL;
+    }
+
+    /* Check not-before time. */
+    i = X509_cmp_time(X509_get_notBefore(x), ptime);
+    if (i == 0) {
+        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    if (i > 0) {
+        ctx->error = X509_V_ERR_CERT_NOT_YET_VALID;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    /* Check not-after time. */
+    i = X509_cmp_time(X509_get_notAfter(x), ptime);
+    if (i == 0) {
+        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    if (i < 0) {
+        ctx->error = X509_V_ERR_CERT_HAS_EXPIRED;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static int iqrssl_cert_chain_verify_cb(X509_STORE_CTX *ctx)
+{
+    int ok = 0;
+    int n = 0;
+    X509 *subject_cert = NULL;
+    X509 *issuer_cert = NULL;
+    int (*cb) (int xok, X509_STORE_CTX *xctx);
+
+    if (ctx == NULL) {
+        goto end;
+    }
+
+    /* Set the error callback. */
+    cb = ctx->verify_cb;
+
+    /* Get the number of certs in the chain. */
+    n = sk_X509_num(ctx->chain);
+    if (n <= 0) {
+        ctx->error = X509_V_ERR_UNSPECIFIED;
+        SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+        ok = cb(0, ctx);
+        goto end;
+    }
+
+    /* Get the last cert in the chain, mostly likely a self-signed cert. */
+    n--;
+    ctx->error_depth = n;
+    issuer_cert = sk_X509_value(ctx->chain, n);
+    if (issuer_cert == NULL) {
+        ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
+        SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+        ok = cb(0, ctx);
+        goto end;
+    }
+
+    /* Check if the issuer of subject cert is the subject of the issuer cert. */
+    if (ctx->check_issued(ctx, issuer_cert, issuer_cert)) {
+        /* Self-signed cert */
+        subject_cert = issuer_cert;
+    } else {
+        /* Not a self-signed cert */
+        if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
+            subject_cert = issuer_cert;
+            goto check_cert;
+        }
+
+        if (n <= 0) {
+            ctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
+            ctx->current_cert = issuer_cert;
+            SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+            ok = cb(0, ctx);
+            goto end;
+        } else {
+            /* Get the next cert in the chain, which should be the subject cert.*/
+            n--;
+            ctx->error_depth = n;
+            subject_cert = sk_X509_value(ctx->chain, n);
+            if (subject_cert == NULL) {
+                ctx->error = X509_V_ERR_UNSPECIFIED;
+                ctx->current_cert = issuer_cert;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+
+            if (!ctx->check_issued(ctx, subject_cert, issuer_cert)) {
+                ctx->error = X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
+                ctx->current_issuer = issuer_cert;
+                ctx->current_cert = subject_cert;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+        }
+    }
+
+    while (n >= 0) {
+        ctx->error_depth = n;
+
+        /*
+         * Perform cert verification.
+         *
+         * Skip signature check for self signed certificates unless
+         * explicitly asked for. This is the default behavior of openssl.
+         */
+        if (!subject_cert->valid && (subject_cert != issuer_cert || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {
+            ctx->current_issuer = issuer_cert;
+            ctx->current_cert = subject_cert;
+
+            ok = iqrssl_cert_verify(ctx);
+            if (!ok) {
+                ctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+        }
+
+        subject_cert->valid = 1;
+
+check_cert:
+        /* Check cert validity. */
+        ok = iqrssl_check_cert_time(ctx, subject_cert);
+        if (!ok) {
+            SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+            ok = cb(0, ctx);
+            goto end;
+        }
+
+        /*
+         * Call the error callback with 1 (success).
+         * This gives the user a chance to do things like printing the status, etc.
+         */
+        ctx->current_issuer = issuer_cert;
+        ctx->current_cert = subject_cert;
+
+        ok = (*cb) (1, ctx);
+        if (!ok) {
+            SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Go down one level in the cert-chain and do the verification again. */
+        n--;
+        if (n >= 0) {
+            issuer_cert = subject_cert;
+            subject_cert = sk_X509_value(ctx->chain, n);
+            if (subject_cert == NULL) {
+                ctx->error = X509_V_ERR_UNSPECIFIED;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+
+            if (!ctx->check_issued(ctx, subject_cert, issuer_cert)) {
+                ctx->error = X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
+                ctx->current_issuer = issuer_cert;
+                ctx->current_cert = subject_cert;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+        }
+    }
+
+    ok = 1;
+end:
+    return ok;
+}
+
 int SSL_get_ex_data_X509_STORE_CTX_idx(void)
 {
     static volatile int ssl_x509_store_ctx_idx = -1;
@@ -195,6 +630,19 @@ void ssl_cert_set_default_md(CERT *cert)
 #ifndef OPENSSL_NO_ECDSA
     cert->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();
 #endif
+#ifndef OPENSSL_NO_HSS
+    cert->pkeys[SSL_PKEY_HSS].digest = EVP_sha512();
+#endif
+#ifndef OPENSSL_NO_XMSS
+    cert->pkeys[SSL_PKEY_XMSS].digest = EVP_sha512();
+#endif
+#ifndef OPENSSL_NO_XMSSMT
+    cert->pkeys[SSL_PKEY_XMSSMT].digest = EVP_sha512();
+#endif
+#ifndef OPENSSL_NO_DILITHIUM
+    cert->pkeys[SSL_PKEY_DILITHIUM_III_SHAKE_R2].digest = EVP_sha512();
+    cert->pkeys[SSL_PKEY_DILITHIUM_IV_SHAKE_R2].digest = EVP_sha512();
+#endif
 }
 
 CERT *ssl_cert_new(void)
@@ -308,6 +756,8 @@ CERT *ssl_cert_dup(CERT *cert)
             }
         }
         rpk->valid_flags = 0;
+        rpk->is_mpka_cert = cpk->is_mpka_cert;
+        rpk->is_mpka_key = cpk->is_mpka_key;
 #ifndef OPENSSL_NO_TLSEXT
         if (cert->pkeys[i].serverinfo != NULL) {
             /* Just copy everything. */
@@ -447,6 +897,8 @@ void ssl_cert_clear_certs(CERT *c)
 #endif
         /* Clear all flags apart from explicit sign */
         cpk->valid_flags &= CERT_PKEY_EXPLICIT_SIGN;
+        cpk->is_mpka_cert = 0;
+        cpk->is_mpka_key = 0;
     }
 }
 
@@ -536,12 +988,43 @@ int ssl_cert_inst(CERT **o)
 
 int ssl_cert_set0_chain(CERT *c, STACK_OF(X509) *chain)
 {
+    int i = 0;
+    int alt_pub_key_idx = -1;
+    EVP_PKEY *alt_pub_key = NULL;
     CERT_PKEY *cpk = c->key;
     if (!cpk)
         return 0;
     if (cpk->chain)
         sk_X509_pop_free(cpk->chain, X509_free);
     cpk->chain = chain;
+
+    /*
+     * Cert chain also needs to be set for the alternative public key,
+     * so that MPKAC verification can find the proper issuer.
+     */
+    alt_pub_key_idx = X509_get_ext_by_NID(cpk->x509, NID_subjectAltPublicKeyInfo, -1);
+    if (alt_pub_key_idx >= 0) {
+        /* Get the hybrid ALT PKEY. */
+        alt_pub_key = SSL_get_alt_pubkey(cpk->x509);
+        if (alt_pub_key == NULL) {
+            return 0;
+        }
+
+        i = ssl_cert_type(cpk->x509, alt_pub_key);
+        if (i < 0) {
+            EVP_PKEY_free(alt_pub_key);
+            return 0;
+        }
+
+        EVP_PKEY_free(alt_pub_key);
+
+        if (c->pkeys[i].chain) {
+            sk_X509_pop_free(c->pkeys[i].chain, X509_free);
+        }
+
+        c->pkeys[i].chain = chain;
+    }
+
     return 1;
 }
 
@@ -562,6 +1045,9 @@ int ssl_cert_set1_chain(CERT *c, STACK_OF(X509) *chain)
 
 int ssl_cert_add0_chain_cert(CERT *c, X509 *x)
 {
+    int i = 0;
+    int alt_pub_key_idx = -1;
+    EVP_PKEY *alt_pub_key = NULL;
     CERT_PKEY *cpk = c->key;
     if (!cpk)
         return 0;
@@ -569,6 +1055,39 @@ int ssl_cert_add0_chain_cert(CERT *c, X509 *x)
         cpk->chain = sk_X509_new_null();
     if (!cpk->chain || !sk_X509_push(cpk->chain, x))
         return 0;
+
+    /*
+     * Cert chain also needs to be increased for the alternative public key,
+     * so that MPKAC verification can find the proper issuer.
+     */
+    alt_pub_key_idx = X509_get_ext_by_NID(cpk->x509, NID_subjectAltPublicKeyInfo, -1);
+    if (alt_pub_key_idx >= 0) {
+        /* Get the hybrid ALT PKEY. */
+        alt_pub_key = SSL_get_alt_pubkey(cpk->x509);
+        if (alt_pub_key == NULL) {
+            return 0;
+        }
+
+        i = ssl_cert_type(cpk->x509, alt_pub_key);
+        if (i < 0) {
+            EVP_PKEY_free(alt_pub_key);
+            return 0;
+        }
+
+        EVP_PKEY_free(alt_pub_key);
+
+        if (c->pkeys[i].chain == NULL) {
+            c->pkeys[i].chain = sk_X509_new_null();
+        }
+
+        if (c->pkeys[i].chain == NULL || !sk_X509_push(c->pkeys[i].chain, x)) {
+            return 0;
+        }
+
+        // Need to increase the reference for this cert.
+        CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
+    }
+
     return 1;
 }
 
@@ -697,6 +1216,12 @@ void ssl_sess_cert_free(SESS_CERT *sc)
         EC_KEY_free(sc->peer_ecdh_tmp);
 #endif
 
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (i = 0; i < QS_TLS_KEY_EXCH_ALGOS_NUM; i++) {
+        OPENSSL_free(sc->peer_qs_pub_tmp[i]);
+    }
+#endif
+
     OPENSSL_free(sc);
 }
 
@@ -721,6 +1246,10 @@ int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)
     if ((sk == NULL) || (sk_X509_num(sk) == 0))
         return (0);
 
+    if (verify_store && (verify_store->verify == NULL)) {
+        X509_STORE_set_verify_func(verify_store, iqrssl_cert_chain_verify_cb);
+    }
+
     x = sk_X509_value(sk, 0);
     if (!X509_STORE_CTX_init(&ctx, verify_store, x, sk)) {
         SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN, ERR_R_X509_LIB);
diff --git a/openssl-1.0.2r/ssl/ssl_ciph.c b/openssl-1.0.2r/ssl/ssl_ciph.c
index 58dcddfd..ea6c7998 100644
--- a/openssl-1.0.2r/ssl/ssl_ciph.c
+++ b/openssl-1.0.2r/ssl/ssl_ciph.c
@@ -261,6 +261,14 @@ static const SSL_CIPHER cipher_aliases[] = {
     {0, SSL_TXT_kECDHE, 0, SSL_kEECDH, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_ECDH, 0, SSL_kECDHr | SSL_kECDHe | SSL_kEECDH, 0, 0, 0, 0, 0,
      0, 0, 0},
+    {0, SSL_TXT_kECDHE_NHDH, 0, SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kECDHE_SIDH, 0,  SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kECDHE_NHDH_SIDH, 0,  SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kECDHE_KYBER, 0, SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kECDHE_SIKE, 0, SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kECDHE_KYBER_SIKE, 0,  SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kKYBER, 0, SSL_kEKYBER, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kSIKE, 0, SSL_kESIKE, 0, 0, 0, 0, 0, 0, 0, 0},
 
     {0, SSL_TXT_kPSK, 0, SSL_kPSK, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_kSRP, 0, SSL_kSRP, 0, 0, 0, 0, 0, 0, 0, 0},
@@ -270,6 +278,7 @@ static const SSL_CIPHER cipher_aliases[] = {
     {0, SSL_TXT_aRSA, 0, 0, SSL_aRSA, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_aDSS, 0, 0, SSL_aDSS, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_DSS, 0, 0, SSL_aDSS, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_DILITHIUM, 0, 0, SSL_aDILITHIUM, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_aKRB5, 0, 0, SSL_aKRB5, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_aNULL, 0, 0, SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     /* no such ciphersuites supported! */
@@ -295,6 +304,14 @@ static const SSL_CIPHER cipher_aliases[] = {
     {0, SSL_TXT_AECDH, 0, SSL_kEECDH, SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_PSK, 0, SSL_kPSK, SSL_aPSK, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_SRP, 0, SSL_kSRP, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_ECDHE_NHDH, 0, SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_ECDHE_SIDH, 0, SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_ECDHE_NHDH_SIDH, 0, SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_ECDHE_KYBER, 0, SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_ECDHE_SIKE, 0, SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_ECDHE_KYBER_SIKE, 0, SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_KYBER, 0, SSL_kEKYBER, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_SIKE, 0, SSL_kESIKE, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
 
     /* symmetric encryption aliases */
     {0, SSL_TXT_DES, 0, 0, 0, SSL_DES, 0, 0, 0, 0, 0, 0},
@@ -755,6 +772,18 @@ static void ssl_cipher_get_disabled(unsigned long *mkey, unsigned long *auth,
     *mkey |= SSL_kECDHe | SSL_kECDHr;
     *auth |= SSL_aECDH;
 #endif
+#ifdef OPENSSL_NO_NHDH
+    *mkey |= SSL_kENHDH;
+#endif
+#ifdef OPENSSL_NO_SIDH
+    *mkey |= SSL_kESIDH;
+#endif
+#ifdef OPENSSL_NO_SIKE
+    *mkey |= SSL_kESIKE;
+#endif
+#ifdef OPENSSL_NO_KYBER
+    *mkey |= SSL_kEKYBER;
+#endif
 #ifdef OPENSSL_NO_PSK
     *mkey |= SSL_kPSK;
     *auth |= SSL_aPSK;
@@ -1029,6 +1058,22 @@ static void ssl_cipher_apply_rule(unsigned long cipher_id,
             if (cipher_id && cipher_id != cp->id)
                 continue;
 #endif
+            if (alg_mkey && ((alg_mkey & SSL_kHYBRID) || (cp->algorithm_mkey & SSL_kHYBRID))) {
+                /*
+                 * If the key exchange is a hybrid, then it must be an exact match.
+                 *
+                 * E.g., specifying alg_mkey "ECDHE" shouldn't match cp "ECDHE-SIDH-ECDSA-AES256-GCM-SHA384", and
+                 * specifying alg_mkey "ECDHE-SIDH" shouldn't match cp "ECDHE-ECDSA-AES256-GCM-SHA384".
+                 *
+                 * "(alg_mkey & SSL_kHYBRID)" makes sure hybrid alg_mkey matches only hybrid cp->algorithm_mkey
+                 * (but not the reverse), and "(cp->algorithm_mkey & SSL_kHYBRID)" makes sure hybrid cp->algorithm_mkey
+                 * matches only hybrid alg_mkey (but not the reverse). Therefore, we need both conditions to achieve
+                 * matching in both directions.
+                 */
+                if (alg_mkey != cp->algorithm_mkey) {
+                    continue;
+                }
+            } else
             if (alg_mkey && !(alg_mkey & cp->algorithm_mkey))
                 continue;
             if (alg_auth && !(alg_auth & cp->algorithm_auth))
@@ -1524,10 +1569,118 @@ STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *ssl_method, STACK
 
     /* Now arrange all ciphers by preference: */
 
+    /* Set the quantum-safe ciphersuites to the highest priority. */
+
+    /*
+     * 1. Hybrid KEMs with QS signatures
+     * Within KEMs: KYBER > SIKE > KYBER + SIKE
+     */
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID, SSL_aDILITHIUM, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#if !((defined OPENSSL_NO_SIKE) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID, SSL_aDILITHIUM, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_SIKE) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID, SSL_aDILITHIUM, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
     /*
-     * Everything else being equal, prefer ephemeral ECDH over other key
-     * exchange mechanisms
+     * 2. Hybrid DHs with QS signatures
+     * Within KEMs: NHDH > SIDH > NHDH + SIDH
      */
+#if !((defined OPENSSL_NO_NHDH) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID, SSL_aDILITHIUM, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#if !((defined OPENSSL_NO_SIDH) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID, SSL_aDILITHIUM, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#if !((defined OPENSSL_NO_NHDH) || (defined OPENSSL_NO_SIDH) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID, SSL_aDILITHIUM, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+    /* 3. Hybrid KEMs with classical signatures */
+#ifndef OPENSSL_NO_KYBER
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID, SSL_aECDSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID, SSL_aRSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#ifndef OPENSSL_NO_SIKE
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID, SSL_aECDSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID, SSL_aRSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_SIKE))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID, SSL_aECDSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID, SSL_aRSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+    /* 4. Hybrid DHs with classical signatures */
+#ifndef OPENSSL_NO_NHDH
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID, SSL_aECDSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID, SSL_aRSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#ifndef OPENSSL_NO_SIDH
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID, SSL_aECDSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID, SSL_aRSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#if !((defined OPENSSL_NO_NHDH) || (defined OPENSSL_NO_SIDH))
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID, SSL_aECDSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID, SSL_aRSA, 0, 0, 0, 0,
+                          CIPHER_ADD, -1, &head, &tail);
+#endif
+
+    /* 5. Pure QS KEMs with QS signatures */
+#if !((defined OPENSSL_NO_KYBER) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kEKYBER, SSL_aDILITHIUM, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#if !((defined OPENSSL_NO_SIKE) || (defined OPENSSL_NO_DILITHIUM))
+    ssl_cipher_apply_rule(0, SSL_kESIKE, SSL_aDILITHIUM, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
+#endif
+
+    /* 6. Pure QS KEMs with classical signatures */
+#ifndef OPENSSL_NO_KYBER
+    ssl_cipher_apply_rule(0, SSL_kEKYBER, SSL_aECDSA, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kEKYBER, SSL_aRSA, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
+#endif
+
+#ifndef OPENSSL_NO_SIKE
+    ssl_cipher_apply_rule(0, SSL_kESIKE, SSL_aECDSA, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
+
+    ssl_cipher_apply_rule(0, SSL_kESIKE, SSL_aRSA, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
+#endif
+
     ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head,
                           &tail);
     ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head,
@@ -1734,6 +1887,30 @@ char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len)
     case SSL_kEECDH:
         kx = "ECDH";
         break;
+    case (SSL_kEECDH | SSL_kENHDH | SSL_kHYBRID):
+        kx = "ECDHE+NHDH";
+        break;
+    case (SSL_kEECDH | SSL_kESIDH | SSL_kHYBRID):
+        kx = "ECDHE+SIDH";
+        break;
+    case (SSL_kEECDH | SSL_kENHDH | SSL_kESIDH | SSL_kHYBRID):
+        kx = "ECDHE+NHDH+SIDH";
+        break;
+    case (SSL_kEECDH | SSL_kEKYBER | SSL_kHYBRID):
+        kx = "ECDHE+KYBER";
+        break;
+    case (SSL_kEECDH | SSL_kESIKE | SSL_kHYBRID):
+        kx = "ECDHE+SIKE";
+        break;
+    case (SSL_kEECDH | SSL_kEKYBER | SSL_kESIKE | SSL_kHYBRID):
+        kx = "ECDHE+KYBER+SIKE";
+        break;
+    case SSL_kEKYBER:
+        kx = "KYBER";
+        break;
+    case SSL_kESIKE:
+        kx = "SIKE";
+        break;
     case SSL_kPSK:
         kx = "PSK";
         break;
@@ -1781,6 +1958,9 @@ char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len)
     case SSL_aGOST01:
         au = "GOST01";
         break;
+    case SSL_aDILITHIUM:
+        au = "DILITHIUM";
+        break;
     default:
         au = "unknown";
         break;
@@ -2047,7 +2227,7 @@ const char *SSL_COMP_get_name(const COMP_METHOD *comp)
 }
 #endif
 /* For a cipher return the index corresponding to the certificate type */
-int ssl_cipher_get_cert_index(const SSL_CIPHER *c)
+int ssl_cipher_get_cert_index(const SSL *s, EVP_PKEY *pkey, const SSL_CIPHER *c)
 {
     unsigned long alg_k, alg_a;
 
@@ -2081,6 +2261,68 @@ int ssl_cipher_get_cert_index(const SSL_CIPHER *c)
         return SSL_PKEY_GOST94;
     else if (alg_a & SSL_aGOST01)
         return SSL_PKEY_GOST01;
+    else if (alg_a & SSL_aDILITHIUM) {
+        /*
+         * TODO (ISARA): We may be able to abstract the following into a tightly
+         * contained logic (T3876).
+         */
+        if (pkey != NULL) {
+            /* This is the receiver case. */
+
+            int type = ssl_cert_type(NULL, pkey);
+            if (type < 0) {
+                return -1;
+            }
+
+            if (type == SSL_PKEY_DILITHIUM_III_SHAKE_R2 || type == SSL_PKEY_DILITHIUM_IV_SHAKE_R2) {
+                return type;
+            } else {
+                /*
+                 * In this case, it actually doesn't matter which Dilithium parameter it
+                 * returns, as long as it belongs to Dilithium.
+                 *
+                 * The matching on the receiving end should fail, which signals that it is
+                 * a case of Catalyst where the auth in ciphersuite corresponds to the alt
+                 * public key in the entity cert.
+                 */
+
+                return SSL_PKEY_DILITHIUM_IV_SHAKE_R2;
+            }
+        } else if (s != NULL) {
+            /* This is the sender case. */
+
+            CERT *c = s->cert;
+
+            /*
+             * If the peer supports both Dilithium parameters and the entity
+             * has 2 cert chains that cover both parameters (which should be a
+             * rare case), then the entity picks the stronger parameter over the
+             * weaker one and send the corresponding cert chain to the peer for
+             * entity authentication.
+             */
+            CERT_PKEY *cpk = &(c->pkeys[SSL_PKEY_DILITHIUM_IV_SHAKE_R2]);
+            if (cpk->x509 != NULL && cpk->privatekey != NULL && cpk->valid_flags & CERT_PKEY_SIGN) {
+                if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+                    return SSL_PKEY_DILITHIUM_IV_SHAKE_R2;
+                }
+            }
+
+            cpk = &(c->pkeys[SSL_PKEY_DILITHIUM_III_SHAKE_R2]);
+            if (cpk->x509 != NULL && cpk->privatekey != NULL && cpk->valid_flags & CERT_PKEY_SIGN) {
+                if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+                    return SSL_PKEY_DILITHIUM_III_SHAKE_R2;
+                }
+            }
+        } else {
+            /*
+             * In this case the caller is neither the sender nor the
+             * receiver. Such case shouldn't happen.
+             */
+
+            return -1;
+        }
+    }
+
     return -1;
 }
 
diff --git a/openssl-1.0.2r/ssl/ssl_conf.c b/openssl-1.0.2r/ssl/ssl_conf.c
index 8d3709d2..d2faeb3b 100644
--- a/openssl-1.0.2r/ssl/ssl_conf.c
+++ b/openssl-1.0.2r/ssl/ssl_conf.c
@@ -258,6 +258,66 @@ static int cmd_Curves(SSL_CONF_CTX *cctx, const char *value)
     return rv > 0;
 }
 
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+/* Set supported QS key exchange algorithm parameters */
+/*
+ * TODO (T4247) JS: Document QS params setting capability using "SSL_CONF_cmd()"
+ * as well as using OpenSSL cnf file, when documenting the usage of
+ * "SSL_CTX_set1_xxxx_parameters_list()".
+ */
+static int cmd_NHDHParameters(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 0;
+
+    if (cctx->ssl) {
+        rv = SSL_set1_nhdh_parameters_list(cctx->ssl, value);
+    } else {
+        rv = SSL_CTX_set1_nhdh_parameters_list(cctx->ctx, value);
+    }
+
+    return rv > 0;
+}
+
+static int cmd_SIDHParameters(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 0;
+
+    if (cctx->ssl) {
+        rv = SSL_set1_sidh_parameters_list(cctx->ssl, value);
+    } else {
+        rv = SSL_CTX_set1_sidh_parameters_list(cctx->ctx, value);
+    }
+
+    return rv > 0;
+}
+
+static int cmd_KyberParameters(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 0;
+
+    if (cctx->ssl) {
+        rv = SSL_set1_kyber_parameters_list(cctx->ssl, value);
+    } else {
+        rv = SSL_CTX_set1_kyber_parameters_list(cctx->ctx, value);
+    }
+
+    return rv > 0;
+}
+
+static int cmd_SIKEParameters(SSL_CONF_CTX *cctx, const char *value)
+{
+    int rv = 0;
+
+    if (cctx->ssl) {
+        rv = SSL_set1_sike_parameters_list(cctx->ssl, value);
+    } else {
+        rv = SSL_CTX_set1_sike_parameters_list(cctx->ctx, value);
+    }
+
+    return rv > 0;
+}
+#endif    /* OPENSSL_NO_QS_KEY_EXCHANGE */
+
 #ifndef OPENSSL_NO_ECDH
 /* ECDH temporary parameters */
 static int cmd_ECDHParameters(SSL_CONF_CTX *cctx, const char *value)
@@ -456,6 +516,12 @@ static const ssl_conf_cmd_tbl ssl_conf_cmds[] = {
     SSL_CONF_CMD_STRING(SignatureAlgorithms, "sigalgs"),
     SSL_CONF_CMD_STRING(ClientSignatureAlgorithms, "client_sigalgs"),
     SSL_CONF_CMD_STRING(Curves, "curves"),
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    SSL_CONF_CMD_STRING(NHDHParameters, "nhdh_params"),
+    SSL_CONF_CMD_STRING(SIDHParameters, "sidh_params"),
+    SSL_CONF_CMD_STRING(KyberParameters, "kyber_params"),
+    SSL_CONF_CMD_STRING(SIKEParameters, "sike_params"),
+#endif
 #ifndef OPENSSL_NO_ECDH
     SSL_CONF_CMD_STRING(ECDHParameters, "named_curve"),
 #endif
diff --git a/openssl-1.0.2r/ssl/ssl_err.c b/openssl-1.0.2r/ssl/ssl_err.c
index a4c17a6b..9aeb69b2 100644
--- a/openssl-1.0.2r/ssl/ssl_err.c
+++ b/openssl-1.0.2r/ssl/ssl_err.c
@@ -1,6 +1,6 @@
 /* ssl/ssl_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2019 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -84,6 +84,7 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_DTLS1_CHECK_TIMEOUT_NUM), "dtls1_check_timeout_num"},
     {ERR_FUNC(SSL_F_DTLS1_CLIENT_HELLO), "dtls1_client_hello"},
     {ERR_FUNC(SSL_F_DTLS1_CONNECT), "dtls1_connect"},
+    {ERR_FUNC(SSL_F_DTLS1_ENC), "DTLS1_ENC"},
     {ERR_FUNC(SSL_F_DTLS1_GET_HELLO_VERIFY), "DTLS1_GET_HELLO_VERIFY"},
     {ERR_FUNC(SSL_F_DTLS1_GET_MESSAGE), "dtls1_get_message"},
     {ERR_FUNC(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT),
@@ -124,6 +125,19 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_GET_SERVER_STATIC_DH_KEY), "GET_SERVER_STATIC_DH_KEY"},
     {ERR_FUNC(SSL_F_GET_SERVER_VERIFY), "GET_SERVER_VERIFY"},
     {ERR_FUNC(SSL_F_I2D_SSL_SESSION), "i2d_SSL_SESSION"},
+    {ERR_FUNC(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB),
+     "IQRSSL_CERT_CHAIN_VERIFY_CB"},
+    {ERR_FUNC(SSL_F_IQRSSL_CERT_VERIFY), "IQRSSL_CERT_VERIFY"},
+    {ERR_FUNC(SSL_F_IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET),
+     "IQRSSL_GENERATE_CLIENT_PUBKEY_PREMASTER_SECRET"},
+    {ERR_FUNC(SSL_F_IQRSSL_GENERATE_SERVER_PREMASTER_SECRET),
+     "IQRSSL_GENERATE_SERVER_PREMASTER_SECRET"},
+    {ERR_FUNC(SSL_F_IQRSSL_GENERATE_SERVER_PUBKEY),
+     "IQRSSL_GENERATE_SERVER_PUBKEY"},
+    {ERR_FUNC(SSL_F_IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG),
+     "IQRSSL_PARSE_CLIENT_KEY_EXCH_MSG"},
+    {ERR_FUNC(SSL_F_IQRSSL_PARSE_SERVER_KEY_EXCH_MSG),
+     "IQRSSL_PARSE_SERVER_KEY_EXCH_MSG"},
     {ERR_FUNC(SSL_F_READ_N), "READ_N"},
     {ERR_FUNC(SSL_F_REQUEST_CERTIFICATE), "REQUEST_CERTIFICATE"},
     {ERR_FUNC(SSL_F_SERVER_FINISH), "SERVER_FINISH"},
@@ -260,6 +274,11 @@ static ERR_STRING_DATA SSL_str_functs[] = {
      "SSL_CTX_set_session_id_context"},
     {ERR_FUNC(SSL_F_SSL_CTX_SET_SSL_VERSION), "SSL_CTX_set_ssl_version"},
     {ERR_FUNC(SSL_F_SSL_CTX_SET_TRUST), "SSL_CTX_set_trust"},
+    {ERR_FUNC(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY), "SSL_CTX_use_ALTPrivateKey"},
+    {ERR_FUNC(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_ASN1),
+     "SSL_CTX_use_ALTPrivateKey_ASN1"},
+    {ERR_FUNC(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE),
+     "SSL_CTX_use_ALTPrivateKey_file"},
     {ERR_FUNC(SSL_F_SSL_CTX_USE_CERTIFICATE), "SSL_CTX_use_certificate"},
     {ERR_FUNC(SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1),
      "SSL_CTX_use_certificate_ASN1"},
@@ -322,6 +341,7 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_SSL_SESSION_SET1_ID_CONTEXT),
      "SSL_SESSION_set1_id_context"},
     {ERR_FUNC(SSL_F_SSL_SESS_CERT_NEW), "ssl_sess_cert_new"},
+    {ERR_FUNC(SSL_F_SSL_SET_ALT_PKEY), "SSL_SET_ALT_PKEY"},
     {ERR_FUNC(SSL_F_SSL_SET_CERT), "SSL_SET_CERT"},
     {ERR_FUNC(SSL_F_SSL_SET_CIPHER_LIST), "SSL_set_cipher_list"},
     {ERR_FUNC(SSL_F_SSL_SET_FD), "SSL_set_fd"},
@@ -396,6 +416,7 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
     {ERR_REASON(SSL_R_BAD_DH_P_LENGTH), "bad dh p length"},
     {ERR_REASON(SSL_R_BAD_DH_P_VALUE), "bad dh p value"},
     {ERR_REASON(SSL_R_BAD_DIGEST_LENGTH), "bad digest length"},
+    {ERR_REASON(SSL_R_BAD_DILITHIUM_SIGNATURE), "bad dilithium signature"},
     {ERR_REASON(SSL_R_BAD_DSA_SIGNATURE), "bad dsa signature"},
     {ERR_REASON(SSL_R_BAD_ECC_CERT), "bad ecc cert"},
     {ERR_REASON(SSL_R_BAD_ECDSA_SIGNATURE), "bad ecdsa signature"},
@@ -442,6 +463,8 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
     {ERR_REASON(SSL_R_CCS_RECEIVED_EARLY), "ccs received early"},
     {ERR_REASON(SSL_R_CERTIFICATE_VERIFY_FAILED),
      "certificate verify failed"},
+    {ERR_REASON(SSL_R_CERT_ALT_PUBKEY_ALG_DUPLICATE),
+     "cert alt pubkey alg duplicate"},
     {ERR_REASON(SSL_R_CERT_CB_ERROR), "cert cb error"},
     {ERR_REASON(SSL_R_CERT_LENGTH_MISMATCH), "cert length mismatch"},
     {ERR_REASON(SSL_R_CHALLENGE_IS_DIFFERENT), "challenge is different"},
@@ -531,6 +554,7 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
     {ERR_REASON(SSL_R_KRB5_S_TKT_NYV), "krb5 server tkt not yet valid"},
     {ERR_REASON(SSL_R_KRB5_S_TKT_SKEW), "krb5 server tkt skew"},
     {ERR_REASON(SSL_R_LENGTH_MISMATCH), "length mismatch"},
+    {ERR_REASON(SSL_R_LENGTH_TOO_LONG), "length too long"},
     {ERR_REASON(SSL_R_LENGTH_TOO_SHORT), "length too short"},
     {ERR_REASON(SSL_R_LIBRARY_BUG), "library bug"},
     {ERR_REASON(SSL_R_LIBRARY_HAS_NO_CIPHERS), "library has no ciphers"},
@@ -538,6 +562,8 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
     {ERR_REASON(SSL_R_MISSING_DH_DSA_CERT), "missing dh dsa cert"},
     {ERR_REASON(SSL_R_MISSING_DH_KEY), "missing dh key"},
     {ERR_REASON(SSL_R_MISSING_DH_RSA_CERT), "missing dh rsa cert"},
+    {ERR_REASON(SSL_R_MISSING_DILITHIUM_SIGNING_CERT),
+     "missing dilithium signing cert"},
     {ERR_REASON(SSL_R_MISSING_DSA_SIGNING_CERT), "missing dsa signing cert"},
     {ERR_REASON(SSL_R_MISSING_ECDH_CERT), "missing ecdh cert"},
     {ERR_REASON(SSL_R_MISSING_ECDSA_SIGNING_CERT),
@@ -753,11 +779,11 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
      "tls illegal exporter label"},
     {ERR_REASON(SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST),
      "tls invalid ecpointformat list"},
-    {ERR_REASON(SSL_R_TOO_MANY_WARN_ALERTS), "too many warn alerts"},
     {ERR_REASON(SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST),
      "tls peer did not respond with certificate list"},
     {ERR_REASON(SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG),
      "tls rsa encrypted value length is wrong"},
+    {ERR_REASON(SSL_R_TOO_MANY_WARN_ALERTS), "too many warn alerts"},
     {ERR_REASON(SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER),
      "tried to use unsupported cipher"},
     {ERR_REASON(SSL_R_UNABLE_TO_DECODE_DH_CERTS),
diff --git a/openssl-1.0.2r/ssl/ssl_lib.c b/openssl-1.0.2r/ssl/ssl_lib.c
index cfcfe76b..e23024ff 100644
--- a/openssl-1.0.2r/ssl/ssl_lib.c
+++ b/openssl-1.0.2r/ssl/ssl_lib.c
@@ -294,6 +294,7 @@ int SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth)
 SSL *SSL_new(SSL_CTX *ctx)
 {
     SSL *s;
+    int qs_idx = 0;
 
     if (ctx == NULL) {
         SSLerr(SSL_F_SSL_NEW, SSL_R_NULL_SSL_CTX);
@@ -393,6 +394,19 @@ SSL *SSL_new(SSL_CTX *ctx)
             ctx->tlsext_ellipticcurvelist_length;
     }
 # endif
+# ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (ctx->qs_key_exch_parameters[qs_idx] != NULL) {
+            s->qs_key_exch_parameters[qs_idx] = BUF_memdup(ctx->qs_key_exch_parameters[qs_idx],
+                                                           ctx->qs_key_exch_parameters_length[qs_idx]);
+            if (s->qs_key_exch_parameters[qs_idx] == NULL) {
+                goto err;
+            }
+
+            s->qs_key_exch_parameters_length[qs_idx] = ctx->qs_key_exch_parameters_length[qs_idx];
+        }
+    }
+# endif
 # ifndef OPENSSL_NO_NEXTPROTONEG
     s->next_proto_negotiated = NULL;
 # endif
@@ -562,6 +576,7 @@ void SSL_certs_clear(SSL *s)
 void SSL_free(SSL *s)
 {
     int i;
+    int qs_idx = 0;
 
     if (s == NULL)
         return;
@@ -631,6 +646,17 @@ void SSL_free(SSL *s)
     if (s->tlsext_ellipticcurvelist)
         OPENSSL_free(s->tlsext_ellipticcurvelist);
 # endif                         /* OPENSSL_NO_EC */
+# ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (s->qs_key_exch_parameters[qs_idx] != NULL) {
+            OPENSSL_free(s->qs_key_exch_parameters[qs_idx]);
+        }
+    }
+
+    if (s->curves_and_qs_params != NULL) {
+        OPENSSL_free(s->curves_and_qs_params);
+    }
+# endif                         /* OPENSSL_NO_QS_KEY_EXCHANGE */
     if (s->tlsext_opaque_prf_input)
         OPENSSL_free(s->tlsext_opaque_prf_input);
     if (s->tlsext_ocsp_exts)
@@ -2116,6 +2142,7 @@ static void ssl_buf_freelist_free(SSL3_BUF_FREELIST *list)
 void SSL_CTX_free(SSL_CTX *a)
 {
     int i;
+    int qs_idx = 0;
 
     if (a == NULL)
         return;
@@ -2203,6 +2230,13 @@ void SSL_CTX_free(SSL_CTX *a)
     if (a->tlsext_ellipticcurvelist)
         OPENSSL_free(a->tlsext_ellipticcurvelist);
 # endif                         /* OPENSSL_NO_EC */
+# ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (a->qs_key_exch_parameters[qs_idx] != NULL) {
+            OPENSSL_free(a->qs_key_exch_parameters[qs_idx]);
+        }
+    }
+# endif                         /* OPENSSL_NO_QS_KEY_EXCHANGE */
     if (a->alpn_client_proto_list != NULL)
         OPENSSL_free(a->alpn_client_proto_list);
 #endif
@@ -2333,6 +2367,91 @@ void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
         mask_a |= SSL_aGOST94;
     }
 
+    cpk = &(c->pkeys[SSL_PKEY_HSS]);
+    if (cpk->x509 != NULL && cpk->privatekey != NULL && cpk->valid_flags & CERT_PKEY_SIGN) {
+        /* If the private key is an alternative key but the peer does not support Catalyst,
+         * then do not set the mask.
+         *
+         * I.e., only set this mask if the private key is not an alternative key, or if
+         * it is an alternative key and the peer supports Catalyst.
+         *
+         * This is done so that when the server chooses the ciphersuite, it would not
+         * accidentally choose one with auth corresponding to the alternative key while
+         * the client does not actually support Catalyst.
+         */
+        if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+            mask_a |= SSL_aHSS;
+        }
+    }
+
+    cpk = &(c->pkeys[SSL_PKEY_XMSS]);
+    if (cpk->x509 != NULL && cpk->privatekey != NULL && cpk->valid_flags & CERT_PKEY_SIGN) {
+        /* If the private key is an alternative key but the peer does not support Catalyst,
+         * then do not set the mask.
+         *
+         * I.e., only set this mask if the private key is not an alternative key, or if
+         * it is an alternative key and the peer supports Catalyst.
+         *
+         * This is done so that when the server chooses the ciphersuite, it would not
+         * accidentally choose one with auth corresponding to the alternative key while
+         * the client does not actually support Catalyst.
+         */
+        if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+            mask_a |= SSL_aXMSS;
+        }
+    }
+
+    cpk = &(c->pkeys[SSL_PKEY_XMSSMT]);
+    if (cpk->x509 != NULL && cpk->privatekey != NULL && cpk->valid_flags & CERT_PKEY_SIGN) {
+        /* If the private key is an alternative key but the peer does not support Catalyst,
+         * then do not set the mask.
+         *
+         * I.e., only set this mask if the private key is not an alternative key, or if
+         * it is an alternative key and the peer supports Catalyst.
+         *
+         * This is done so that when the server chooses the ciphersuite, it would not
+         * accidentally choose one with auth corresponding to the alternative key while
+         * the client does not actually support Catalyst.
+         */
+        if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+            mask_a |= SSL_aXMSSMT;
+        }
+    }
+
+    cpk = &(c->pkeys[SSL_PKEY_DILITHIUM_III_SHAKE_R2]);
+    if (cpk->x509 != NULL && cpk->privatekey != NULL && cpk->valid_flags & CERT_PKEY_SIGN) {
+        /* If the private key is an alternative key but the peer does not support Catalyst,
+         * then do not set the mask.
+         *
+         * I.e., only set this mask if the private key is not an alternative key, or if
+         * it is an alternative key and the peer supports Catalyst.
+         * 
+         * This is done so that when the server chooses the ciphersuite, it would not
+         * accidentally choose one with auth corresponding to the alternative key while
+         * the client does not actually support Catalyst.
+         */
+        if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+            mask_a |= SSL_aDILITHIUM;
+        }
+    }
+
+    cpk = &(c->pkeys[SSL_PKEY_DILITHIUM_IV_SHAKE_R2]);
+    if (cpk->x509 != NULL && cpk->privatekey != NULL && cpk->valid_flags & CERT_PKEY_SIGN) {
+        /* If the private key is an alternative key but the peer does not support Catalyst,
+         * then do not set the mask.
+         *
+         * I.e., only set this mask if the private key is not an alternative key, or if
+         * it is an alternative key and the peer supports Catalyst.
+         *
+         * This is done so that when the server chooses the ciphersuite, it would not
+         * accidentally choose one with auth corresponding to the alternative key while
+         * the client does not actually support Catalyst.
+         */
+        if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+            mask_a |= SSL_aDILITHIUM;
+        }
+    }
+
     if (rsa_enc || (rsa_tmp && rsa_sign))
         mask_k |= SSL_kRSA;
     if (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))
@@ -2451,6 +2570,26 @@ void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
     }
 #endif
 
+#ifndef OPENSSL_NO_SIDH
+    mask_k |= SSL_kESIDH;
+    emask_k |= SSL_kESIDH;
+#endif
+
+#ifndef OPENSSL_NO_SIKE
+    mask_k |= SSL_kESIKE;
+    emask_k |= SSL_kESIKE;
+#endif
+
+#ifndef OPENSSL_NO_NHDH
+    mask_k |= SSL_kENHDH;
+    emask_k |= SSL_kENHDH;
+#endif
+
+#ifndef OPENSSL_NO_KYBER
+    mask_k |= SSL_kEKYBER;
+    emask_k |= SSL_kEKYBER;
+#endif
+
 #ifndef OPENSSL_NO_PSK
     mask_k |= SSL_kPSK;
     mask_a |= SSL_aPSK;
@@ -2541,7 +2680,7 @@ int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s)
 static int ssl_get_server_cert_index(const SSL *s)
 {
     int idx;
-    idx = ssl_cipher_get_cert_index(s->s3->tmp.new_cipher);
+    idx = ssl_cipher_get_cert_index(s, NULL, s->s3->tmp.new_cipher);
     if (idx == SSL_PKEY_RSA_ENC && !s->cert->pkeys[SSL_PKEY_RSA_ENC].x509)
         idx = SSL_PKEY_RSA_SIGN;
     if (idx == -1)
@@ -2599,16 +2738,25 @@ EVP_PKEY *ssl_get_sign_pkey(SSL *s, const SSL_CIPHER *cipher,
 #endif
 
     if ((alg_a & SSL_aDSS) &&
-            (c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL))
+            (c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL)) {
         idx = SSL_PKEY_DSA_SIGN;
-    else if (alg_a & SSL_aRSA) {
-        if (c->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL)
+    } else if (alg_a & SSL_aRSA) {
+        if (c->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL) {
             idx = SSL_PKEY_RSA_SIGN;
-        else if (c->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL)
+        } else if (c->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL) {
             idx = SSL_PKEY_RSA_ENC;
+        }
     } else if ((alg_a & SSL_aECDSA) &&
-               (c->pkeys[SSL_PKEY_ECC].privatekey != NULL))
+               (c->pkeys[SSL_PKEY_ECC].privatekey != NULL)) {
         idx = SSL_PKEY_ECC;
+    } else if (alg_a & SSL_aDILITHIUM) {
+        if (c->pkeys[SSL_PKEY_DILITHIUM_III_SHAKE_R2].privatekey != NULL) {
+            idx = SSL_PKEY_DILITHIUM_III_SHAKE_R2;
+        } else if (c->pkeys[SSL_PKEY_DILITHIUM_IV_SHAKE_R2].privatekey != NULL) {
+            idx = SSL_PKEY_DILITHIUM_IV_SHAKE_R2;
+        }
+    }
+
     if (idx == -1) {
         SSLerr(SSL_F_SSL_GET_SIGN_PKEY, ERR_R_INTERNAL_ERROR);
         return (NULL);
@@ -2887,6 +3035,7 @@ SSL *SSL_dup(SSL *s)
     X509_NAME *xn;
     SSL *ret;
     int i;
+    int qs_idx = 0;
 
     if ((ret = SSL_new(SSL_get_SSL_CTX(s))) == NULL)
         return (NULL);
@@ -2994,6 +3143,25 @@ SSL *SSL_dup(SSL *s)
         }
     }
 
+    /* Dup QS TLS key exchange data */
+# ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (s->qs_key_exch_parameters[qs_idx] != NULL) {
+            ret->qs_key_exch_parameters[qs_idx] = BUF_memdup(s->qs_key_exch_parameters[qs_idx],
+                                                           s->qs_key_exch_parameters_length[qs_idx]);
+            if (ret->qs_key_exch_parameters[qs_idx] == NULL) {
+                goto err;
+            }
+
+            ret->qs_key_exch_parameters_length[qs_idx] = s->qs_key_exch_parameters_length[qs_idx];
+        }
+    }
+
+    if (s->curves_and_qs_params != NULL) {
+        ret->curves_and_qs_params = BUF_memdup(s->curves_and_qs_params, s->curves_and_qs_params_size);
+    }
+# endif
+
     if (0) {
  err:
         if (ret != NULL)
@@ -3043,6 +3211,68 @@ EVP_PKEY *SSL_get_privatekey(const SSL *s)
         return (NULL);
 }
 
+EVP_PKEY *SSL_get_alt_pubkey(X509 *x)
+{
+    int alt_pub_key_idx = -1;
+    X509_EXTENSION *alt_pub_key_ext = NULL;
+
+    X509_PUBKEY *alt_x509_pubkey = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *alt_spki = NULL;
+
+    EVP_PKEY *alt_pub_key = NULL;
+
+    if (x == NULL) {
+        return NULL;
+    }
+
+    alt_pub_key_idx = X509_get_ext_by_NID(x, NID_subjectAltPublicKeyInfo, -1);
+    if (alt_pub_key_idx < 0 ) {
+        return NULL;
+    }
+
+    alt_pub_key_ext = X509_get_ext(x, alt_pub_key_idx);
+    if (alt_pub_key_ext == NULL) {
+        return NULL;
+    }
+
+    /* ASN.1 parse the ALT public key extension. */
+    alt_spki = X509V3_EXT_d2i(alt_pub_key_ext);
+    if (alt_spki == NULL) {
+        return NULL;
+    }
+
+    /* Convert the x509 formatted public key into an x509_PUBKEY. */
+    alt_x509_pubkey = X509_PUBKEY_new();
+    if (alt_x509_pubkey == NULL) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(alt_spki);
+        return NULL;
+    }
+
+    X509_ALGOR_free(alt_x509_pubkey->algor);
+    ASN1_BIT_STRING_free(alt_x509_pubkey->public_key);
+
+    alt_x509_pubkey->algor = alt_spki->algor;
+    alt_x509_pubkey->public_key = alt_spki->public_key;
+    alt_x509_pubkey->pkey = NULL;
+
+    /* Get the PKEY. */
+    alt_pub_key = X509_PUBKEY_get(alt_x509_pubkey);
+
+    alt_x509_pubkey->algor = NULL;
+    alt_x509_pubkey->public_key = NULL;
+    X509_PUBKEY_free(alt_x509_pubkey);
+    alt_x509_pubkey = NULL;
+
+    if (alt_pub_key == NULL) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(alt_spki);
+        return NULL;
+    }
+
+    SUBJECT_ALT_PUBLIC_KEY_INFO_free(alt_spki);
+
+    return alt_pub_key;
+}
+
 X509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx)
 {
     if (ctx->cert != NULL)
diff --git a/openssl-1.0.2r/ssl/ssl_locl.h b/openssl-1.0.2r/ssl/ssl_locl.h
index 43789ad7..4515f3ea 100644
--- a/openssl-1.0.2r/ssl/ssl_locl.h
+++ b/openssl-1.0.2r/ssl/ssl_locl.h
@@ -164,6 +164,18 @@
 # include <openssl/err.h>
 # include <openssl/ssl.h>
 # include <openssl/symhacks.h>
+#ifndef OPENSSL_NO_NHDH
+#include <openssl/nhdh.h>
+#endif
+#ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+#endif
+#ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+#endif
+#ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+#endif
 
 # ifdef OPENSSL_BUILD_SHLIBSSL
 #  undef OPENSSL_EXTERN
@@ -316,6 +328,147 @@
 # define SSL_kGOST       0x00000200L
 /* SRP */
 # define SSL_kSRP        0x00000400L
+/* ephemeral NEWHOPE */
+# define SSL_kENHDH              0x00001000L
+/* ephemeral SIDH */
+# define SSL_kESIDH              0x00002000L
+/* ephemeral KYBER */
+# define SSL_kEKYBER             0x00004000L
+/* ephemeral SIKE */
+# define SSL_kESIKE              0x00008000L
+/* hybrid key exchange */
+# define SSL_kHYBRID             0x01000000L
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+/*
+ * The set of QS key exchange algorithms currently used for TLS handshake.
+ *
+ * They are specified in both SSL_kXXXX and EVP_PKEY_XXXX with corresponding
+ * pkey_ctrl parameter commands added for convenience purposes.
+ *
+ * In order to properly support QS hybrid key exchange, algorithms should be
+ * listed in the order as they appear in the ciphersuite string.
+ * E.g., ECDHE-KYBER-SIKE-DILM-AES256-GCM-SHA384 suggests that Kyber should be
+ * listed before SIKE in the array.
+ */
+#define QS_TLS_KEY_EXCH_SSL_MASK      0
+#define QS_TLS_KEY_EXCH_EVP_NAME      1
+#define QS_TLS_KEY_EXCH_PKEY_CTRL_CMD 2
+static const long QS_TLS_KEY_EXCH_ALGOS[][QS_TLS_KEY_EXCH_ALGOS_NUM] = {{SSL_kENHDH, SSL_kESIDH, SSL_kEKYBER, SSL_kESIKE},
+                                                            {EVP_PKEY_NHDH, EVP_PKEY_SIDH, EVP_PKEY_KYBER, EVP_PKEY_SIKE},
+                                                      {EVP_PKEY_CTRL_NHDH_PARAMETER_SET, EVP_PKEY_CTRL_SIDH_PARAMETER_SET,
+                                                      EVP_PKEY_CTRL_KYBER_PARAMETER_SET, EVP_PKEY_CTRL_SIKE_PARAMETER_SET}};
+
+typedef struct {
+    unsigned char params_codepoint[QS_TLS_MAX_KEY_EXCH_PARAM_NUM * 2];
+    int params_internal[QS_TLS_MAX_KEY_EXCH_PARAM_NUM];
+    int params_nid[QS_TLS_MAX_KEY_EXCH_PARAM_NUM];
+    char *params_string[QS_TLS_MAX_KEY_EXCH_PARAM_NUM];
+    size_t params_num;
+} qs_key_exch_params;
+
+/*
+ * The set of parameters for QS key exchange algorithms specified above.
+ *
+ * The order of listed algos here must be the same as that in
+ * array "QS_TLS_KEY_EXCH_ALGOS" above.
+ */
+static const qs_key_exch_params SUPPORTED_QS_KEY_EXCH_PARAMS[] = {
+    /* NHDH parameters */
+    {
+      {
+        254, 06,    /* nhdh_1024_v0 code point (Dec:65030  Hex:0xFE06) */
+      },
+      {
+        NHDH_1024_V0,  /* The corresponding parameter macro defined internally in libcrypto */
+      },
+      {
+        NID_NewHope_1024_v0,  /* The corresponding parameter NID */
+      },
+      {
+        "NewHope_1024_v0",  /* The corresponding parameter string */
+      },
+      1  /* The number of parameters for this algorithm */
+    },
+
+    /* SIDH parameters */
+    {
+      {
+        254, 00,    /* sidh_p503_r2 code point (Dec:65024  Hex:0xFE00) */
+        254, 07,    /* sidh_p751_r2 code point (Dec:65031  Hex:0xFE07) */
+      },
+      {
+        SIDH_P503_R2,
+        SIDH_P751_R2,
+      },
+      {
+        NID_SIDH_p503_r2,
+        NID_SIDH_p751_r2,
+      },
+      {
+        "SIDH_p503_r2",
+        "SIDH_p751_r2",
+      },
+      2
+    },
+
+    /* Kyber parameters */
+    {
+      {
+        254, 04,    /* kyber_768_r2  code point (Dec:65028  Hex:0xFE04) */
+        254, 05,    /* kyber_1024_r2 code point (Dec:65029  Hex:0xFE05) */
+      },
+      {
+        KYBER_768_R2,
+        KYBER_1024_R2,
+      },
+      {
+        NID_Kyber_768_r2,
+        NID_Kyber_1024_r2,
+      },
+      {
+        "Kyber_768_r2",
+        "Kyber_1024_r2",
+      },
+      2
+    },
+
+    /* SIKE parameters */
+    {
+      {
+        254, 02,    /* sike_p503_r2 code point (Dec:65026  Hex:0xFE02) */
+        254, 03,    /* sike_p751_r2 code point (Dec:65027  Hex:0xFE03) */
+      },
+      {
+        SIKE_P503_R2,
+        SIKE_P751_R2,
+      },
+      {
+        NID_SIKE_p503_r2,
+        NID_SIKE_p751_r2,
+      },
+      {
+        "SIKE_p503_r2",
+        "SIKE_p751_r2",
+      },
+      2
+    },
+};
+#endif
+
+/*
+ * Return true if the passed in key exchange algorithm is a quantum-safe
+ * KEM-based key exchange algorithm. Otherwise, return false.
+ */
+static inline unsigned int iqrssl_is_qs_kem_key_exch(unsigned long key_exchange)
+{
+    if (key_exchange & SSL_kESIKE ||
+        key_exchange & SSL_kEKYBER) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
 
 /* Bits for algorithm_auth (server authentication) */
 /* RSA auth */
@@ -340,6 +493,14 @@
 # define SSL_aGOST01                     0x00000200L
 /* SRP auth */
 # define SSL_aSRP                0x00000400L
+/* HSS auth */
+# define SSL_aHSS                0x00000800L
+/* Dilithium auth */
+# define SSL_aDILITHIUM          0x00001000L
+/* XMSS auth */
+# define SSL_aXMSS               0x00002000L
+/* XMSSMT auth */
+# define SSL_aXMSSMT             0x00004000L
 
 /* Bits for algorithm_enc (symmetric encryption) */
 # define SSL_DES                 0x00000001L
@@ -509,7 +670,12 @@
 # define SSL_PKEY_ECC            5
 # define SSL_PKEY_GOST94         6
 # define SSL_PKEY_GOST01         7
-# define SSL_PKEY_NUM            8
+# define SSL_PKEY_HSS                     8
+# define SSL_PKEY_DILITHIUM_III_SHAKE_R2  9
+# define SSL_PKEY_DILITHIUM_IV_SHAKE_R2  10
+# define SSL_PKEY_XMSS                   11
+# define SSL_PKEY_XMSSMT                 12
+# define SSL_PKEY_NUM                    13
 
 /*-
  * SSL_kRSA <- RSA_ENC | (RSA_TMP & RSA_SIGN) |
@@ -559,6 +725,18 @@ typedef struct cert_pkey_st {
      * at all.
      */
     int valid_flags;
+    /*
+     * Set if the referenced cert is an MPKAC.
+     */
+    unsigned char is_mpka_cert;
+    /*
+     * Set if the private key is the alternative key for an MPKAC.
+     *
+     * Note that referenced cert being an MPKAC does not necessarily mean
+     * the private key needs to be an alternative key, e.g., pkey loaded for
+     * the non-alternative part of the cert.
+     */
+    unsigned char is_mpka_key;
 } CERT_PKEY;
 /* Retrieve Suite B flags */
 # define tls1_suiteb(s)  (s->cert->cert_flags & SSL_CERT_FLAG_SUITEB_128_LOS)
@@ -704,6 +882,8 @@ typedef struct cert_st {
     int alpn_sent;                  /* client */
     /* Count of the number of consecutive warning alerts received */
     unsigned int alert_count;
+    /* This is set if peer supports MPKAC (ISARA Catalyst). */
+    unsigned char peer_mpkac_support;
 } CERT;
 
 typedef struct sess_cert_st {
@@ -725,6 +905,10 @@ typedef struct sess_cert_st {
 # endif
 # ifndef OPENSSL_NO_ECDH
     EC_KEY *peer_ecdh_tmp;
+# endif
+# ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    unsigned char *peer_qs_pub_tmp[QS_TLS_KEY_EXCH_ALGOS_NUM];
+    size_t peer_qs_pub_size_tmp[QS_TLS_KEY_EXCH_ALGOS_NUM];
 # endif
     int references;             /* actually always 1 at the moment */
 } SESS_CERT;
@@ -736,6 +920,8 @@ struct tls_sigalgs_st {
     int sign_nid;
     /* Combined hash and signature NID */
     int signandhash_nid;
+    /* NID of signature algorithm parameter set */
+    int sign_parameter_set_nid;
     /* Raw values used in extension */
     unsigned char rsign;
     unsigned char rhash;
@@ -1096,7 +1282,7 @@ int ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc,
                        const EVP_MD **md, int *mac_pkey_type,
                        int *mac_secret_size, SSL_COMP **comp);
 int ssl_get_handshake_digest(int i, long *mask, const EVP_MD **md);
-int ssl_cipher_get_cert_index(const SSL_CIPHER *c);
+int ssl_cipher_get_cert_index(const SSL *s, EVP_PKEY *pkey, const SSL_CIPHER *c);
 const SSL_CIPHER *ssl_get_cipher_by_char(SSL *ssl, const unsigned char *ptr);
 int ssl_cert_set0_chain(CERT *c, STACK_OF(X509) *chain);
 int ssl_cert_set1_chain(CERT *c, STACK_OF(X509) *chain);
@@ -1347,6 +1533,8 @@ int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *p);
 int tls1_mac(SSL *ssl, unsigned char *md, int snd);
 int tls1_generate_master_secret(SSL *s, unsigned char *out,
                                 unsigned char *p, int len);
+int iqrssl_generate_hybrid_master_secret(SSL *s, unsigned char *master_secret, unsigned char *premaster_secret,
+    int premaster_secret_size, unsigned char *client_key_exchange_msg, int client_key_exchange_msg_size);
 int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
                                 const char *label, size_t llen,
                                 const unsigned char *p, size_t plen,
@@ -1366,6 +1554,13 @@ int tls1_ec_curve_id2nid(int curve_id);
 int tls1_ec_nid2curve_id(int nid);
 int tls1_check_curve(SSL *s, const unsigned char *p, size_t len);
 int tls1_shared_curve(SSL *s, int nmatch);
+int tls1_qs_keyexch_get_parameter_set(unsigned int codepoint);
+void tls1_qs_keyexch_find_shared_param(SSL *s);
+int tls1_qs_keyexch_have_shared_param(SSL *s, SSL_CIPHER *ciphersuite);
+int tls1_set_qs_keyexch_parameters(long algo_type, unsigned char **p_parameters_codepoint, size_t *p_parameters_codepoint_length,
+                    int *parameters_nid, size_t parameters_nid_length);
+int tls1_set_qs_keyexch_parameters_list(long algo_type, unsigned char **p_parameters_codepoint,
+                    size_t *p_parameters_codepoint_length, const char *str);
 int tls1_set_curves(unsigned char **pext, size_t *pextlen,
                     int *curves, size_t ncurves);
 int tls1_set_curves_list(unsigned char **pext, size_t *pextlen,
diff --git a/openssl-1.0.2r/ssl/ssl_rsa.c b/openssl-1.0.2r/ssl/ssl_rsa.c
index af03d45c..7609f051 100644
--- a/openssl-1.0.2r/ssl/ssl_rsa.c
+++ b/openssl-1.0.2r/ssl/ssl_rsa.c
@@ -62,6 +62,7 @@
 #include <openssl/objects.h>
 #include <openssl/evp.h>
 #include <openssl/x509.h>
+#include <openssl/x509v3.h>
 #include <openssl/pem.h>
 
 static int ssl_set_cert(CERT *c, X509 *x509);
@@ -231,12 +232,83 @@ static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey)
         EVP_PKEY_free(c->pkeys[i].privatekey);
     CRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);
     c->pkeys[i].privatekey = pkey;
+    c->pkeys[i].is_mpka_key = 0;
+
     c->key = &(c->pkeys[i]);
 
     c->valid = 0;
     return (1);
 }
 
+static int ssl_set_alt_pkey(CERT *c, EVP_PKEY *pkey)
+{
+    EVP_PKEY *alt_pub_key = NULL;
+    int ret = 0;
+
+    int i = ssl_cert_type(NULL, pkey);
+    if (i < 0) {
+        SSLerr(SSL_F_SSL_SET_ALT_PKEY, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+        return (0);
+    }
+
+    if (c->pkeys[i].x509 != NULL) {
+        /* Get the QS alternative PKEY. */
+
+        /*
+         * What if the cert in this cert_pkey is legitimately not an
+         * MPKAC? If it is just QS cert?
+         *
+         * In this case, this function fails (and it should), as the
+         * public key in the cert would be different from the public
+         * key in the passed-in pkey. One is a public key and the other
+         * is an ALT public key.
+         */
+        alt_pub_key = SSL_get_alt_pubkey(c->pkeys[i].x509);
+        if (alt_pub_key == NULL) {
+            SSLerr(SSL_F_SSL_SET_ALT_PKEY, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+            return (0);
+        }
+
+        /* Check if there is a cert/key mismatch. */
+        ret = EVP_PKEY_cmp(alt_pub_key, pkey);
+
+        switch (ret) {
+            case 1:
+                break;
+            case 0:
+                SSLerr(SSL_F_SSL_SET_ALT_PKEY, X509_R_KEY_VALUES_MISMATCH);
+                break;
+            case -1:
+                SSLerr(SSL_F_SSL_SET_ALT_PKEY, X509_R_KEY_TYPE_MISMATCH);
+                break;
+            case -2:
+                SSLerr(SSL_F_SSL_SET_ALT_PKEY, X509_R_UNKNOWN_KEY_TYPE);
+                break;
+        }
+
+        if (ret <= 0) {
+            EVP_PKEY_free(alt_pub_key);
+            X509_free(c->pkeys[i].x509);
+            c->pkeys[i].x509 = NULL;
+
+            return (0);
+        }
+    }
+
+    EVP_PKEY_free(alt_pub_key);
+
+    if (c->pkeys[i].privatekey != NULL) {
+        EVP_PKEY_free(c->pkeys[i].privatekey);
+    }
+
+    CRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);
+
+    c->pkeys[i].privatekey = pkey;
+    c->pkeys[i].is_mpka_key = 1;
+
+    return (1);
+}
+
 #ifndef OPENSSL_NO_RSA
 # ifndef OPENSSL_NO_STDIO
 int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)
@@ -391,8 +463,10 @@ int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)
 
 static int ssl_set_cert(CERT *c, X509 *x)
 {
-    EVP_PKEY *pkey;
-    int i;
+    EVP_PKEY *pkey = 0;
+    int i = 0;
+    int alt_pub_key_idx = -1;
+    EVP_PKEY *alt_pub_key = NULL;
 
     pkey = X509_get_pubkey(x);
     if (pkey == NULL) {
@@ -439,14 +513,81 @@ static int ssl_set_cert(CERT *c, X509 *x)
     }
 
     EVP_PKEY_free(pkey);
+    c->pkeys[i].is_mpka_cert = 0;
 
     if (c->pkeys[i].x509 != NULL)
         X509_free(c->pkeys[i].x509);
     CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
     c->pkeys[i].x509 = x;
     c->key = &(c->pkeys[i]);
-
     c->valid = 0;
+
+    alt_pub_key_idx = X509_get_ext_by_NID(x, NID_subjectAltPublicKeyInfo, -1);
+    if (alt_pub_key_idx >= 0 ) {
+        int j = -1;
+        /* Get the QS alternative PKEY. */
+        alt_pub_key = SSL_get_alt_pubkey(x);
+        if (alt_pub_key == NULL) {
+            SSLerr(SSL_F_SSL_SET_CERT, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+            return (0);
+        }
+
+        /* Mark the previous pkey (before updating the index "i"),
+         * because it also refers to an MPKAC.
+         */
+        c->pkeys[i].is_mpka_cert = 1;
+
+        j = ssl_cert_type(x, alt_pub_key);
+        if (j < 0) {
+            SSLerr(SSL_F_SSL_SET_CERT, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+            EVP_PKEY_free(alt_pub_key);
+            return (0);
+        }
+
+        if (i == j) {
+            SSLerr(SSL_F_SSL_SET_CERT, SSL_R_CERT_ALT_PUBKEY_ALG_DUPLICATE);
+            EVP_PKEY_free(alt_pub_key);
+            return (0);
+        }
+        i = j;
+
+        if (c->pkeys[i].privatekey != NULL) {
+            /* Check if there is a cert/key mismatch. */
+            int ret = EVP_PKEY_cmp(alt_pub_key, c->pkeys[i].privatekey);
+
+            switch (ret) {
+                case 1:
+                    break;
+                case 0:
+                    SSLerr(SSL_F_SSL_SET_CERT, X509_R_KEY_VALUES_MISMATCH);
+                    break;
+                case -1:
+                    SSLerr(SSL_F_SSL_SET_CERT, X509_R_KEY_TYPE_MISMATCH);
+                    break;
+                case -2:
+                    SSLerr(SSL_F_SSL_SET_CERT, X509_R_UNKNOWN_KEY_TYPE);
+                    break;
+            }
+
+            if (ret <= 0) {
+                EVP_PKEY_free(c->pkeys[i].privatekey);
+                c->pkeys[i].privatekey = NULL;
+                /* clear error queue */
+                ERR_clear_error();
+            }
+        }
+
+        EVP_PKEY_free(alt_pub_key);
+
+        if (c->pkeys[i].x509 != NULL) {
+            X509_free(c->pkeys[i].x509);
+        }
+
+        CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
+        c->pkeys[i].x509 = x;
+        c->pkeys[i].is_mpka_cert = 1;
+    }
+
     return (1);
 }
 
@@ -616,6 +757,19 @@ int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
     return (ssl_set_pkey(ctx->cert, pkey));
 }
 
+int SSL_CTX_use_ALTPrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
+{
+    if (pkey == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
+        return (0);
+    }
+    if (!ssl_cert_inst(&ctx->cert)) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY, ERR_R_MALLOC_FAILURE);
+        return (0);
+    }
+    return (ssl_set_alt_pkey(ctx->cert, pkey));
+}
+
 #ifndef OPENSSL_NO_STDIO
 int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
 {
@@ -656,6 +810,45 @@ int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
         BIO_free(in);
     return (ret);
 }
+
+int SSL_CTX_use_ALTPrivateKey_file(SSL_CTX *ctx, const char *file, int type)
+{
+    int j, ret = 0;
+    BIO *in = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    in = BIO_new(BIO_s_file_internal());
+    if (in == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, ERR_R_SYS_LIB);
+        goto end;
+    }
+    if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+
+        pkey = PEM_read_bio_ALTPrivateKey(in, NULL,
+                                          ctx->default_passwd_callback,
+                                          ctx->default_passwd_callback_userdata);
+
+    } else {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+    if (pkey == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, j);
+        goto end;
+    }
+    ret = SSL_CTX_use_ALTPrivateKey(ctx, pkey);
+    EVP_PKEY_free(pkey);
+ end:
+    if (in != NULL)
+        BIO_free(in);
+    return (ret);
+}
 #endif
 
 int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx,
@@ -676,6 +869,24 @@ int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx,
     return (ret);
 }
 
+int SSL_CTX_use_ALTPrivateKey_ASN1(int type, SSL_CTX *ctx,
+                                const unsigned char *d, long len)
+{
+    int ret = 0;
+    const unsigned char *p = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    p = d;
+    if ((pkey = d2i_PrivateKey(type, NULL, &p, (long)len)) == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
+        return (0);
+    }
+
+    ret = SSL_CTX_use_ALTPrivateKey(ctx, pkey);
+    EVP_PKEY_free(pkey);
+    return (ret);
+}
+
 #ifndef OPENSSL_NO_STDIO
 /*
  * Read a file that contains our certificate in "PEM" format, possibly
diff --git a/openssl-1.0.2r/ssl/ssl_sess.c b/openssl-1.0.2r/ssl/ssl_sess.c
index 6a5ad537..80c6112e 100644
--- a/openssl-1.0.2r/ssl/ssl_sess.c
+++ b/openssl-1.0.2r/ssl/ssl_sess.c
@@ -191,6 +191,7 @@ void *SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx)
 
 SSL_SESSION *SSL_SESSION_new(void)
 {
+    int i = 0;
     SSL_SESSION *ss;
 
     ss = (SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));
@@ -223,6 +224,11 @@ SSL_SESSION *SSL_SESSION_new(void)
 #endif
 #ifndef OPENSSL_NO_SRP
     ss->srp_username = NULL;
+#endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (i = 0; i < QS_TLS_KEY_EXCH_ALGOS_NUM; i++) {
+        ss->shared_qs_key_exch_parameters[i] = 0;
+    }
 #endif
     return (ss);
 }
@@ -233,6 +239,7 @@ SSL_SESSION *SSL_SESSION_new(void)
  */
 SSL_SESSION *ssl_session_dup(SSL_SESSION *src, int ticket)
 {
+    int i = 0;
     SSL_SESSION *dest;
 
     dest = OPENSSL_malloc(sizeof(*src));
@@ -345,6 +352,11 @@ SSL_SESSION *ssl_session_dup(SSL_SESSION *src, int ticket)
         }
     }
 #endif
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (i = 0; i < QS_TLS_KEY_EXCH_ALGOS_NUM; i++) {
+        dest->shared_qs_key_exch_parameters[i] = src->shared_qs_key_exch_parameters[i];
+    }
+#endif
 
     return dest;
 err:
diff --git a/openssl-1.0.2r/ssl/t1_enc.c b/openssl-1.0.2r/ssl/t1_enc.c
index 50491ff6..7ac887e3 100644
--- a/openssl-1.0.2r/ssl/t1_enc.c
+++ b/openssl-1.0.2r/ssl/t1_enc.c
@@ -1201,6 +1201,34 @@ int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
     return (SSL3_MASTER_SECRET_SIZE);
 }
 
+/*
+ * Create IQR hybrid master secret.
+ *
+ * Input parameters:
+ * Secret: premaster_secret
+ * Label:  "hybrid master secret"
+ * Seed:   client_random || server_random || client_key_exchange_msg
+ */
+int iqrssl_generate_hybrid_master_secret(SSL *s, unsigned char *master_secret, unsigned char *premaster_secret,
+    int premaster_secret_size, unsigned char *client_key_exchange_msg, int client_key_exchange_msg_size)
+{
+    unsigned char buf[SSL_MAX_MASTER_KEY_LENGTH];
+
+    tls1_PRF(ssl_get_algorithm2(s),
+             TLS_MD_HYBRID_MASTER_SECRET_CONST, TLS_MD_HYBRID_MASTER_SECRET_CONST_SIZE,
+             s->s3->client_random, SSL3_RANDOM_SIZE,
+             NULL, 0,
+             s->s3->server_random, SSL3_RANDOM_SIZE,
+             client_key_exchange_msg, client_key_exchange_msg_size,
+             premaster_secret, premaster_secret_size,
+             master_secret,
+             buf, sizeof(buf));
+
+    OPENSSL_cleanse(buf, sizeof(buf));
+
+    return (SSL3_MASTER_SECRET_SIZE);
+}
+
 int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
                                 const char *label, size_t llen,
                                 const unsigned char *context,
diff --git a/openssl-1.0.2r/ssl/t1_lib.c b/openssl-1.0.2r/ssl/t1_lib.c
index 8c1f3ae5..ca524c54 100644
--- a/openssl-1.0.2r/ssl/t1_lib.c
+++ b/openssl-1.0.2r/ssl/t1_lib.c
@@ -121,6 +121,21 @@
 #include <openssl/ocsp.h>
 #include <openssl/rand.h>
 #include "ssl_locl.h"
+#ifndef OPENSSL_NO_DILITHIUM
+# include <openssl/dilithium.h>
+#endif
+#ifndef OPENSSL_NO_SIDH
+# include <openssl/sidh.h>
+#endif
+#ifndef OPENSSL_NO_SIKE
+# include <openssl/sike.h>
+#endif
+#ifndef OPENSSL_NO_KYBER
+# include <openssl/kyber.h>
+#endif
+#ifndef OPENSSL_NO_NHDH
+# include <openssl/nhdh.h>
+#endif
 
 const char tls1_version_str[] = "TLSv1" OPENSSL_VERSION_PTEXT;
 
@@ -468,6 +483,8 @@ static int tls1_get_curvelist(SSL *s, int sess,
                               size_t *num_curves)
 {
     size_t pcurveslen = 0;
+    int qs_idx = 0;
+
     if (sess) {
         *pcurves = s->session->tlsext_ellipticcurvelist;
         pcurveslen = s->session->tlsext_ellipticcurvelist_length;
@@ -513,6 +530,44 @@ static int tls1_get_curvelist(SSL *s, int sess,
                 }
             }
         }
+
+        /*
+         * Since we are adding QS key exchange parameters to ECC curves array
+         * (i.e., leveraging ECC curves for QS key exchange parameters negotiation),
+         * make sure that they are always appended to the end of the array, so
+         * that they are not in the way of ECC curves matching.
+         */
+        if (s->curves_and_qs_params != NULL) {
+            OPENSSL_free(s->curves_and_qs_params);
+            s->curves_and_qs_params = NULL;
+        }
+
+        s->curves_and_qs_params = OPENSSL_malloc((pcurveslen + QS_TLS_MAX_KEY_EXCH_PARAM_NUM) * 2);
+        if (s->curves_and_qs_params == NULL) {
+            return 0;
+        }
+
+        s->curves_and_qs_params_size = (pcurveslen + QS_TLS_MAX_KEY_EXCH_PARAM_NUM) * 2;
+        memset(s->curves_and_qs_params, 0, s->curves_and_qs_params_size);
+
+        /* Copy the curves. */
+        memcpy(s->curves_and_qs_params, (*pcurves), pcurveslen);
+
+        /* Copy the QS params. */
+        for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+            if (s->qs_key_exch_parameters[qs_idx] != NULL) {
+                memcpy(s->curves_and_qs_params + pcurveslen, s->qs_key_exch_parameters[qs_idx], s->qs_key_exch_parameters_length[qs_idx]);
+
+                pcurveslen = pcurveslen + s->qs_key_exch_parameters_length[qs_idx];
+            } else {
+                memcpy(s->curves_and_qs_params + pcurveslen, SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint,
+                    SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num * 2);
+
+                pcurveslen = pcurveslen + (SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num * 2);
+            }
+        }
+
+        *pcurves = s->curves_and_qs_params;
     }
     /* We do not allow odd length arrays to enter the system. */
     if (pcurveslen & 1) {
@@ -633,6 +688,293 @@ int tls1_shared_curve(SSL *s, int nmatch)
     return NID_undef;
 }
 
+/*
+ * Map a QS key exchange algorithm parameter code point to its
+ * corresponding parameter set.
+ */
+int tls1_qs_keyexch_get_parameter_set(unsigned int codepoint)
+{
+    int qs_idx = 0;
+
+    /*
+     * Translate int code point into 2-byte form which is
+     * what OpenSSL uses for its code point tables.
+     *
+     * Code points are always encoded in big-endian format,
+     * as with pretty much all OpenSSL data.
+     */
+    unsigned char codepoint_byte[2] = { 0 };
+
+    codepoint_byte[0] = (unsigned char) ((codepoint >> 8) & 0xFF);
+    codepoint_byte[1] = (unsigned char) ((codepoint) & 0xFF);
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        int i = 0;
+        for (i = 0; i < SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num; i++) {
+            if (codepoint_byte[0] == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[2 * i] &&
+                codepoint_byte[1] == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[2 * i + 1]) {
+                return SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_internal[i];
+            }
+        }
+    }
+
+    return -1;
+}
+
+/*
+ * Find the first shared parameter between the client and the server
+ * for each QS key exchange algo that supports parameter matching.
+ *
+ * The shared parameters will be used for client-server key exchange.
+ */
+void tls1_qs_keyexch_find_shared_param(SSL *s)
+{
+    const unsigned char *received = NULL;
+    const unsigned char *preferred = NULL;
+    size_t num_received = 0;
+    size_t num_preferred = 0;
+    int qs_idx = 0;
+    int i = 0;
+    int j = 0;
+
+    if (s == NULL || s->session == NULL) {
+        return;
+    }
+
+    /*
+     * Get client's curve list, which contains QS algo parameters.
+     *
+     * Client's list is called "received", as the caller of this function is
+     * the server. On the other hand, the server's param list, containing only
+     * QS algo parameters, is called "preferred", as the server's list takes
+     * higher priority during matching.
+     */
+    if (!tls1_get_curvelist(s, 1, &received, &num_received)) {
+        return;
+    }
+
+#ifndef OPENSSL_NO_QS_KEY_EXCHANGE
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        /* Find shared parameter for a QS key exchange algo. */
+        if (s->qs_key_exch_parameters[qs_idx] != NULL) {
+            preferred = s->qs_key_exch_parameters[qs_idx];
+            num_preferred = s->qs_key_exch_parameters_length[qs_idx];
+        } else {
+            preferred = SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint;
+            num_preferred = SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num;
+        }
+
+        /* Find the first match. */
+        for (i = 0; i < num_preferred; i++) {
+            const unsigned char *tmp_received = received;
+
+            for (j = 0; j < num_received; j++) {
+                if (preferred[0] == tmp_received[0] && preferred[1] == tmp_received[1]) {
+                    /*
+                     * Big-endian encode the code point bytes into int.
+                     * This is similar to n2s(), but n2s() increments
+                     * the byte array for you, which may go out of bound
+                     * in this case.
+                     */
+                    s->session->shared_qs_key_exch_parameters[qs_idx] = (((unsigned int) tmp_received[0]) << 8) |
+                        ((unsigned int) tmp_received[1]);
+
+                    goto param_matching_done;
+                }
+
+                tmp_received += 2;
+            }
+
+            preferred += 2;
+        }
+
+param_matching_done: ; /* Semicolon to avoid "label at end of compound statement" error. */
+    }
+#endif
+
+    return;
+}
+
+/*
+ * For a ciphersuite with QS key exchange algos that support multiple
+ * parameters, check if there exists a shared parameter for each and every
+ * such key exchange algo in this ciphersuite.
+ *
+ * If any key exchange algo does not have a shared parameter, then this
+ * ciphersuite cannot be chosen for the TLS session.
+ */
+int tls1_qs_keyexch_have_shared_param(SSL *s, SSL_CIPHER *ciphersuite)
+{
+    unsigned long alg_key_exch = 0;
+    int qs_idx = 0;
+
+    if (s == NULL || s->session == NULL || ciphersuite == NULL) {
+        return 0;
+    }
+
+    /* Get the set of key exchange algos contained in the ciphersuite. */
+    alg_key_exch = ciphersuite->algorithm_mkey;
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (alg_key_exch & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            break;
+        }
+    }
+
+    if (qs_idx == QS_TLS_KEY_EXCH_ALGOS_NUM) {
+        /*
+         * For a ciphersuite that does not contain key exchange algos that have
+         * parameter matching support, this function returns true so as to allow
+         * pass-through.
+         */
+
+        return 1;
+    }
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (alg_key_exch & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            if (s->session->shared_qs_key_exch_parameters[qs_idx] == 0) {
+                return 0;
+            }
+        }
+    }
+
+    return 1;
+}
+
+int tls1_set_qs_keyexch_parameters(long algo_type, unsigned char **p_parameters_codepoint, size_t *p_parameters_codepoint_length,
+                    int *parameters_nid, size_t parameters_nid_length)
+{
+    unsigned char *codepoint_list = NULL;
+    size_t codepoint_length = 0;
+    size_t qs_idx = 0;
+
+    if (p_parameters_codepoint == NULL || p_parameters_codepoint_length == NULL || parameters_nid == NULL) {
+        return 0;
+    }
+
+    codepoint_list = OPENSSL_malloc(parameters_nid_length * 2);
+    if (!codepoint_list) {
+        return 0;
+    }
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        if (algo_type == QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+            break;
+        }
+    }
+
+    if (qs_idx != QS_TLS_KEY_EXCH_ALGOS_NUM) {
+        int i = 0;
+
+        for (i = 0; i < parameters_nid_length; i++) {
+            int j = 0;
+
+            for (j = 0; j < SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num; j++) {
+                if (parameters_nid[i] == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_nid[j]) {
+                    int k = 0;
+
+                    for (k = 0; k < codepoint_length; k = k + 2) {
+                        if (codepoint_list[k] == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[2 * j] &&
+                            codepoint_list[k + 1] == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[2 * j + 1]) {
+                            /* Found a duplicate. Skip. */
+                            goto next_nid;
+                        }
+                    }
+
+                    codepoint_list[codepoint_length] = SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[2 * j];
+                    codepoint_list[codepoint_length + 1] = SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_codepoint[2 * j + 1];
+
+                    codepoint_length += 2;
+                    break;
+                }
+            }
+
+            if (j == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num) {
+                /* Found an unsupported parameter. */
+                OPENSSL_free(codepoint_list);
+                return 0;
+            }
+next_nid: ;
+        }
+    } else {
+        OPENSSL_free(codepoint_list);
+        return 0;
+    }
+
+    if (*p_parameters_codepoint) {
+        OPENSSL_free(*p_parameters_codepoint);
+    }
+
+    *p_parameters_codepoint = codepoint_list;
+    *p_parameters_codepoint_length = codepoint_length;
+
+    return 1;
+}
+
+#define MAX_CURVELIST   28
+
+typedef struct {
+    size_t qs_nid_num;
+    int qs_nid_arr[QS_TLS_MAX_KEY_EXCH_PARAM_NUM];
+} qs_nid_cb_st;
+
+static int qs_nid_cb(const char *elem, int len, void *arg)
+{
+    qs_nid_cb_st *tmp_arg = arg;
+    size_t qs_idx = 0;
+
+    if (elem == NULL) {
+        return 0;
+    }
+
+    if (tmp_arg->qs_nid_num == QS_TLS_MAX_KEY_EXCH_PARAM_NUM) {
+        return 0;
+    }
+
+    for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+        int i = 0;
+
+        for (i = 0; i < SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_num; i++) {
+            if (strncasecmp(elem, SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_string[i], len) == 0) {
+                int j = 0;
+
+                for (j = 0; j < tmp_arg->qs_nid_num; j++) {
+                    if (tmp_arg->qs_nid_arr[j] == SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_nid[i]) {
+                        /* Found a duplicate. Skip. */
+                        return 1;
+                    }
+                }
+
+                tmp_arg->qs_nid_arr[tmp_arg->qs_nid_num++] = SUPPORTED_QS_KEY_EXCH_PARAMS[qs_idx].params_nid[i];
+                return 1;
+            }
+        }
+    }
+
+    /* Cannot find a NID for the string. */
+    return 0;
+}
+
+int tls1_set_qs_keyexch_parameters_list(long algo_type, unsigned char **p_parameters_codepoint,
+                    size_t *p_parameters_codepoint_length, const char *str)
+{
+    qs_nid_cb_st ncb;
+
+    if (p_parameters_codepoint == NULL || p_parameters_codepoint_length == NULL || str == NULL) {
+        return 0;
+    }
+
+    memset(&ncb, 0, sizeof(ncb));
+
+    if (!CONF_parse_list(str, ':', 1, qs_nid_cb, &ncb)) {
+        return 0;
+    }
+
+    return tls1_set_qs_keyexch_parameters(algo_type, p_parameters_codepoint, p_parameters_codepoint_length,
+        ncb.qs_nid_arr, ncb.qs_nid_num);
+}
+
 int tls1_set_curves(unsigned char **pext, size_t *pextlen,
                     int *curves, size_t ncurves)
 {
@@ -687,8 +1029,6 @@ int tls1_set_curves(unsigned char **pext, size_t *pextlen,
     return 1;
 }
 
-# define MAX_CURVELIST   28
-
 typedef struct {
     size_t nidcnt;
     int nid_arr[MAX_CURVELIST];
@@ -1007,6 +1347,44 @@ static int tls1_check_cert_param(SSL *s, X509 *x, int set_ee_md)
 #  define tlsext_sigalg_dsa(md) md, TLSEXT_signature_dsa,
 # endif
 
+# ifdef OPENSSL_NO_HSS
+#  define tlsext_sigalg_hss(md) /* */
+# else
+#  define tlsext_sigalg_hss(md) md, TLSEXT_signature_hss,
+# endif
+
+# ifdef OPENSSL_NO_XMSS
+#  define tlsext_sigalg_xmss(md) /* */
+# else
+#  define tlsext_sigalg_xmss(md) md, TLSEXT_signature_xmss,
+# endif
+
+# ifdef OPENSSL_NO_XMSSMT
+#  define tlsext_sigalg_xmssmt(md) /* */
+# else
+#  define tlsext_sigalg_xmssmt(md) md, TLSEXT_signature_xmssmt,
+# endif
+
+# ifdef OPENSSL_NO_DILITHIUM
+#  define tlsext_sigalg_dilithium_III_SHAKE_r2(md) /* */
+#  define tlsext_sigalg_dilithium_IV_SHAKE_r2(md) /* */
+# else
+#  define tlsext_sigalg_dilithium_III_SHAKE_r2(md) md, TLSEXT_signature_dilithium_III_SHAKE_r2,
+#  define tlsext_sigalg_dilithium_IV_SHAKE_r2(md) md, TLSEXT_signature_dilithium_IV_SHAKE_r2,
+# endif
+
+# ifdef OPENSSL_NO_CATALYST
+#  define tlsext_sigalg_catalyst(md) /* */
+# else
+/* This does not define a signature algorithm per se,
+ * but to suggest to the peer that it supports ISARA Catalyst.
+ *
+ * The paired hash algo is not used, and its purpose is to
+ * make it fit better in tls12_sigalgs.
+ */
+#  define tlsext_sigalg_catalyst(md) md, TLSEXT_signature_catalyst,
+# endif
+
 # ifdef OPENSSL_NO_ECDSA
 #  define tlsext_sigalg_ecdsa(md)
                                 /* */
@@ -1019,6 +1397,17 @@ static int tls1_check_cert_param(SSL *s, X509 *x, int set_ee_md)
                 tlsext_sigalg_dsa(md) \
                 tlsext_sigalg_ecdsa(md)
 
+/*
+ * As per ISARA TLS QS parameter negotiation design, we
+ * combine the QS parameter info with the signature algorithm.
+ *
+ * This is a bit different from how ECDSA is using the curves in
+ * TLS 1.2. The reason for our design is that it is better
+ * in-line with TLS 1.3, where the signature algorithm parameter
+ * is indeed merged with the algorithm itself, and "elliptic_curves"
+ * extension (or "named_group" extension in TLS 1.3) is only
+ * used for key exchange algorithms.
+ */
 static unsigned char tls12_sigalgs[] = {
 # ifndef OPENSSL_NO_SHA512
     tlsext_sigalg(TLSEXT_hash_sha512)
@@ -1031,6 +1420,14 @@ static unsigned char tls12_sigalgs[] = {
 # ifndef OPENSSL_NO_SHA
         tlsext_sigalg(TLSEXT_hash_sha1)
 # endif
+#ifndef OPENSSL_NO_INTRINSIC
+        tlsext_sigalg_hss(TLSEXT_hash_intrinsic)
+        tlsext_sigalg_xmss(TLSEXT_hash_intrinsic)
+        tlsext_sigalg_xmssmt(TLSEXT_hash_intrinsic)
+        tlsext_sigalg_dilithium_III_SHAKE_r2(TLSEXT_hash_intrinsic)
+        tlsext_sigalg_dilithium_IV_SHAKE_r2(TLSEXT_hash_intrinsic)
+#endif
+        tlsext_sigalg_catalyst(TLSEXT_hash_none)
 };
 
 # ifndef OPENSSL_NO_ECDSA
@@ -1161,7 +1558,7 @@ void ssl_set_client_disabled(SSL *s)
     CERT *c = s->cert;
     const unsigned char *sigalgs;
     size_t i, sigalgslen;
-    int have_rsa = 0, have_dsa = 0, have_ecdsa = 0;
+    int have_rsa = 0, have_dsa = 0, have_ecdsa = 0, have_dilithium = 0;
     c->mask_a = 0;
     c->mask_k = 0;
     /* Don't allow TLS 1.2 only ciphers if we don't suppport them */
@@ -1190,6 +1587,12 @@ void ssl_set_client_disabled(SSL *s)
         case TLSEXT_signature_ecdsa:
             have_ecdsa = 1;
             break;
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+        case TLSEXT_signature_dilithium_III_SHAKE_r2:
+        case TLSEXT_signature_dilithium_IV_SHAKE_r2:
+            have_dilithium = 1;
+            break;
 # endif
         }
     }
@@ -1205,6 +1608,9 @@ void ssl_set_client_disabled(SSL *s)
         c->mask_a |= SSL_aDSS;
         c->mask_k |= SSL_kDHd;
     }
+    if (!have_dilithium) {
+        c->mask_a |= SSL_aDILITHIUM;
+    }
     if (!have_ecdsa) {
         c->mask_a |= SSL_aECDSA;
         c->mask_k |= SSL_kECDHe;
@@ -1240,8 +1646,9 @@ unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
 # ifndef OPENSSL_NO_EC
     /* See if we support any ECC ciphersuites */
     int using_ecc = 0;
+    int using_qs_key_exch = 0;
     if (s->version >= TLS1_VERSION || SSL_IS_DTLS(s)) {
-        int i;
+        int i, qs_idx;
         unsigned long alg_k, alg_a;
         STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);
 
@@ -1256,6 +1663,22 @@ unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
                 break;
             }
         }
+
+        for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {
+            SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);
+            alg_k = c->algorithm_mkey;
+
+            for (qs_idx = 0; qs_idx < QS_TLS_KEY_EXCH_ALGOS_NUM; qs_idx++) {
+                if (alg_k & QS_TLS_KEY_EXCH_ALGOS[QS_TLS_KEY_EXCH_SSL_MASK][qs_idx]) {
+                    using_qs_key_exch = 1;
+                    break;
+                }
+            }
+
+            if (using_qs_key_exch == 1) {
+                break;
+            }
+        }
     }
 # endif
 
@@ -1354,8 +1777,8 @@ unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
         /*
          * Add TLS extension ECPointFormats to the ClientHello message
          */
-        const unsigned char *pcurves, *pformats;
-        size_t num_curves, num_formats, curves_list_len;
+        const unsigned char *pformats;
+        size_t num_formats;
 
         tls1_get_formatlist(s, &pformats, &num_formats);
 
@@ -1378,10 +1801,15 @@ unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
         *(ret++) = (unsigned char)num_formats;
         memcpy(ret, pformats, num_formats);
         ret += num_formats;
+    }
 
+    if (using_ecc || using_qs_key_exch) {
         /*
          * Add TLS extension EllipticCurves to the ClientHello message
          */
+        const unsigned char *pcurves = NULL;
+        size_t num_curves = 0;
+        size_t curves_list_len = 0;
         pcurves = s->tlsext_ellipticcurvelist;
         if (!tls1_get_curvelist(s, 0, &pcurves, &num_curves))
             return NULL;
@@ -1444,6 +1872,12 @@ unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
     if (SSL_CLIENT_USE_SIGALGS(s)) {
         size_t salglen;
         const unsigned char *salg;
+
+        /*
+         * This will put "tls12_sigalgs" array into
+         * client hello extension. This array contains
+         * QS sig algos with parameters.
+         */
         salglen = tls12_get_psigalgs(s, 1, &salg);
 
         /*-
@@ -3644,13 +4078,25 @@ static tls12_lookup tls12_md[] = {
     {NID_sha224, TLSEXT_hash_sha224},
     {NID_sha256, TLSEXT_hash_sha256},
     {NID_sha384, TLSEXT_hash_sha384},
-    {NID_sha512, TLSEXT_hash_sha512}
+    {NID_sha512, TLSEXT_hash_sha512},
+    {NID_undef, TLSEXT_hash_intrinsic}
+
 };
 
+/*
+ * The last two entries for Dilithium can only be used
+ * for find_nid, but not for find_id, because it is clearly
+ * not a function mapping.
+ */
 static tls12_lookup tls12_sig[] = {
     {EVP_PKEY_RSA, TLSEXT_signature_rsa},
     {EVP_PKEY_DSA, TLSEXT_signature_dsa},
-    {EVP_PKEY_EC, TLSEXT_signature_ecdsa}
+    {EVP_PKEY_EC, TLSEXT_signature_ecdsa},
+    {EVP_PKEY_HSS, TLSEXT_signature_hss},
+    {EVP_PKEY_XMSS, TLSEXT_signature_xmss},
+    {EVP_PKEY_XMSSMT, TLSEXT_signature_xmssmt},
+    {EVP_PKEY_DILITHIUM, TLSEXT_signature_dilithium_III_SHAKE_r2},
+    {EVP_PKEY_DILITHIUM, TLSEXT_signature_dilithium_IV_SHAKE_r2},
 };
 
 static int tls12_find_id(int nid, tls12_lookup *table, size_t tlen)
@@ -3693,8 +4139,24 @@ int tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk,
 
 int tls12_get_sigid(const EVP_PKEY *pk)
 {
-    return tls12_find_id(pk->type, tls12_sig,
-                         sizeof(tls12_sig) / sizeof(tls12_lookup));
+    int sig_id = 0;
+
+#ifndef OPENSSL_NO_DILITHIUM
+    if (pk->type == EVP_PKEY_DILITHIUM) {
+        if (pk->pkey.dilithium->parameter_set == DILITHIUM_III_SHAKE_R2) {
+            sig_id = TLSEXT_signature_dilithium_III_SHAKE_r2;
+        } else if (pk->pkey.dilithium->parameter_set == DILITHIUM_IV_SHAKE_R2) {
+            sig_id = TLSEXT_signature_dilithium_IV_SHAKE_r2;
+        } else {
+            return 0;
+        }
+    } else
+#endif
+    {
+        sig_id = tls12_find_id(pk->type, tls12_sig, sizeof(tls12_sig) / sizeof(tls12_lookup));
+    }
+
+    return sig_id;
 }
 
 static int tls12_get_hash_nid(unsigned char hash_alg)
@@ -3731,6 +4193,11 @@ const EVP_MD *tls12_get_hash(unsigned char hash_alg)
 
     case TLSEXT_hash_sha512:
         return EVP_sha512();
+# endif
+# ifndef OPENSSL_NO_INTRINSIC
+    case TLSEXT_hash_intrinsic:
+        /* This does not just return a NULL pointer. */
+        return EVP_md_null();
 # endif
     default:
         return NULL;
@@ -3752,6 +4219,24 @@ static int tls12_get_pkey_idx(unsigned char sig_alg)
 # ifndef OPENSSL_NO_ECDSA
     case TLSEXT_signature_ecdsa:
         return SSL_PKEY_ECC;
+# endif
+# ifndef OPENSSL_NO_HSS
+    case TLSEXT_signature_hss:
+        return SSL_PKEY_HSS;
+# endif
+# ifndef OPENSSL_NO_XMSS
+    case TLSEXT_signature_xmss:
+        return SSL_PKEY_XMSS;
+# endif
+# ifndef OPENSSL_NO_XMSSMT
+    case TLSEXT_signature_xmssmt:
+        return SSL_PKEY_XMSSMT;
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+    case TLSEXT_signature_dilithium_III_SHAKE_r2:
+        return SSL_PKEY_DILITHIUM_III_SHAKE_R2;
+    case TLSEXT_signature_dilithium_IV_SHAKE_r2:
+        return SSL_PKEY_DILITHIUM_IV_SHAKE_R2;
 # endif
     }
     return -1;
@@ -3777,7 +4262,10 @@ static void tls1_lookup_sigalg(int *phash_nid, int *psign_nid,
             *psign_nid = sign_nid;
     }
     if (psignhash_nid) {
-        if (sign_nid == NID_undef || hash_nid == NID_undef
+        /* We allow the condition of hash_nid being NID_undef becasuse that
+         * indicates "intrinsic" which is new.
+         */
+        if (sign_nid == NID_undef
                 || OBJ_find_sigid_by_algs(psignhash_nid, hash_nid,
                                           sign_nid) <= 0)
             *psignhash_nid = NID_undef;
@@ -3804,6 +4292,17 @@ static int tls12_do_shared_sigalgs(TLS_SIGALGS *shsig,
                 if (shsig) {
                     shsig->rhash = ptmp[0];
                     shsig->rsign = ptmp[1];
+
+                    /*
+                     * Let's also explicitly set the parameter set NID in TLS_SIGALGS,
+                     * even though the rsign value implies what it is.
+                     */
+                    if (ptmp[1] == TLSEXT_signature_dilithium_III_SHAKE_r2) {
+                        shsig->sign_parameter_set_nid = NID_Dilithium_III_SHAKE_r2;
+                    } else if (ptmp[1] == TLSEXT_signature_dilithium_IV_SHAKE_r2) {
+                        shsig->sign_parameter_set_nid = NID_Dilithium_IV_SHAKE_r2;
+                    }
+
                     tls1_lookup_sigalg(&shsig->hash_nid,
                                        &shsig->sign_nid,
                                        &shsig->signandhash_nid, ptmp);
@@ -3868,6 +4367,7 @@ static int tls1_set_shared_sigalgs(SSL *s)
 
 int tls1_save_sigalgs(SSL *s, const unsigned char *data, int dsize)
 {
+    int i = 0;
     CERT *c = s->cert;
     /* Extension ignored for inappropriate versions */
     if (!SSL_USE_SIGALGS(s))
@@ -3878,6 +4378,17 @@ int tls1_save_sigalgs(SSL *s, const unsigned char *data, int dsize)
 
     if (c->peer_sigalgs)
         OPENSSL_free(c->peer_sigalgs);
+
+    for (i = 0; i < dsize; i += 2) {
+        /* If the peer supports Catalyst, there should be an entry that is
+         * TLSEXT_signature_catalyst. It serves as a signal rather than specifying
+         * a signing algorithm, and it is OK to be copied to c->peer_sigalgs.
+         */
+        if (data[i+1] == TLSEXT_signature_catalyst) {
+            c->peer_mpkac_support = 1;
+        }
+    }
+
     c->peer_sigalgs = OPENSSL_malloc(dsize);
     if (!c->peer_sigalgs)
         return 0;
@@ -3930,8 +4441,31 @@ int tls1_process_sigalgs(SSL *s)
             ERR_set_mark();
             if (EVP_PKEY_get_default_digest_nid(s->cert->pkeys[idx].privatekey,
                                                 &mandatory_mdnid) == 2 &&
-                mandatory_mdnid != tls12_get_hash_nid(sigptr->rhash))
+                mandatory_mdnid != tls12_get_hash_nid(sigptr->rhash)) {
+
+                /* The default MD for Dilithium has been changed to NID_undef.
+                 * Therefore, we need to populate Dilithium's pkeys entry with
+                 * MD corresponding to the shared sig_and_hash.
+                 *
+                 * This only needs to be done for OpenSSL 1.0.2r, as 1.0.2q does
+                 * not have this logic.
+                 *
+                 * Dilithium is the only QS signature algorithm that can sign
+                 * TLS handshake messages, and therefore we only need to do this for
+                 * Dilithium at the moment.
+                 *
+                 * This will likely need to be updated when implementing full-message
+                 * signing for TLS handshake. (T4246)
+                 */
+                if ((idx == SSL_PKEY_DILITHIUM_III_SHAKE_R2 || idx == SSL_PKEY_DILITHIUM_IV_SHAKE_R2) &&
+                    c->pkeys[idx].digest == NULL) {
+                    md = tls12_get_hash(sigptr->rhash);
+                    c->pkeys[idx].digest = md;
+                    c->pkeys[idx].valid_flags = CERT_PKEY_EXPLICIT_SIGN;
+                }
+
                 continue;
+            }
             /*
              * If EVP_PKEY_get_default_digest_nid() failed, don't pollute
              * the error stack.
@@ -3972,6 +4506,13 @@ int tls1_process_sigalgs(SSL *s)
 # ifndef OPENSSL_NO_ECDSA
         if (!c->pkeys[SSL_PKEY_ECC].digest)
             c->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();
+# endif
+# ifndef OPENSSL_NO_DILITHIUM
+        if (!c->pkeys[SSL_PKEY_DILITHIUM_III_SHAKE_R2].digest)
+            c->pkeys[SSL_PKEY_DILITHIUM_III_SHAKE_R2].digest = EVP_sha512();
+
+        if (!c->pkeys[SSL_PKEY_DILITHIUM_IV_SHAKE_R2].digest)
+            c->pkeys[SSL_PKEY_DILITHIUM_IV_SHAKE_R2].digest = EVP_sha512();
 # endif
     }
     return 1;
@@ -4209,6 +4750,14 @@ static int sig_cb(const char *elem, int len, void *arg)
         sig_alg = EVP_PKEY_RSA;
     else if (!strcmp(etmp, "DSA"))
         sig_alg = EVP_PKEY_DSA;
+    else if (!strcmp(etmp, "HSS"))
+        sig_alg = EVP_PKEY_HSS;
+    else if (!strcmp(etmp, "XMSS"))
+        sig_alg = EVP_PKEY_XMSS;
+    else if (!strcmp(etmp, "XMSSMT"))
+        sig_alg = EVP_PKEY_XMSSMT;
+    else if (!strcmp(etmp, "DITLIHUM"))
+        sig_alg = EVP_PKEY_DILITHIUM;
     else if (!strcmp(etmp, "ECDSA"))
         sig_alg = EVP_PKEY_EC;
     else
@@ -4250,6 +4799,7 @@ int tls1_set_sigalgs(CERT *c, const int *psig_nids, size_t salglen,
     unsigned char *sigalgs, *sptr;
     int rhash, rsign;
     size_t i;
+    size_t salglen_tmp = salglen;
     if (salglen & 1)
         return 0;
     sigalgs = OPENSSL_malloc(salglen);
@@ -4258,8 +4808,29 @@ int tls1_set_sigalgs(CERT *c, const int *psig_nids, size_t salglen,
     for (i = 0, sptr = sigalgs; i < salglen; i += 2) {
         rhash = tls12_find_id(*psig_nids++, tls12_md,
                               sizeof(tls12_md) / sizeof(tls12_lookup));
-        rsign = tls12_find_id(*psig_nids++, tls12_sig,
-                              sizeof(tls12_sig) / sizeof(tls12_lookup));
+
+#ifndef OPENSSL_NO_DILITHIUM
+        if (*psig_nids == EVP_PKEY_DILITHIUM) {
+            // Dilithium has two algorithm IDs, one for each parameter set.
+            salglen_tmp += 2;
+
+            if (OPENSSL_realloc(sigalgs, salglen_tmp) == NULL) {
+                goto err;
+            }
+
+            *sptr++ = rhash;
+            *sptr++ = TLSEXT_signature_dilithium_III_SHAKE_r2;
+
+            rsign = TLSEXT_signature_dilithium_IV_SHAKE_r2;
+
+        } else
+#endif
+        {
+            rsign = tls12_find_id(*psig_nids, tls12_sig,
+                                  sizeof(tls12_sig) / sizeof(tls12_lookup));
+        }
+
+        psig_nids++;
 
         if (rhash == -1 || rsign == -1)
             goto err;
@@ -4271,12 +4842,12 @@ int tls1_set_sigalgs(CERT *c, const int *psig_nids, size_t salglen,
         if (c->client_sigalgs)
             OPENSSL_free(c->client_sigalgs);
         c->client_sigalgs = sigalgs;
-        c->client_sigalgslen = salglen;
+        c->client_sigalgslen = salglen_tmp;
     } else {
         if (c->conf_sigalgs)
             OPENSSL_free(c->conf_sigalgs);
         c->conf_sigalgs = sigalgs;
-        c->conf_sigalgslen = salglen;
+        c->conf_sigalgslen = salglen_tmp;
     }
 
     return 1;
@@ -4290,14 +4861,83 @@ static int tls1_check_sig_alg(CERT *c, X509 *x, int default_nid)
 {
     int sig_nid;
     size_t i;
+
+    int alt_sig_alg_ind = -1;
+    X509_EXTENSION *alt_sig_alg_ext = NULL;
+    X509_ALGOR *alt_sig_alg = NULL;
+    int alt_sig_nid = -1;
+    int is_supported = 1;
+
     if (default_nid == -1)
         return 1;
+
     sig_nid = X509_get_signature_nid(x);
-    if (default_nid)
-        return sig_nid == default_nid ? 1 : 0;
-    for (i = 0; i < c->shared_sigalgslen; i++)
-        if (sig_nid == c->shared_sigalgs[i].signandhash_nid)
+
+    // See if the certificate contains an alternative signature algorithm extension.
+    alt_sig_alg_ind = X509_get_ext_by_NID(x, NID_altSignatureAlgorithm, -1);
+
+    if (alt_sig_alg_ind >= 0) {
+        // Get the certificate's alternative signature algorithm extension.
+        alt_sig_alg_ext = X509_get_ext(x, alt_sig_alg_ind);
+        if (alt_sig_alg_ext == NULL) {
+            return 0;
+        }
+
+        // Convert the certificate's alternative signature algorithm extension into internal representation.
+        alt_sig_alg = X509V3_EXT_d2i(alt_sig_alg_ext);
+        if (alt_sig_alg == NULL) {
+            return 0;
+        }
+
+        // This NID is the sig-and-hash.
+        alt_sig_nid = OBJ_obj2nid(alt_sig_alg->algorithm);
+    }
+
+    if (default_nid) {
+        if (sig_nid == default_nid) {
+            if (alt_sig_nid >= 0) {
+                // check if the alternative signature algorithm is supported by
+                // both the client and the server.
+
+                for (i = 0; i < c->shared_sigalgslen; i++) {
+                    if (alt_sig_nid == c->shared_sigalgs[i].signandhash_nid) {
+                        return 1;
+                    }
+                }
+
+                return 0;
+            }
+
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+
+    if (alt_sig_nid >= 0) {
+        is_supported = 0;
+
+        // check if the alternative signature algorithm is supported by
+        // both the client and the server.
+        for (i = 0; i < c->shared_sigalgslen; i++) {
+            if (alt_sig_nid == c->shared_sigalgs[i].signandhash_nid) {
+                is_supported = 1;
+            }
+        }
+    }
+
+    if (is_supported == 0) {
+        return 0;
+    }
+
+    for (i = 0; i < c->shared_sigalgslen; i++) {
+        // check if the classic signature algorithm is supported by
+        // both the client and the server.
+        if (sig_nid == c->shared_sigalgs[i].signandhash_nid) {
             return 1;
+        }
+    }
+
     return 0;
 }
 
@@ -4418,6 +5058,31 @@ int tls1_check_chain(SSL *s, X509 *x, EVP_PKEY *pk, STACK_OF(X509) *chain,
                 default_nid = NID_ecdsa_with_SHA1;
                 break;
 
+            case SSL_PKEY_HSS:
+                rsign = TLSEXT_signature_hss;
+                default_nid = NID_hss;
+                break;
+
+            case SSL_PKEY_XMSS:
+                rsign = TLSEXT_signature_xmss;
+                default_nid = NID_xmss;
+                break;
+
+            case SSL_PKEY_XMSSMT:
+                rsign = TLSEXT_signature_xmssmt;
+                default_nid = NID_xmssmt;
+                break;
+
+            case SSL_PKEY_DILITHIUM_III_SHAKE_R2:
+                rsign = TLSEXT_signature_dilithium_III_SHAKE_r2;
+                default_nid = NID_dilithium;
+                break;
+
+            case SSL_PKEY_DILITHIUM_IV_SHAKE_R2:
+                rsign = TLSEXT_signature_dilithium_IV_SHAKE_r2;
+                default_nid = NID_dilithium;
+                break;
+
             default:
                 default_nid = -1;
                 break;
@@ -4496,6 +5161,9 @@ int tls1_check_chain(SSL *s, X509 *x, EVP_PKEY *pk, STACK_OF(X509) *chain,
         case EVP_PKEY_EC:
             check_type = TLS_CT_ECDSA_SIGN;
             break;
+        case EVP_PKEY_DILITHIUM:
+            check_type = TLS_CT_DILITHIUM_SIGN;
+            break;
         case EVP_PKEY_DH:
         case EVP_PKEY_DHX:
             {
@@ -4588,6 +5256,12 @@ void tls1_set_cert_validity(SSL *s)
     tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DH_RSA);
     tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DH_DSA);
     tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_ECC);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_HSS);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_XMSS);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_XMSSMT);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DILITHIUM_III_SHAKE_R2);
+    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DILITHIUM_IV_SHAKE_R2);
+
 }
 
 /* User level utiity function to check a chain is suitable */
diff --git a/openssl-1.0.2r/ssl/t1_trce.c b/openssl-1.0.2r/ssl/t1_trce.c
index 3e6194a5..d14279a7 100644
--- a/openssl-1.0.2r/ssl/t1_trce.c
+++ b/openssl-1.0.2r/ssl/t1_trce.c
@@ -333,6 +333,30 @@ static ssl_trace_tbl ssl_ciphers_tbl[] = {
     {0xC030, "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"},
     {0xC031, "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"},
     {0xC032, "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF07, "TLS_ECDHE_NHDH_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF08, "TLS_ECDHE_NHDH_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF10, "TLS_ECDHE_SIDH_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF11, "TLS_ECDHE_SIDH_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF12, "TLS_ECDHE_NHDH_SIDH_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF13, "TLS_ECDHE_NHDH_SIDH_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF14, "TLS_ECDHE_NHDH_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF15, "TLS_ECDHE_SIDH_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF16, "TLS_ECDHE_NHDH_SIDH_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF17, "TLS_ECDHE_SIKE_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF18, "TLS_ECDHE_KYBER_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF19, "TLS_ECDHE_SIKE_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF1A, "TLS_ECDHE_KYBER_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF1B, "TLS_ECDHE_SIKE_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF1C, "TLS_ECDHE_KYBER_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF1D, "TLS_ECDHE_KYBER_SIKE_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF1E, "TLS_ECDHE_KYBER_SIKE_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF1F, "TLS_ECDHE_KYBER_SIKE_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF20, "TLS_KYBER_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF21, "TLS_KYBER_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF22, "TLS_KYBER_RSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF23, "TLS_SIKE_DILM_WITH_AES_256_GCM_SHA384"},
+    {0xFF24, "TLS_SIKE_ECDSA_WITH_AES_256_GCM_SHA384"},
+    {0xFF25, "TLS_SIKE_RSA_WITH_AES_256_GCM_SHA384"},
     {0xFEFE, "SSL_RSA_FIPS_WITH_DES_CBC_SHA"},
     {0xFEFF, "SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"},
 };
@@ -399,6 +423,13 @@ static ssl_trace_tbl ssl_curve_tbl[] = {
     {26, "brainpoolP256r1"},
     {27, "brainpoolP384r1"},
     {28, "brainpoolP512r1"},
+    {0xFE00, "sidh_p503_r2"},
+    {0xFE07, "sidh_p751_r2"},
+    {0xFE02, "sike_p503_r2"},
+    {0xFE03, "sike_p751_r2"},
+    {0xFE04, "kyber_768_r2"},
+    {0xFE05, "kyber_1024_r2"},
+    {0xFE06, "newhope_1024_v0"},
     {0xFF01, "arbitrary_explicit_prime_curves"},
     {0xFF02, "arbitrary_explicit_char2_curves"}
 };
@@ -423,7 +454,13 @@ static ssl_trace_tbl ssl_sig_tbl[] = {
     {0, "anonymous"},
     {1, "rsa"},
     {2, "dsa"},
-    {3, "ecdsa"}
+    {3, "ecdsa"},
+    {224, "catalyst"},
+    {225, "dilithiumA"},
+    {226, "dilithiumB"},
+    {227, "hss"},
+    {228, "xmss"},
+    {229, "xmssmt"}
 };
 
 static ssl_trace_tbl ssl_hb_tbl[] = {
@@ -444,6 +481,10 @@ static ssl_trace_tbl ssl_ctype_tbl[] = {
     {5, "rsa_ephemeral_dh"},
     {6, "dss_ephemeral_dh"},
     {20, "fortezza_dms"},
+    {32, "hss_sign"},
+    {33, "dilithium_sign"},
+    {34, "xmss_sign"},
+    {35, "xmssmt_sign"},
     {64, "ecdsa_sign"},
     {65, "rsa_fixed_ecdh"},
     {66, "ecdsa_fixed_ecdh"}
@@ -815,6 +856,22 @@ static int ssl_get_keyex(const char **pname, SSL *ssl)
         *pname = "GOST";
         return SSL_kGOST;
     }
+    if (alg_k & SSL_kENHDH) {
+        *pname = "ENHDH";
+        return SSL_kENHDH;
+    }
+    if (alg_k & SSL_kESIDH) {
+        *pname = "ESIDH";
+        return SSL_kESIDH;
+    }
+    if (alg_k & SSL_kEKYBER) {
+        *pname = "EKYBER";
+        return SSL_kEKYBER;
+    }
+    if (alg_k & SSL_kESIKE) {
+        *pname = "ESIKE";
+        return SSL_kESIKE;
+    }
     *pname = "UNKNOWN";
     return 0;
 }
diff --git a/openssl-1.0.2r/ssl/tls1.h b/openssl-1.0.2r/ssl/tls1.h
index dd1d8c10..34802503 100644
--- a/openssl-1.0.2r/ssl/tls1.h
+++ b/openssl-1.0.2r/ssl/tls1.h
@@ -279,8 +279,16 @@ extern "C" {
 # define TLSEXT_signature_dsa                            2
 # define TLSEXT_signature_ecdsa                          3
 
+/* Signature and hash algorithms from ISARA */
+# define TLSEXT_signature_catalyst                       224
+# define TLSEXT_signature_dilithium_III_SHAKE_r2         225
+# define TLSEXT_signature_dilithium_IV_SHAKE_r2          226
+# define TLSEXT_signature_hss                            227
+# define TLSEXT_signature_xmss                           228
+# define TLSEXT_signature_xmssmt                         229
+
 /* Total number of different signature algorithms */
-# define TLSEXT_signature_num                            4
+# define TLSEXT_signature_num                            10
 
 # define TLSEXT_hash_none                                0
 # define TLSEXT_hash_md5                                 1
@@ -289,10 +297,13 @@ extern "C" {
 # define TLSEXT_hash_sha256                              4
 # define TLSEXT_hash_sha384                              5
 # define TLSEXT_hash_sha512                              6
+# define TLSEXT_hash_intrinsic                           8
 
 /* Total number of different digest algorithms */
-
-# define TLSEXT_hash_num                                 7
+/* Note that this is not used as a loop index. It is used to put an upper
+ * limit on the size of an array.
+ */
+# define TLSEXT_hash_num                                 8
 
 /* Flag set for unrecognised algorithms */
 # define TLSEXT_nid_unknown                              0x1000000
@@ -563,6 +574,32 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB,(void (*)(void))cb)
 # define TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256        0x0300C031
 # define TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384        0x0300C032
 
+/* ISARA QS schemes */
+# define TLS1_CK_ECDHE_NHDH_RSA_WITH_AES_256_GCM_SHA384         0x0300FF07
+# define TLS1_CK_ECDHE_NHDH_ECDSA_WITH_AES_256_GCM_SHA384       0x0300FF08
+# define TLS1_CK_ECDHE_SIDH_RSA_WITH_AES_256_GCM_SHA384         0x0300FF10
+# define TLS1_CK_ECDHE_SIDH_ECDSA_WITH_AES_256_GCM_SHA384       0x0300FF11
+# define TLS1_CK_ECDHE_NHDH_SIDH_RSA_WITH_AES_256_GCM_SHA384    0x0300FF12
+# define TLS1_CK_ECDHE_NHDH_SIDH_ECDSA_WITH_AES_256_GCM_SHA384  0x0300FF13
+# define TLS1_CK_ECDHE_NHDH_DILM_WITH_AES_256_GCM_SHA384        0x0300FF14
+# define TLS1_CK_ECDHE_SIDH_DILM_WITH_AES_256_GCM_SHA384        0x0300FF15
+# define TLS1_CK_ECDHE_NHDH_SIDH_DILM_WITH_AES_256_GCM_SHA384   0x0300FF16
+# define TLS1_CK_ECDHE_SIKE_ECDSA_WITH_AES_256_GCM_SHA384       0x0300FF17
+# define TLS1_CK_ECDHE_KYBER_ECDSA_WITH_AES_256_GCM_SHA384      0x0300FF18
+# define TLS1_CK_ECDHE_SIKE_RSA_WITH_AES_256_GCM_SHA384         0x0300FF19
+# define TLS1_CK_ECDHE_KYBER_RSA_WITH_AES_256_GCM_SHA384        0x0300FF1A
+# define TLS1_CK_ECDHE_SIKE_DILM_WITH_AES_256_GCM_SHA384        0x0300FF1B
+# define TLS1_CK_ECDHE_KYBER_DILM_WITH_AES_256_GCM_SHA384       0x0300FF1C
+# define TLS1_CK_ECDHE_KYBER_SIKE_DILM_WITH_AES_256_GCM_SHA384  0x0300FF1D
+# define TLS1_CK_ECDHE_KYBER_SIKE_ECDSA_WITH_AES_256_GCM_SHA384 0x0300FF1E
+# define TLS1_CK_ECDHE_KYBER_SIKE_RSA_WITH_AES_256_GCM_SHA384   0x0300FF1F
+# define TLS1_CK_KYBER_DILM_WITH_AES_256_GCM_SHA384             0x0300FF20
+# define TLS1_CK_KYBER_ECDSA_WITH_AES_256_GCM_SHA384            0x0300FF21
+# define TLS1_CK_KYBER_RSA_WITH_AES_256_GCM_SHA384              0x0300FF22
+# define TLS1_CK_SIKE_DILM_WITH_AES_256_GCM_SHA384              0x0300FF23
+# define TLS1_CK_SIKE_ECDSA_WITH_AES_256_GCM_SHA384             0x0300FF24
+# define TLS1_CK_SIKE_RSA_WITH_AES_256_GCM_SHA384               0x0300FF25
+
 /*
  * XXX * Backward compatibility alert: + * Older versions of OpenSSL gave
  * some DHE ciphers names with "EDH" + * instead of "DHE".  Going forward, we
@@ -713,6 +750,32 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB,(void (*)(void))cb)
 # define TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256       "ECDH-RSA-AES128-GCM-SHA256"
 # define TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384       "ECDH-RSA-AES256-GCM-SHA384"
 
+/* ISARA QS schemes */
+# define TLS1_TXT_ECDHE_NHDH_RSA_WITH_AES_256_GCM_SHA384            "ECDHE-NHDH-RSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_NHDH_ECDSA_WITH_AES_256_GCM_SHA384          "ECDHE-NHDH-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_SIDH_RSA_WITH_AES_256_GCM_SHA384            "ECDHE-SIDH-RSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_SIDH_ECDSA_WITH_AES_256_GCM_SHA384          "ECDHE-SIDH-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_NHDH_SIDH_RSA_WITH_AES_256_GCM_SHA384       "ECDHE-NHDH-SIDH-RSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_NHDH_SIDH_ECDSA_WITH_AES_256_GCM_SHA384     "ECDHE-NHDH-SIDH-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_NHDH_DILM_WITH_AES_256_GCM_SHA384           "ECDHE-NHDH-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_SIDH_DILM_WITH_AES_256_GCM_SHA384           "ECDHE-SIDH-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_NHDH_SIDH_DILM_WITH_AES_256_GCM_SHA384      "ECDHE-NHDH-SIDH-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_SIKE_ECDSA_WITH_AES_256_GCM_SHA384          "ECDHE-SIKE-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_KYBER_ECDSA_WITH_AES_256_GCM_SHA384         "ECDHE-KYBER-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_SIKE_RSA_WITH_AES_256_GCM_SHA384            "ECDHE-SIKE-RSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_KYBER_RSA_WITH_AES_256_GCM_SHA384           "ECDHE-KYBER-RSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_SIKE_DILM_WITH_AES_256_GCM_SHA384           "ECDHE-SIKE-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_KYBER_DILM_WITH_AES_256_GCM_SHA384          "ECDHE-KYBER-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_KYBER_SIKE_DILM_WITH_AES_256_GCM_SHA384     "ECDHE-KYBER-SIKE-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_KYBER_SIKE_ECDSA_WITH_AES_256_GCM_SHA384    "ECDHE-KYBER-SIKE-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_ECDHE_KYBER_SIKE_RSA_WITH_AES_256_GCM_SHA384      "ECDHE-KYBER-SIKE-RSA-AES256-GCM-SHA384"
+# define TLS1_TXT_KYBER_DILM_WITH_AES_256_GCM_SHA384                "KYBER-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_KYBER_ECDSA_WITH_AES_256_GCM_SHA384               "KYBER-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_KYBER_RSA_WITH_AES_256_GCM_SHA384                 "KYBER-RSA-AES256-GCM-SHA384"
+# define TLS1_TXT_SIKE_DILM_WITH_AES_256_GCM_SHA384                 "SIKE-DILM-AES256-GCM-SHA384"
+# define TLS1_TXT_SIKE_ECDSA_WITH_AES_256_GCM_SHA384                "SIKE-ECDSA-AES256-GCM-SHA384"
+# define TLS1_TXT_SIKE_RSA_WITH_AES_256_GCM_SHA384                  "SIKE-RSA-AES256-GCM-SHA384"
+
 # define TLS_CT_RSA_SIGN                 1
 # define TLS_CT_DSS_SIGN                 2
 # define TLS_CT_RSA_FIXED_DH             3
@@ -722,11 +785,13 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB,(void (*)(void))cb)
 # define TLS_CT_ECDSA_FIXED_ECDH         66
 # define TLS_CT_GOST94_SIGN              21
 # define TLS_CT_GOST01_SIGN              22
+# define TLS_CT_DILITHIUM_SIGN           224
+
 /*
  * when correcting this number, correct also SSL3_CT_NUMBER in ssl3.h (see
  * comment there)
  */
-# define TLS_CT_NUMBER                   9
+# define TLS_CT_NUMBER                   12
 
 # define TLS1_FINISH_MAC_LENGTH          12
 
@@ -747,6 +812,8 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB,(void (*)(void))cb)
 # define TLS_MD_IV_BLOCK_CONST_SIZE              8
 # define TLS_MD_MASTER_SECRET_CONST              "master secret"
 # define TLS_MD_MASTER_SECRET_CONST_SIZE         13
+# define TLS_MD_HYBRID_MASTER_SECRET_CONST       "hybrid master secret"
+# define TLS_MD_HYBRID_MASTER_SECRET_CONST_SIZE  20
 
 # ifdef CHARSET_EBCDIC
 #  undef TLS_MD_CLIENT_FINISH_CONST
diff --git a/openssl-1.0.2r/test/testssl b/openssl-1.0.2r/test/testssl
index 8bea40a4..6afc3bfa 100644
--- a/openssl-1.0.2r/test/testssl
+++ b/openssl-1.0.2r/test/testssl
@@ -10,7 +10,8 @@ if [ "$2" = "" ]; then
 else
   cert="$2"
 fi
-ssltest="../util/shlib_wrap.sh ./ssltest -key $key -cert $cert -c_key $key -c_cert $cert"
+
+ssltest="../util/shlib_wrap.sh ./ssltest -key $key -cert $cert -c_key $key -c_cert $cert -cipher "ECDHE:DHE:RSA""
 
 if ../util/shlib_wrap.sh ../apps/openssl x509 -in $cert -text -noout | fgrep 'DSA Public Key' >/dev/null; then
   dsa_cert=YES
@@ -189,7 +190,8 @@ for protocol in TLSv1.2 SSLv3; do
   if ../util/shlib_wrap.sh ../apps/openssl no-ec; then
     echo "skipping RSA+ECDHE tests"
   else
-    for cipher in `../util/shlib_wrap.sh ../apps/openssl ciphers "EECDH+aRSA+$protocol:-EXP" | tr ':' ' '`; do
+  # Ignore ECDHE-NHDH, ECDHE-SIDH, ECDHE-NHDH-SIDH, ECDHE-KYBER, ECDHE-SIKE, and ECDHE-KYBER-SIKE hybrid schemes.
+    for cipher in `../util/shlib_wrap.sh ../apps/openssl ciphers "EECDH+aRSA+$protocol:!ECDHE-NHDH:!ECDHE-SIDH:!ECDHE-NHDH-SIDH:!ECDHE-KYBER:!ECDHE-SIKE:!ECDHE-KYBER-SIKE:-EXP" | tr ':' ' '`; do
       test_cipher $cipher $protocol
     done
   fi
diff --git a/openssl-1.0.2r/test/testsslproxy b/openssl-1.0.2r/test/testsslproxy
index 58bbda8a..178f4327 100644
--- a/openssl-1.0.2r/test/testsslproxy
+++ b/openssl-1.0.2r/test/testsslproxy
@@ -4,7 +4,7 @@ echo 'Testing a lot of proxy conditions.'
 echo 'Some of them may turn out being invalid, which is fine.'
 for auth in A B C BC; do
     for cond in A B C 'A|B&!C'; do
-	sh ./testssl $1 $2 $3 "-proxy -proxy_auth $auth -proxy_cond $cond"
+	sh ./testssl $1 $2 $3 "-proxy -proxy_auth $auth -proxy_cond $cond" $4 $5
 	if [ $? = 3 ]; then exit 1; fi
     done
 done
diff --git a/openssl-1.0.2r/util/libeay.num b/openssl-1.0.2r/util/libeay.num
index 2e522140..edef016d 100755
--- a/openssl-1.0.2r/util/libeay.num
+++ b/openssl-1.0.2r/util/libeay.num
@@ -4432,3 +4432,341 @@ EVP_PKEY_meth_get_cleanup               4786	EXIST::FUNCTION:
 EVP_PKEY_meth_get_encrypt               4787	EXIST::FUNCTION:
 EVP_PKEY_meth_get_copy                  4788	EXIST::FUNCTION:
 ossl_safe_getenv                        4789	EXIST::FUNCTION:
+i2d_KYBERPublicKey                      4790	EXIST::FUNCTION:KYBER
+PEM_read_bio_ALTPrivateKey              4791	EXIST::FUNCTION:
+PEM_read_XMSSMTPrivateKey               4792	EXIST:!WIN16:FUNCTION:XMSSMT
+d2i_NTRUPPrivateKey                     4793	EXIST::FUNCTION:NTRUP
+NTRUP_new                               4794	EXIST::FUNCTION:NTRUP
+d2i_SIDHPublicKey                       4795	EXIST::FUNCTION:SIDH
+i2d_XMSSMTPublicKey                     4796	EXIST::FUNCTION:XMSSMT
+d2i_KemInfo                             4797	EXIST::FUNCTION:
+EVP_PKEY_set1_FRODODH                   4798	EXIST::FUNCTION:FRODODH
+d2i_HSS_PUBKEY_fp                       4799	EXIST::FUNCTION:FP_API,HSS
+i2d_NTRUPKemInfo                        4800	EXIST::FUNCTION:NTRUP
+i2d_XMSSPublicKey                       4801	EXIST::FUNCTION:XMSS
+CMS_RecipientInfo_keri_get0_orig_id     4802	NOEXIST::FUNCTION:
+d2i_RAINBOWPrivateKey                   4803	EXIST::FUNCTION:RAINBOW
+i2d_XMSSPrivateKey_fp                   4804	EXIST::FUNCTION:FP_API,XMSS
+KYBER_new_with_engine                   4805	EXIST::FUNCTION:KYBER
+ASN1_get_sigparam                       4806	EXIST::FUNCTION:EVP
+d2i_CMCPrivateKey                       4807	EXIST::FUNCTION:CMC
+CMS_RecipientInfo_keri_set0_pkey        4808	NOEXIST::FUNCTION:
+EVP_PKEY_get1_RAINBOW                   4809	EXIST::FUNCTION:RAINBOW
+i2d_SIKEPublicKey                       4810	EXIST::FUNCTION:SIKE
+i2d_XMSS_PUBKEY                         4811	EXIST::FUNCTION:XMSS
+i2d_XMSSMTPrivateKey                    4812	EXIST::FUNCTION:XMSSMT
+i2d_CMS_KEMParameter                    4813	NOEXIST::FUNCTION:
+d2i_SPHINCSPrivateKey_bio               4814	EXIST::FUNCTION:BIO,SPHINCS
+PEM_read_bio_SPHINCSPrivateKey          4815	EXIST::FUNCTION:SPHINCS
+PEM_read_bio_RAINBOWPrivateKey          4816	EXIST::FUNCTION:RAINBOW
+CMS_KEMParameter_free                   4817	NOEXIST::FUNCTION:
+RAINBOW_free                            4818	EXIST::FUNCTION:RAINBOW
+SIDH_new_with_engine                    4819	EXIST::FUNCTION:SIDH
+PEM_read_bio_HSS_PUBKEY                 4820	EXIST::FUNCTION:HSS
+PEM_write_bio_SPHINCS_PUBKEY            4821	EXIST::FUNCTION:SPHINCS
+SIKE_free                               4822	EXIST::FUNCTION:SIKE
+PEM_read_bio_RAINBOW_PUBKEY             4823	EXIST::FUNCTION:RAINBOW
+i2d_SPHINCSPrivateKey_bio               4824	EXIST::FUNCTION:BIO,SPHINCS
+i2d_CMCKemInfo                          4825	EXIST::FUNCTION:CMC
+EVP_PKEY_get1_XMSSMT                    4826	EXIST::FUNCTION:XMSSMT
+EVP_PKEY_set1_NTRUP                     4827	EXIST::FUNCTION:NTRUP
+ERR_load_XMSS_strings                   4828	EXIST::FUNCTION:XMSS
+ERR_load_SIKE_strings                   4829	EXIST::FUNCTION:SIKE
+SPHINCS_up_ref                          4830	EXIST::FUNCTION:SPHINCS
+EVP_PKEY_set1_XMSS                      4831	EXIST::FUNCTION:XMSS
+X509_PCINF_new                          4832	EXIST::FUNCTION:
+KYBER_set_ex_data                       4833	EXIST::FUNCTION:KYBER
+SPHINCS_new                             4834	EXIST::FUNCTION:SPHINCS
+EVP_PKEY_set1_CMC                       4835	EXIST::FUNCTION:CMC
+PEM_write_SPHINCS_PUBKEY                4836	EXIST:!WIN16:FUNCTION:SPHINCS
+ERR_load_NH_strings                     4837	NOEXIST::FUNCTION:
+PEM_read_bio_DILITHIUMPrivateKey        4838	EXIST::FUNCTION:DILITHIUM
+d2i_RAINBOW_PUBKEY                      4839	EXIST::FUNCTION:RAINBOW
+i2d_FRODOKEMKemInfo                     4840	EXIST::FUNCTION:FRODOKEM
+XMSSMT_free                             4841	EXIST::FUNCTION:XMSSMT
+d2i_RAINBOWPrivateKey_bio               4842	EXIST::FUNCTION:BIO,RAINBOW
+i2d_SPHINCSPrivateKey_fp                4843	EXIST::FUNCTION:FP_API,SPHINCS
+ERR_load_CMC_strings                    4844	EXIST::FUNCTION:CMC
+CMS_KEMParameter_it                     4845	NOEXIST::FUNCTION:
+CMS_KEMParameter_it                     4845	NOEXIST::FUNCTION:
+i2d_FRODOKEMPrivateKey                  4846	EXIST::FUNCTION:FRODOKEM
+d2i_SIKEPrivateKey                      4847	EXIST::FUNCTION:SIKE
+PEM_read_DILITHIUM_PUBKEY               4848	EXIST:!WIN16:FUNCTION:DILITHIUM
+d2i_SPHINCS_PUBKEY                      4849	EXIST::FUNCTION:SPHINCS
+NTRUP_free                              4850	EXIST::FUNCTION:NTRUP
+PEM_write_XMSSPrivateKey                4851	EXIST:!WIN16:FUNCTION:XMSS
+PEM_write_HSSPrivateKey                 4852	EXIST:!WIN16:FUNCTION:HSS
+d2i_RAINBOWPrivateKey_fp                4853	EXIST::FUNCTION:FP_API,RAINBOW
+PEM_read_SPHINCS_PUBKEY                 4854	EXIST:!WIN16:FUNCTION:SPHINCS
+PEM_read_HSSPrivateKey                  4855	EXIST:!WIN16:FUNCTION:HSS
+d2i_KYBERPublicKey                      4856	EXIST::FUNCTION:KYBER
+CMC_up_ref                              4857	EXIST::FUNCTION:CMC
+EVP_PKEY_get1_CMC                       4858	EXIST::FUNCTION:CMC
+EVP_PKEY_get1_XMSS                      4859	EXIST::FUNCTION:XMSS
+PEM_write_bio_HSS_PUBKEY                4860	EXIST::FUNCTION:HSS
+d2i_XMSSPrivateKey_fp                   4861	EXIST::FUNCTION:FP_API,XMSS
+d2i_XMSSMTPrivateKey_bio                4862	EXIST::FUNCTION:BIO,XMSSMT
+KYBER_get_ex_new_index                  4863	EXIST::FUNCTION:KYBER
+XMSSMT_new_with_engine                  4864	EXIST::FUNCTION:XMSSMT
+NTRUP_set_ex_data                       4865	EXIST::FUNCTION:NTRUP
+d2i_SUBJECT_ALT_PUBLIC_KEY_INFO         4866	EXIST::FUNCTION:
+ERR_load_RAINBOW_strings                4867	EXIST::FUNCTION:RAINBOW
+PEM_write_XMSSMTPrivateKey              4868	EXIST:!WIN16:FUNCTION:XMSSMT
+DILITHIUM_free                          4869	EXIST::FUNCTION:DILITHIUM
+i2d_X509_PCINF                          4870	EXIST::FUNCTION:
+PEM_write_bio_XMSSPrivateKey            4871	EXIST::FUNCTION:XMSS
+EVP_PKEY_set1_SIKE                      4872	EXIST::FUNCTION:SIKE
+d2i_HSS_PUBKEY                          4873	EXIST::FUNCTION:HSS
+d2i_CMS_KEMParameter                    4874	NOEXIST::FUNCTION:
+EVP_PKEY_get1_HSS                       4875	EXIST::FUNCTION:HSS
+d2i_FRODOKEMKemInfo                     4876	EXIST::FUNCTION:FRODOKEM
+PEM_write_bio_XMSS_PUBKEY               4877	EXIST::FUNCTION:XMSS
+PEM_read_RAINBOW_PUBKEY                 4878	EXIST:!WIN16:FUNCTION:RAINBOW
+d2i_FRODOKEMPrivateKey                  4879	EXIST::FUNCTION:FRODOKEM
+d2i_SIKEKemInfo                         4880	EXIST::FUNCTION:SIKE
+CMS_GenericHybridParameters_new         4881	NOEXIST::FUNCTION:
+KYBER_new                               4882	EXIST::FUNCTION:KYBER
+d2i_CMS_GenericHybridParameters         4883	NOEXIST::FUNCTION:
+d2i_RAINBOWPublicKey                    4884	EXIST::FUNCTION:RAINBOW
+HSS_new_with_engine                     4885	EXIST::FUNCTION:HSS
+i2d_CMS_GenericHybridParameters         4886	NOEXIST::FUNCTION:
+i2d_SPHINCSPrivateKey                   4887	EXIST::FUNCTION:SPHINCS
+NH_new                                  4888	NOEXIST::FUNCTION:
+SIDH_up_ref                             4889	EXIST::FUNCTION:SIDH
+X509_get_alt_pubkey                     4890	EXIST::FUNCTION:
+CMS_RecipientInfo_keri_get0_ctx         4891	NOEXIST::FUNCTION:
+X509_check_alt_private_key              4892	EXIST::FUNCTION:
+PEM_write_bio_XMSSMTPrivateKey          4893	EXIST::FUNCTION:XMSSMT
+PEM_write_DILITHIUM_PUBKEY              4894	EXIST:!WIN16:FUNCTION:DILITHIUM
+PEM_write_XMSS_PUBKEY                   4895	EXIST:!WIN16:FUNCTION:XMSS
+X509_PCINF_free                         4896	EXIST::FUNCTION:
+d2i_DILITHIUM_PUBKEY                    4897	EXIST::FUNCTION:DILITHIUM
+PEM_write_bio_HSSPrivateKey             4898	EXIST::FUNCTION:HSS
+CMC_set_ex_data                         4899	EXIST::FUNCTION:CMC
+EVP_PKEY_get1_DILITHIUM                 4900	EXIST::FUNCTION:DILITHIUM
+PEM_write_bio_XMSSMT_PUBKEY             4901	EXIST::FUNCTION:XMSSMT
+i2d_XMSSMT_PUBKEY_bio                   4902	EXIST::FUNCTION:BIO,XMSSMT
+PEM_write_SPHINCSPrivateKey             4903	EXIST:!WIN16:FUNCTION:SPHINCS
+PEM_read_XMSS_PUBKEY                    4904	EXIST:!WIN16:FUNCTION:XMSS
+d2i_SPHINCSPrivateKey                   4905	EXIST::FUNCTION:SPHINCS
+FRODOKEM_free                           4906	EXIST::FUNCTION:FRODOKEM
+i2d_HSSPublicKey                        4907	EXIST::FUNCTION:HSS
+CMS_RecipientInfo_keri_decrypt          4908	NOEXIST::FUNCTION:
+i2d_SPHINCSPublicKey                    4909	EXIST::FUNCTION:SPHINCS
+d2i_HSSPrivateKey_fp                    4910	EXIST::FUNCTION:FP_API,HSS
+d2i_SPHINCS_PUBKEY_fp                   4911	EXIST::FUNCTION:FP_API,SPHINCS
+i2d_DILITHIUMPrivateKey_fp              4912	EXIST::FUNCTION:DILITHIUM,FP_API
+i2d_HSS_PUBKEY_bio                      4913	EXIST::FUNCTION:BIO,HSS
+d2i_XMSSMTPublicKey                     4914	EXIST::FUNCTION:XMSSMT
+FRODOKEM_set_ex_data                    4915	EXIST::FUNCTION:FRODOKEM
+HSS_free                                4916	EXIST::FUNCTION:HSS
+ERR_load_DILITHIUM_strings              4917	EXIST::FUNCTION:DILITHIUM
+PEM_write_RAINBOWPrivateKey             4918	EXIST:!WIN16:FUNCTION:RAINBOW
+ERR_load_XMSSMT_strings                 4919	EXIST::FUNCTION:XMSSMT
+PEM_read_RAINBOWPrivateKey              4920	EXIST:!WIN16:FUNCTION:RAINBOW
+d2i_XMSSMTPrivateKey                    4921	EXIST::FUNCTION:XMSSMT
+EVP_PKEY_set1_FRODOKEM                  4922	EXIST::FUNCTION:FRODOKEM
+EVP_PKEY_set1_KYBER                     4923	EXIST::FUNCTION:KYBER
+i2d_HSS_PUBKEY_fp                       4924	EXIST::FUNCTION:FP_API,HSS
+PEM_read_bio_XMSSPrivateKey             4925	EXIST::FUNCTION:XMSS
+SPHINCS_free                            4926	EXIST::FUNCTION:SPHINCS
+i2d_HSSPrivateKey_bio                   4927	EXIST::FUNCTION:BIO,HSS
+d2i_SIKEPublicKey                       4928	EXIST::FUNCTION:SIKE
+PEM_write_RAINBOW_PUBKEY                4929	EXIST:!WIN16:FUNCTION:RAINBOW
+d2i_NTRUPPublicKey                      4930	EXIST::FUNCTION:NTRUP
+d2i_NHPublicKey                         4931	NOEXIST::FUNCTION:
+CMC_new_with_engine                     4932	EXIST::FUNCTION:CMC
+SIKE_up_ref                             4933	EXIST::FUNCTION:SIKE
+d2i_HSSPrivateKey_bio                   4934	EXIST::FUNCTION:BIO,HSS
+RAINBOW_new_with_engine                 4935	EXIST::FUNCTION:RAINBOW
+SIKE_get_ex_new_index                   4936	EXIST::FUNCTION:SIKE
+ERR_load_FRODOKEM_strings               4937	EXIST::FUNCTION:FRODOKEM
+d2i_HSSPublicKey                        4938	EXIST::FUNCTION:HSS
+PEM_read_bio_XMSSMTPrivateKey           4939	EXIST::FUNCTION:XMSSMT
+PEM_read_XMSSPrivateKey                 4940	EXIST:!WIN16:FUNCTION:XMSS
+i2d_SIDHPublicKey                       4941	EXIST::FUNCTION:SIDH
+i2d_XMSSMTPrivateKey_fp                 4942	EXIST::FUNCTION:FP_API,XMSSMT
+i2d_DILITHIUM_PUBKEY                    4943	EXIST::FUNCTION:DILITHIUM
+i2d_SPHINCS_PUBKEY                      4944	EXIST::FUNCTION:SPHINCS
+SUBJECT_ALT_PUBLIC_KEY_INFO_it          4945	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
+SUBJECT_ALT_PUBLIC_KEY_INFO_it          4945	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+d2i_SPHINCSPublicKey                    4946	EXIST::FUNCTION:SPHINCS
+d2i_RAINBOW_PUBKEY_fp                   4947	EXIST::FUNCTION:FP_API,RAINBOW
+d2i_XMSSMT_PUBKEY_fp                    4948	EXIST::FUNCTION:FP_API,XMSSMT
+XMSSMT_up_ref                           4949	EXIST::FUNCTION:XMSSMT
+NTRUP_get_ex_data                       4950	EXIST::FUNCTION:NTRUP
+i2d_XMSSPrivateKey                      4951	EXIST::FUNCTION:XMSS
+CMS_SignerInfo_set1_altpriv             4952	EXIST::FUNCTION:CMS
+PEM_read_bio_XMSS_PUBKEY                4953	EXIST::FUNCTION:XMSS
+CMC_free                                4954	EXIST::FUNCTION:CMC
+i2d_DILITHIUMPrivateKey                 4955	EXIST::FUNCTION:DILITHIUM
+XMSSMT_new                              4956	EXIST::FUNCTION:XMSSMT
+d2i_HSS_PUBKEY_bio                      4957	EXIST::FUNCTION:BIO,HSS
+i2d_XMSSMT_PUBKEY_fp                    4958	EXIST::FUNCTION:FP_API,XMSSMT
+i2d_FRODOKEMPublicKey                   4959	EXIST::FUNCTION:FRODOKEM
+ERR_load_SPHINCS_strings                4960	EXIST::FUNCTION:SPHINCS
+PEM_write_bio_DILITHIUM_PUBKEY          4961	EXIST::FUNCTION:DILITHIUM
+i2d_SPHINCS_PUBKEY_fp                   4962	EXIST::FUNCTION:FP_API,SPHINCS
+d2i_CMCKemInfo                          4963	EXIST::FUNCTION:CMC
+i2d_HSSPrivateKey                       4964	EXIST::FUNCTION:HSS
+d2i_XMSS_PUBKEY_bio                     4965	EXIST::FUNCTION:BIO,XMSS
+PEM_write_HSS_PUBKEY                    4966	EXIST:!WIN16:FUNCTION:HSS
+i2o_PublicKey                           4967	EXIST::FUNCTION:
+d2i_DILITHIUMPrivateKey_bio             4968	EXIST::FUNCTION:BIO,DILITHIUM
+EVP_PKEY_get1_KYBER                     4969	EXIST::FUNCTION:KYBER
+d2i_XMSSPublicKey                       4970	EXIST::FUNCTION:XMSS
+CMS_GenericHybridParameters_it          4971	NOEXIST::FUNCTION:
+CMS_GenericHybridParameters_it          4971	NOEXIST::FUNCTION:
+d2i_FRODODHPublicKey                    4972	EXIST::FUNCTION:
+X509_PCINF_it                           4973	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
+X509_PCINF_it                           4973	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+i2d_XMSSPrivateKey_bio                  4974	EXIST::FUNCTION:BIO,XMSS
+d2i_FRODOKEMPublicKey                   4975	EXIST::FUNCTION:FRODOKEM
+i2d_XMSS_PUBKEY_fp                      4976	EXIST::FUNCTION:FP_API,XMSS
+CMC_new                                 4977	EXIST::FUNCTION:CMC
+SUBJECT_ALT_PUBLIC_KEY_INFO_new         4978	EXIST::FUNCTION:
+i2d_RAINBOWPrivateKey_bio               4979	EXIST::FUNCTION:BIO,RAINBOW
+EVP_PKEY_set1_DILITHIUM                 4980	EXIST::FUNCTION:DILITHIUM
+CMS_SignerInfo_altsign                  4981	EXIST::FUNCTION:CMS
+PEM_read_bio_XMSSMT_PUBKEY              4982	EXIST::FUNCTION:XMSSMT
+i2d_HSSPrivateKey_fp                    4983	EXIST::FUNCTION:FP_API,HSS
+i2d_KYBERKemInfo                        4984	EXIST::FUNCTION:KYBER
+FRODODH_new                             4985	EXIST::FUNCTION:
+i2d_NHPublicKey                         4986	NOEXIST::FUNCTION:
+d2i_XMSSMT_PUBKEY                       4987	EXIST::FUNCTION:XMSSMT
+NTRUP_up_ref                            4988	EXIST::FUNCTION:NTRUP
+EVP_PKEY_get1_NTRUP                     4989	EXIST::FUNCTION:NTRUP
+FRODOKEM_up_ref                         4990	EXIST::FUNCTION:FRODOKEM
+i2d_RAINBOW_PUBKEY                      4991	EXIST::FUNCTION:RAINBOW
+i2d_SPHINCS_PUBKEY_bio                  4992	EXIST::FUNCTION:BIO,SPHINCS
+i2d_DILITHIUMPrivateKey_bio             4993	EXIST::FUNCTION:BIO,DILITHIUM
+i2d_KYBERPrivateKey                     4994	EXIST::FUNCTION:KYBER
+d2i_NTRUPKemInfo                        4995	EXIST::FUNCTION:NTRUP
+NTRUP_new_with_engine                   4996	EXIST::FUNCTION:NTRUP
+CMS_SignerInfo_altverify                4997	EXIST::FUNCTION:CMS
+PEM_write_DILITHIUMPrivateKey           4998	EXIST:!WIN16:FUNCTION:DILITHIUM
+FRODODH_new_with_engine                 4999	EXIST::FUNCTION:
+i2d_RAINBOWPrivateKey                   5000	EXIST::FUNCTION:RAINBOW
+FRODODH_free                            5001	EXIST::FUNCTION:
+DILITHIUM_new_with_engine               5002	EXIST::FUNCTION:DILITHIUM
+CMS_KEMParameter_new                    5003	NOEXIST::FUNCTION:
+XMSS_free                               5004	EXIST::FUNCTION:XMSS
+XMSS_up_ref                             5005	EXIST::FUNCTION:XMSS
+PEM_read_bio_SPHINCS_PUBKEY             5006	EXIST::FUNCTION:SPHINCS
+EVP_PKEY_get1_SPHINCS                   5007	EXIST::FUNCTION:SPHINCS
+i2d_SIKEKemInfo                         5008	EXIST::FUNCTION:SIKE
+EVP_PKEY_get1_FRODODH                   5009	EXIST::FUNCTION:FRODODH
+i2d_SUBJECT_ALT_PUBLIC_KEY_INFO         5010	EXIST::FUNCTION:
+KYBER_get_ex_data                       5011	EXIST::FUNCTION:KYBER
+ERR_load_HSS_strings                    5012	EXIST::FUNCTION:HSS
+d2i_DILITHIUM_PUBKEY_fp                 5013	EXIST::FUNCTION:DILITHIUM,FP_API
+ERR_load_NTRUP_strings                  5014	EXIST::FUNCTION:NTRUP
+i2d_DILITHIUM_PUBKEY_fp                 5015	EXIST::FUNCTION:DILITHIUM,FP_API
+FRODODH_up_ref                          5016	EXIST::FUNCTION:
+PEM_read_HSS_PUBKEY                     5017	EXIST:!WIN16:FUNCTION:HSS
+i2d_FRODODHPublicKey                    5018	EXIST::FUNCTION:
+NH_free                                 5019	NOEXIST::FUNCTION:
+PEM_write_bio_RAINBOW_PUBKEY            5020	EXIST::FUNCTION:RAINBOW
+d2i_XMSS_PUBKEY                         5021	EXIST::FUNCTION:XMSS
+NH_up_ref                               5022	NOEXIST::FUNCTION:
+d2i_DILITHIUMPublicKey                  5023	EXIST::FUNCTION:DILITHIUM
+EVP_PKEY_set1_HSS                       5024	EXIST::FUNCTION:HSS
+EVP_PKEY_get1_FRODOKEM                  5025	EXIST::FUNCTION:FRODOKEM
+d2i_CMCPublicKey                        5026	EXIST::FUNCTION:CMC
+NTRUP_get_ex_new_index                  5027	EXIST::FUNCTION:NTRUP
+i2d_DILITHIUM_PUBKEY_bio                5028	EXIST::FUNCTION:BIO,DILITHIUM
+d2i_SPHINCS_PUBKEY_bio                  5029	EXIST::FUNCTION:BIO,SPHINCS
+KYBER_up_ref                            5030	EXIST::FUNCTION:KYBER
+SIKE_set_ex_data                        5031	EXIST::FUNCTION:SIKE
+CMC_get_ex_new_index                    5032	EXIST::FUNCTION:CMC
+i2d_XMSSMT_PUBKEY                       5033	EXIST::FUNCTION:XMSSMT
+d2i_DILITHIUM_PUBKEY_bio                5034	EXIST::FUNCTION:BIO,DILITHIUM
+CMC_get_ex_data                         5035	EXIST::FUNCTION:CMC
+ERR_load_FRODODH_strings                5036	EXIST::FUNCTION:
+i2d_RAINBOW_PUBKEY_fp                   5037	EXIST::FUNCTION:FP_API,RAINBOW
+PEM_write_bio_ALT_PKCS8PrivateKey       5038	EXIST::FUNCTION:
+PEM_write_bio_SPHINCSPrivateKey         5039	EXIST::FUNCTION:SPHINCS
+i2d_NTRUPPublicKey                      5040	EXIST::FUNCTION:NTRUP
+EVP_PKEY_get1_SIKE                      5041	EXIST::FUNCTION:SIKE
+i2d_CMCPublicKey                        5042	EXIST::FUNCTION:CMC
+i2d_NTRUPPrivateKey                     5043	EXIST::FUNCTION:NTRUP
+RAINBOW_up_ref                          5044	EXIST::FUNCTION:RAINBOW
+ERR_load_KYBER_strings                  5045	EXIST::FUNCTION:KYBER
+PEM_read_XMSSMT_PUBKEY                  5046	EXIST:!WIN16:FUNCTION:XMSSMT
+PEM_write_bio_DILITHIUMPrivateKey       5047	EXIST::FUNCTION:DILITHIUM
+HSS_new                                 5048	EXIST::FUNCTION:HSS
+i2d_RAINBOW_PUBKEY_bio                  5049	EXIST::FUNCTION:BIO,RAINBOW
+d2i_KYBERKemInfo                        5050	EXIST::FUNCTION:KYBER
+PEM_read_bio_HSSPrivateKey              5051	EXIST::FUNCTION:HSS
+EVP_PKEY_set1_RAINBOW                   5052	EXIST::FUNCTION:RAINBOW
+EVP_PKEY_set1_SPHINCS                   5053	EXIST::FUNCTION:SPHINCS
+o2i_PublicKey                           5054	EXIST::FUNCTION:
+i2d_SIKEPrivateKey                      5055	EXIST::FUNCTION:SIKE
+XMSS_new                                5056	EXIST::FUNCTION:XMSS
+i2d_XMSS_PUBKEY_bio                     5057	EXIST::FUNCTION:BIO,XMSS
+SIDH_free                               5058	EXIST::FUNCTION:SIDH
+SIDH_new                                5059	EXIST::FUNCTION:SIDH
+d2i_RAINBOW_PUBKEY_bio                  5060	EXIST::FUNCTION:BIO,RAINBOW
+DILITHIUM_up_ref                        5061	EXIST::FUNCTION:DILITHIUM
+i2d_XMSSMTPrivateKey_bio                5062	EXIST::FUNCTION:BIO,XMSSMT
+XMSS_new_with_engine                    5063	EXIST::FUNCTION:XMSS
+FRODOKEM_new                            5064	EXIST::FUNCTION:FRODOKEM
+i2d_KemInfo                             5065	EXIST::FUNCTION:
+SIKE_new_with_engine                    5066	EXIST::FUNCTION:SIKE
+PEM_write_XMSSMT_PUBKEY                 5067	EXIST:!WIN16:FUNCTION:XMSSMT
+d2i_DILITHIUMPrivateKey                 5068	EXIST::FUNCTION:DILITHIUM
+KYBER_free                              5069	EXIST::FUNCTION:KYBER
+d2i_XMSSMTPrivateKey_fp                 5070	EXIST::FUNCTION:FP_API,XMSSMT
+RAINBOW_new                             5071	EXIST::FUNCTION:RAINBOW
+d2i_SPHINCSPrivateKey_fp                5072	EXIST::FUNCTION:FP_API,SPHINCS
+i2d_DILITHIUMPublicKey                  5073	EXIST::FUNCTION:DILITHIUM
+d2i_KYBERPrivateKey                     5074	EXIST::FUNCTION:KYBER
+d2i_XMSSMT_PUBKEY_bio                   5075	EXIST::FUNCTION:BIO,XMSSMT
+d2i_XMSSPrivateKey_bio                  5076	EXIST::FUNCTION:BIO,XMSS
+SUBJECT_ALT_PUBLIC_KEY_INFO_free        5077	EXIST::FUNCTION:
+HSS_up_ref                              5078	EXIST::FUNCTION:HSS
+FRODOKEM_get_ex_data                    5079	EXIST::FUNCTION:FRODOKEM
+SIKE_get_ex_data                        5080	EXIST::FUNCTION:SIKE
+EVP_PKEY_set1_XMSSMT                    5081	EXIST::FUNCTION:XMSSMT
+SIKE_new                                5082	EXIST::FUNCTION:SIKE
+i2d_HSS_PUBKEY                          5083	EXIST::FUNCTION:HSS
+FRODOKEM_new_with_engine                5084	EXIST::FUNCTION:FRODOKEM
+CMS_GenericHybridParameters_free        5085	NOEXIST::FUNCTION:
+d2i_HSSPrivateKey                       5086	EXIST::FUNCTION:HSS
+CMS_RecipientInfo_keri_set_shared_info  5087	NOEXIST::FUNCTION:
+i2d_RAINBOWPublicKey                    5088	EXIST::FUNCTION:RAINBOW
+ERR_load_SIDH_strings                   5089	EXIST::FUNCTION:SIDH
+PEM_write_bio_RAINBOWPrivateKey         5090	EXIST::FUNCTION:RAINBOW
+SPHINCS_new_with_engine                 5091	EXIST::FUNCTION:SPHINCS
+PEM_read_DILITHIUMPrivateKey            5092	EXIST:!WIN16:FUNCTION:DILITHIUM
+FRODOKEM_get_ex_new_index               5093	EXIST::FUNCTION:FRODOKEM
+DILITHIUM_new                           5094	EXIST::FUNCTION:DILITHIUM
+PEM_read_SPHINCSPrivateKey              5095	EXIST:!WIN16:FUNCTION:SPHINCS
+d2i_DILITHIUMPrivateKey_fp              5096	EXIST::FUNCTION:DILITHIUM,FP_API
+d2i_XMSS_PUBKEY_fp                      5097	EXIST::FUNCTION:FP_API,XMSS
+d2i_X509_PCINF                          5098	EXIST::FUNCTION:
+NH_new_with_engine                      5099	NOEXIST::FUNCTION:
+PEM_read_bio_DILITHIUM_PUBKEY           5100	EXIST::FUNCTION:DILITHIUM
+i2d_RAINBOWPrivateKey_fp                5101	EXIST::FUNCTION:FP_API,RAINBOW
+i2d_CMCPrivateKey                       5102	EXIST::FUNCTION:CMC
+d2i_XMSSPrivateKey                      5103	EXIST::FUNCTION:XMSS
+NHDH_up_ref                             5104	EXIST::FUNCTION:
+NHDH_free                               5105	EXIST::FUNCTION:
+ERR_load_NHDH_strings                   5106	EXIST::FUNCTION:
+i2d_NHDHPublicKey                       5107	EXIST::FUNCTION:
+d2i_NHDHPublicKey                       5108	EXIST::FUNCTION:
+NHDH_new_with_engine                    5109	EXIST::FUNCTION:
+NHDH_new                                5110	EXIST::FUNCTION:
+d2i_SAMWISEPublicKey                    5111	EXIST::FUNCTION:
+ERR_load_SAMWISE_strings                5112	EXIST::FUNCTION:
+i2d_SAMWISEPublicKey                    5113	EXIST::FUNCTION:
+SAMWISE_new                             5114	EXIST::FUNCTION:
+SAMWISE_up_ref                          5115	EXIST::FUNCTION:
+EVP_PKEY_get1_SAMWISE                   5116	EXIST::FUNCTION:SAMWISE
+EVP_PKEY_get_cms_digest_nid             5117	EXIST::FUNCTION:
+BIO_f_store                             5118	EXIST::FUNCTION:
+EVP_PKEY_set1_SAMWISE                   5119	EXIST::FUNCTION:SAMWISE
+SAMWISE_free                            5120	EXIST::FUNCTION:
+SAMWISE_new_with_engine                 5121	EXIST::FUNCTION:
+o2i_KemInfo                             5122	EXIST::FUNCTION:
+i2o_KemInfo                             5123	EXIST::FUNCTION:
diff --git a/openssl-1.0.2r/util/mkdef.pl b/openssl-1.0.2r/util/mkdef.pl
index b9b159a0..da165571 100755
--- a/openssl-1.0.2r/util/mkdef.pl
+++ b/openssl-1.0.2r/util/mkdef.pl
@@ -88,6 +88,11 @@ my @known_algorithms = ( "RC2", "RC4", "RC5", "IDEA", "DES", "BF",
 			 "HMAC", "AES", "CAMELLIA", "SEED", "GOST",
 			 # EC_NISTP_64_GCC_128
 			 "EC_NISTP_64_GCC_128",
+			 # Post-quantum algorithms
+			 "CMC", "DILITHIUM", "FRODODH", "FRODOKEM",
+			 "HSS", "KYBER",
+			 "NHDH", "NTRUP", "RAINBOW", "SAMWISE",
+			 "SIDH","SIKE", "SPHINCS", "XMSS", "XMSSMT",
 			 # Envelope "algorithms"
 			 "EVP", "X509", "ASN1_TYPEDEFS",
 			 # Helper "algorithms"
@@ -312,6 +317,22 @@ $crypto.=" crypto/aes/aes.h" ; # unless $no_aes;
 $crypto.=" crypto/camellia/camellia.h" ; # unless $no_camellia;
 $crypto.=" crypto/seed/seed.h"; # unless $no_seed;
 
+$crypto.=" crypto/cmc/cmc.h";
+$crypto.=" crypto/dilithium/dilithium.h";
+$crypto.=" crypto/frododh/frododh.h";
+$crypto.=" crypto/frodokem/frodokem.h";
+$crypto.=" crypto/hss/hss.h";
+$crypto.=" crypto/kyber/kyber.h";
+$crypto.=" crypto/nhdh/nhdh.h";
+$crypto.=" crypto/ntrup/ntrup.h";
+$crypto.=" crypto/rainbow/rainbow.h";
+$crypto.=" crypto/samwise/samwise.h";
+$crypto.=" crypto/sidh/sidh.h";
+$crypto.=" crypto/sike/sike.h";
+$crypto.=" crypto/sphincs/sphincs.h";
+$crypto.=" crypto/xmss/xmss.h";
+$crypto.=" crypto/xmssmt/xmssmt.h";
+
 $crypto.=" crypto/bn/bn.h";
 $crypto.=" crypto/rsa/rsa.h" ; # unless $no_rsa;
 $crypto.=" crypto/dsa/dsa.h" ; # unless $no_dsa;
diff --git a/openssl-1.0.2r/util/mkerr.pl b/openssl-1.0.2r/util/mkerr.pl
index c197f3a9..b76afcf4 100644
--- a/openssl-1.0.2r/util/mkerr.pl
+++ b/openssl-1.0.2r/util/mkerr.pl
@@ -9,6 +9,7 @@ my $recurse = 0;
 my $reindex = 0;
 my $dowrite = 0;
 my $staticloader = "";
+my $const = "";
 
 my $pack_errcode;
 my $load_errcode;
@@ -39,6 +40,9 @@ while (@ARGV) {
 	} elsif($arg eq "-nostatic") {
 		$static = 0;
 		shift @ARGV;
+	} elsif($arg eq "-withconst") {
+		$const = "const ";
+		shift @ARGV;
 	} elsif($arg eq "-staticloader") {
 		$staticloader = "static ";
 		shift @ARGV;
@@ -95,6 +99,11 @@ Options:
                 runtime.
                 Default: 'static' code generation.
 
+  -withconst    Generates a different function spec, where we add const
+                for file name specifications. Note the const below:
+                  void ERR_<LIB>_error(int f, int r, const char *fn, int ln);
+                You'll want this if you use anything other than __FILE__.
+
   -staticloader Prefix generated functions with the 'static' scope modifier.
                 Default: don't write any scope modifier prefix.
 
@@ -481,7 +490,7 @@ EOF
 		print OUT <<"EOF";
 ${staticloader}void ERR_load_${lib}_strings(void);
 ${staticloader}void ERR_unload_${lib}_strings(void);
-${staticloader}void ERR_${lib}_error(int function, int reason, char *file, int line);
+${staticloader}void ERR_${lib}_error(int function, int reason, ${const}char *file, int line);
 # define ${lib}err(f,r) ERR_${lib}_error((f),(r),__FILE__,__LINE__)
 
 EOF
@@ -778,7 +787,7 @@ ${staticloader}void ERR_unload_${lib}_strings(void)
     }
 }
 
-${staticloader}void ERR_${lib}_error(int function, int reason, char *file, int line)
+${staticloader}void ERR_${lib}_error(int function, int reason, ${const}char *file, int line)
 {
     if (${lib}_lib_error_code == 0)
         ${lib}_lib_error_code = ERR_get_next_error_library();
diff --git a/openssl-1.0.2r/util/mkfiles.pl b/openssl-1.0.2r/util/mkfiles.pl
index 7d9a9d5e..47c7509b 100755
--- a/openssl-1.0.2r/util/mkfiles.pl
+++ b/openssl-1.0.2r/util/mkfiles.pl
@@ -9,6 +9,21 @@
 my @dirs = (
 ".",
 "crypto",
+"crypto/cmc",
+"crypto/dilithium",
+"crypto/frododh",
+"crypto/frodokem",
+"crypto/hss",
+"crypto/kyber",
+"crypto/nhdh",
+"crypto/ntrup",
+"crypto/rainbow",
+"crypto/samwise",
+"crypto/sidh",
+"crypto/sike",
+"crypto/sphincs",
+"crypto/xmss",
+"crypto/xmssmt",
 "crypto/md2",
 "crypto/md4",
 "crypto/md5",
diff --git a/openssl-1.0.2r/util/ssleay.num b/openssl-1.0.2r/util/ssleay.num
index e3fdaf2d..27abb072 100755
--- a/openssl-1.0.2r/util/ssleay.num
+++ b/openssl-1.0.2r/util/ssleay.num
@@ -368,3 +368,7 @@ SSL_CTX_use_serverinfo_file             406	EXIST::FUNCTION:STDIO,TLSEXT
 SSL_COMP_free_compression_methods       407	EXIST:!VMS:FUNCTION:
 SSL_COMP_free_compress_methods          407	EXIST:VMS:FUNCTION:
 SSL_extension_supported                 409	EXIST::FUNCTION:TLSEXT
+SSL_CTX_use_ALTPrivateKey_ASN1          410	EXIST::FUNCTION:
+SSL_CTX_use_ALTPrivateKey_file          411	EXIST::FUNCTION:STDIO
+SSL_get_alt_pubkey                      412	EXIST::FUNCTION:
+SSL_CTX_use_ALTPrivateKey               413	EXIST::FUNCTION:
